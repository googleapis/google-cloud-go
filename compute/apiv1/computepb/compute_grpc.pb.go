// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Generated by the disco-to-proto3-converter. DO NOT EDIT!
// Source Discovery file: compute.v1.json
// Source file revision: 20251230
// API name: compute
// API version: v1

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.7
// source: google/cloud/compute/v1/compute.proto

package computepb

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	AcceleratorTypes_AggregatedList_FullMethodName = "/google.cloud.compute.v1.AcceleratorTypes/AggregatedList"
	AcceleratorTypes_Get_FullMethodName            = "/google.cloud.compute.v1.AcceleratorTypes/Get"
	AcceleratorTypes_List_FullMethodName           = "/google.cloud.compute.v1.AcceleratorTypes/List"
)

// AcceleratorTypesClient is the client API for AcceleratorTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AcceleratorTypesClient interface {
	// Retrieves an aggregated list of accelerator types.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListAcceleratorTypesRequest, opts ...grpc.CallOption) (*AcceleratorTypeAggregatedList, error)
	// Returns the specified accelerator type.
	Get(ctx context.Context, in *GetAcceleratorTypeRequest, opts ...grpc.CallOption) (*AcceleratorType, error)
	// Retrieves a list of accelerator types that are available to the specified
	// project.
	List(ctx context.Context, in *ListAcceleratorTypesRequest, opts ...grpc.CallOption) (*AcceleratorTypeList, error)
}

type acceleratorTypesClient struct {
	cc grpc.ClientConnInterface
}

func NewAcceleratorTypesClient(cc grpc.ClientConnInterface) AcceleratorTypesClient {
	return &acceleratorTypesClient{cc}
}

func (c *acceleratorTypesClient) AggregatedList(ctx context.Context, in *AggregatedListAcceleratorTypesRequest, opts ...grpc.CallOption) (*AcceleratorTypeAggregatedList, error) {
	out := new(AcceleratorTypeAggregatedList)
	err := c.cc.Invoke(ctx, AcceleratorTypes_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acceleratorTypesClient) Get(ctx context.Context, in *GetAcceleratorTypeRequest, opts ...grpc.CallOption) (*AcceleratorType, error) {
	out := new(AcceleratorType)
	err := c.cc.Invoke(ctx, AcceleratorTypes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *acceleratorTypesClient) List(ctx context.Context, in *ListAcceleratorTypesRequest, opts ...grpc.CallOption) (*AcceleratorTypeList, error) {
	out := new(AcceleratorTypeList)
	err := c.cc.Invoke(ctx, AcceleratorTypes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AcceleratorTypesServer is the server API for AcceleratorTypes service.
// All implementations should embed UnimplementedAcceleratorTypesServer
// for forward compatibility
type AcceleratorTypesServer interface {
	// Retrieves an aggregated list of accelerator types.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListAcceleratorTypesRequest) (*AcceleratorTypeAggregatedList, error)
	// Returns the specified accelerator type.
	Get(context.Context, *GetAcceleratorTypeRequest) (*AcceleratorType, error)
	// Retrieves a list of accelerator types that are available to the specified
	// project.
	List(context.Context, *ListAcceleratorTypesRequest) (*AcceleratorTypeList, error)
}

// UnimplementedAcceleratorTypesServer should be embedded to have forward compatible implementations.
type UnimplementedAcceleratorTypesServer struct {
}

func (UnimplementedAcceleratorTypesServer) AggregatedList(context.Context, *AggregatedListAcceleratorTypesRequest) (*AcceleratorTypeAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedAcceleratorTypesServer) Get(context.Context, *GetAcceleratorTypeRequest) (*AcceleratorType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAcceleratorTypesServer) List(context.Context, *ListAcceleratorTypesRequest) (*AcceleratorTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeAcceleratorTypesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AcceleratorTypesServer will
// result in compilation errors.
type UnsafeAcceleratorTypesServer interface {
	mustEmbedUnimplementedAcceleratorTypesServer()
}

func RegisterAcceleratorTypesServer(s grpc.ServiceRegistrar, srv AcceleratorTypesServer) {
	s.RegisterService(&AcceleratorTypes_ServiceDesc, srv)
}

func _AcceleratorTypes_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListAcceleratorTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceleratorTypesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcceleratorTypes_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceleratorTypesServer).AggregatedList(ctx, req.(*AggregatedListAcceleratorTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcceleratorTypes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAcceleratorTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceleratorTypesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcceleratorTypes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceleratorTypesServer).Get(ctx, req.(*GetAcceleratorTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AcceleratorTypes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAcceleratorTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AcceleratorTypesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: AcceleratorTypes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AcceleratorTypesServer).List(ctx, req.(*ListAcceleratorTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// AcceleratorTypes_ServiceDesc is the grpc.ServiceDesc for AcceleratorTypes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var AcceleratorTypes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.AcceleratorTypes",
	HandlerType: (*AcceleratorTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _AcceleratorTypes_AggregatedList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _AcceleratorTypes_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _AcceleratorTypes_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Addresses_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.Addresses/AggregatedList"
	Addresses_Delete_FullMethodName             = "/google.cloud.compute.v1.Addresses/Delete"
	Addresses_Get_FullMethodName                = "/google.cloud.compute.v1.Addresses/Get"
	Addresses_Insert_FullMethodName             = "/google.cloud.compute.v1.Addresses/Insert"
	Addresses_List_FullMethodName               = "/google.cloud.compute.v1.Addresses/List"
	Addresses_Move_FullMethodName               = "/google.cloud.compute.v1.Addresses/Move"
	Addresses_SetLabels_FullMethodName          = "/google.cloud.compute.v1.Addresses/SetLabels"
	Addresses_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Addresses/TestIamPermissions"
)

// AddressesClient is the client API for Addresses service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AddressesClient interface {
	// Retrieves an aggregated list of addresses.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListAddressesRequest, opts ...grpc.CallOption) (*AddressAggregatedList, error)
	// Deletes the specified address resource.
	Delete(ctx context.Context, in *DeleteAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified address resource.
	Get(ctx context.Context, in *GetAddressRequest, opts ...grpc.CallOption) (*Address, error)
	// Creates an address resource in the specified project by using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of addresses contained within
	// the specified region.
	List(ctx context.Context, in *ListAddressesRequest, opts ...grpc.CallOption) (*AddressList, error)
	// Moves the specified address resource.
	Move(ctx context.Context, in *MoveAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on an Address. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsAddressRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type addressesClient struct {
	cc grpc.ClientConnInterface
}

func NewAddressesClient(cc grpc.ClientConnInterface) AddressesClient {
	return &addressesClient{cc}
}

func (c *addressesClient) AggregatedList(ctx context.Context, in *AggregatedListAddressesRequest, opts ...grpc.CallOption) (*AddressAggregatedList, error) {
	out := new(AddressAggregatedList)
	err := c.cc.Invoke(ctx, Addresses_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) Delete(ctx context.Context, in *DeleteAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Addresses_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) Get(ctx context.Context, in *GetAddressRequest, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := c.cc.Invoke(ctx, Addresses_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) Insert(ctx context.Context, in *InsertAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Addresses_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) List(ctx context.Context, in *ListAddressesRequest, opts ...grpc.CallOption) (*AddressList, error) {
	out := new(AddressList)
	err := c.cc.Invoke(ctx, Addresses_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) Move(ctx context.Context, in *MoveAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Addresses_Move_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) SetLabels(ctx context.Context, in *SetLabelsAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Addresses_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *addressesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsAddressRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Addresses_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AddressesServer is the server API for Addresses service.
// All implementations should embed UnimplementedAddressesServer
// for forward compatibility
type AddressesServer interface {
	// Retrieves an aggregated list of addresses.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListAddressesRequest) (*AddressAggregatedList, error)
	// Deletes the specified address resource.
	Delete(context.Context, *DeleteAddressRequest) (*Operation, error)
	// Returns the specified address resource.
	Get(context.Context, *GetAddressRequest) (*Address, error)
	// Creates an address resource in the specified project by using the data
	// included in the request.
	Insert(context.Context, *InsertAddressRequest) (*Operation, error)
	// Retrieves a list of addresses contained within
	// the specified region.
	List(context.Context, *ListAddressesRequest) (*AddressList, error)
	// Moves the specified address resource.
	Move(context.Context, *MoveAddressRequest) (*Operation, error)
	// Sets the labels on an Address. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsAddressRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsAddressRequest) (*TestPermissionsResponse, error)
}

// UnimplementedAddressesServer should be embedded to have forward compatible implementations.
type UnimplementedAddressesServer struct {
}

func (UnimplementedAddressesServer) AggregatedList(context.Context, *AggregatedListAddressesRequest) (*AddressAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedAddressesServer) Delete(context.Context, *DeleteAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAddressesServer) Get(context.Context, *GetAddressRequest) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAddressesServer) Insert(context.Context, *InsertAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedAddressesServer) List(context.Context, *ListAddressesRequest) (*AddressList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAddressesServer) Move(context.Context, *MoveAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedAddressesServer) SetLabels(context.Context, *SetLabelsAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedAddressesServer) TestIamPermissions(context.Context, *TestIamPermissionsAddressRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeAddressesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AddressesServer will
// result in compilation errors.
type UnsafeAddressesServer interface {
	mustEmbedUnimplementedAddressesServer()
}

func RegisterAddressesServer(s grpc.ServiceRegistrar, srv AddressesServer) {
	s.RegisterService(&Addresses_ServiceDesc, srv)
}

func _Addresses_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).AggregatedList(ctx, req.(*AggregatedListAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).Delete(ctx, req.(*DeleteAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).Get(ctx, req.(*GetAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).Insert(ctx, req.(*InsertAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).List(ctx, req.(*ListAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_Move_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).Move(ctx, req.(*MoveAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).SetLabels(ctx, req.(*SetLabelsAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Addresses_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AddressesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Addresses_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AddressesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Addresses_ServiceDesc is the grpc.ServiceDesc for Addresses service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Addresses_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Addresses",
	HandlerType: (*AddressesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _Addresses_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Addresses_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Addresses_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Addresses_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Addresses_List_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _Addresses_Move_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _Addresses_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Addresses_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Advice_CalendarMode_FullMethodName = "/google.cloud.compute.v1.Advice/CalendarMode"
)

// AdviceClient is the client API for Advice service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AdviceClient interface {
	// Advise how, where and when to create the requested amount of instances
	// with specified accelerators, within the specified time and location limits.
	// The method recommends creating future reservations for the requested
	// resources.
	CalendarMode(ctx context.Context, in *CalendarModeAdviceRpcRequest, opts ...grpc.CallOption) (*CalendarModeAdviceResponse, error)
}

type adviceClient struct {
	cc grpc.ClientConnInterface
}

func NewAdviceClient(cc grpc.ClientConnInterface) AdviceClient {
	return &adviceClient{cc}
}

func (c *adviceClient) CalendarMode(ctx context.Context, in *CalendarModeAdviceRpcRequest, opts ...grpc.CallOption) (*CalendarModeAdviceResponse, error) {
	out := new(CalendarModeAdviceResponse)
	err := c.cc.Invoke(ctx, Advice_CalendarMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AdviceServer is the server API for Advice service.
// All implementations should embed UnimplementedAdviceServer
// for forward compatibility
type AdviceServer interface {
	// Advise how, where and when to create the requested amount of instances
	// with specified accelerators, within the specified time and location limits.
	// The method recommends creating future reservations for the requested
	// resources.
	CalendarMode(context.Context, *CalendarModeAdviceRpcRequest) (*CalendarModeAdviceResponse, error)
}

// UnimplementedAdviceServer should be embedded to have forward compatible implementations.
type UnimplementedAdviceServer struct {
}

func (UnimplementedAdviceServer) CalendarMode(context.Context, *CalendarModeAdviceRpcRequest) (*CalendarModeAdviceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CalendarMode not implemented")
}

// UnsafeAdviceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AdviceServer will
// result in compilation errors.
type UnsafeAdviceServer interface {
	mustEmbedUnimplementedAdviceServer()
}

func RegisterAdviceServer(s grpc.ServiceRegistrar, srv AdviceServer) {
	s.RegisterService(&Advice_ServiceDesc, srv)
}

func _Advice_CalendarMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CalendarModeAdviceRpcRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AdviceServer).CalendarMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Advice_CalendarMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AdviceServer).CalendarMode(ctx, req.(*CalendarModeAdviceRpcRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Advice_ServiceDesc is the grpc.ServiceDesc for Advice service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Advice_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Advice",
	HandlerType: (*AdviceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CalendarMode",
			Handler:    _Advice_CalendarMode_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Autoscalers_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.Autoscalers/AggregatedList"
	Autoscalers_Delete_FullMethodName             = "/google.cloud.compute.v1.Autoscalers/Delete"
	Autoscalers_Get_FullMethodName                = "/google.cloud.compute.v1.Autoscalers/Get"
	Autoscalers_Insert_FullMethodName             = "/google.cloud.compute.v1.Autoscalers/Insert"
	Autoscalers_List_FullMethodName               = "/google.cloud.compute.v1.Autoscalers/List"
	Autoscalers_Patch_FullMethodName              = "/google.cloud.compute.v1.Autoscalers/Patch"
	Autoscalers_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Autoscalers/TestIamPermissions"
	Autoscalers_Update_FullMethodName             = "/google.cloud.compute.v1.Autoscalers/Update"
)

// AutoscalersClient is the client API for Autoscalers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type AutoscalersClient interface {
	// Retrieves an aggregated list of autoscalers.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListAutoscalersRequest, opts ...grpc.CallOption) (*AutoscalerAggregatedList, error)
	// Deletes the specified autoscaler.
	Delete(ctx context.Context, in *DeleteAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified autoscaler resource.
	Get(ctx context.Context, in *GetAutoscalerRequest, opts ...grpc.CallOption) (*Autoscaler, error)
	// Creates an autoscaler in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of autoscalers contained within
	// the specified zone.
	List(ctx context.Context, in *ListAutoscalersRequest, opts ...grpc.CallOption) (*AutoscalerList, error)
	// Updates an autoscaler in the specified project using the data
	// included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsAutoscalerRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates an autoscaler in the specified project using the data
	// included in the request.
	Update(ctx context.Context, in *UpdateAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
}

type autoscalersClient struct {
	cc grpc.ClientConnInterface
}

func NewAutoscalersClient(cc grpc.ClientConnInterface) AutoscalersClient {
	return &autoscalersClient{cc}
}

func (c *autoscalersClient) AggregatedList(ctx context.Context, in *AggregatedListAutoscalersRequest, opts ...grpc.CallOption) (*AutoscalerAggregatedList, error) {
	out := new(AutoscalerAggregatedList)
	err := c.cc.Invoke(ctx, Autoscalers_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) Delete(ctx context.Context, in *DeleteAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Autoscalers_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) Get(ctx context.Context, in *GetAutoscalerRequest, opts ...grpc.CallOption) (*Autoscaler, error) {
	out := new(Autoscaler)
	err := c.cc.Invoke(ctx, Autoscalers_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) Insert(ctx context.Context, in *InsertAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Autoscalers_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) List(ctx context.Context, in *ListAutoscalersRequest, opts ...grpc.CallOption) (*AutoscalerList, error) {
	out := new(AutoscalerList)
	err := c.cc.Invoke(ctx, Autoscalers_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) Patch(ctx context.Context, in *PatchAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Autoscalers_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsAutoscalerRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Autoscalers_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoscalersClient) Update(ctx context.Context, in *UpdateAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Autoscalers_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// AutoscalersServer is the server API for Autoscalers service.
// All implementations should embed UnimplementedAutoscalersServer
// for forward compatibility
type AutoscalersServer interface {
	// Retrieves an aggregated list of autoscalers.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListAutoscalersRequest) (*AutoscalerAggregatedList, error)
	// Deletes the specified autoscaler.
	Delete(context.Context, *DeleteAutoscalerRequest) (*Operation, error)
	// Returns the specified autoscaler resource.
	Get(context.Context, *GetAutoscalerRequest) (*Autoscaler, error)
	// Creates an autoscaler in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertAutoscalerRequest) (*Operation, error)
	// Retrieves a list of autoscalers contained within
	// the specified zone.
	List(context.Context, *ListAutoscalersRequest) (*AutoscalerList, error)
	// Updates an autoscaler in the specified project using the data
	// included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchAutoscalerRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsAutoscalerRequest) (*TestPermissionsResponse, error)
	// Updates an autoscaler in the specified project using the data
	// included in the request.
	Update(context.Context, *UpdateAutoscalerRequest) (*Operation, error)
}

// UnimplementedAutoscalersServer should be embedded to have forward compatible implementations.
type UnimplementedAutoscalersServer struct {
}

func (UnimplementedAutoscalersServer) AggregatedList(context.Context, *AggregatedListAutoscalersRequest) (*AutoscalerAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedAutoscalersServer) Delete(context.Context, *DeleteAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedAutoscalersServer) Get(context.Context, *GetAutoscalerRequest) (*Autoscaler, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedAutoscalersServer) Insert(context.Context, *InsertAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedAutoscalersServer) List(context.Context, *ListAutoscalersRequest) (*AutoscalerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedAutoscalersServer) Patch(context.Context, *PatchAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedAutoscalersServer) TestIamPermissions(context.Context, *TestIamPermissionsAutoscalerRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedAutoscalersServer) Update(context.Context, *UpdateAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeAutoscalersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to AutoscalersServer will
// result in compilation errors.
type UnsafeAutoscalersServer interface {
	mustEmbedUnimplementedAutoscalersServer()
}

func RegisterAutoscalersServer(s grpc.ServiceRegistrar, srv AutoscalersServer) {
	s.RegisterService(&Autoscalers_ServiceDesc, srv)
}

func _Autoscalers_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListAutoscalersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).AggregatedList(ctx, req.(*AggregatedListAutoscalersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).Delete(ctx, req.(*DeleteAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).Get(ctx, req.(*GetAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).Insert(ctx, req.(*InsertAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAutoscalersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).List(ctx, req.(*ListAutoscalersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).Patch(ctx, req.(*PatchAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).TestIamPermissions(ctx, req.(*TestIamPermissionsAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Autoscalers_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoscalersServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Autoscalers_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoscalersServer).Update(ctx, req.(*UpdateAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Autoscalers_ServiceDesc is the grpc.ServiceDesc for Autoscalers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Autoscalers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Autoscalers",
	HandlerType: (*AutoscalersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _Autoscalers_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Autoscalers_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Autoscalers_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Autoscalers_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Autoscalers_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Autoscalers_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Autoscalers_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Autoscalers_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	BackendBuckets_AddSignedUrlKey_FullMethodName       = "/google.cloud.compute.v1.BackendBuckets/AddSignedUrlKey"
	BackendBuckets_Delete_FullMethodName                = "/google.cloud.compute.v1.BackendBuckets/Delete"
	BackendBuckets_DeleteSignedUrlKey_FullMethodName    = "/google.cloud.compute.v1.BackendBuckets/DeleteSignedUrlKey"
	BackendBuckets_Get_FullMethodName                   = "/google.cloud.compute.v1.BackendBuckets/Get"
	BackendBuckets_GetIamPolicy_FullMethodName          = "/google.cloud.compute.v1.BackendBuckets/GetIamPolicy"
	BackendBuckets_Insert_FullMethodName                = "/google.cloud.compute.v1.BackendBuckets/Insert"
	BackendBuckets_List_FullMethodName                  = "/google.cloud.compute.v1.BackendBuckets/List"
	BackendBuckets_Patch_FullMethodName                 = "/google.cloud.compute.v1.BackendBuckets/Patch"
	BackendBuckets_SetEdgeSecurityPolicy_FullMethodName = "/google.cloud.compute.v1.BackendBuckets/SetEdgeSecurityPolicy"
	BackendBuckets_SetIamPolicy_FullMethodName          = "/google.cloud.compute.v1.BackendBuckets/SetIamPolicy"
	BackendBuckets_TestIamPermissions_FullMethodName    = "/google.cloud.compute.v1.BackendBuckets/TestIamPermissions"
	BackendBuckets_Update_FullMethodName                = "/google.cloud.compute.v1.BackendBuckets/Update"
)

// BackendBucketsClient is the client API for BackendBuckets service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackendBucketsClient interface {
	// Adds a key for validating requests with signed URLs for this backend
	// bucket.
	AddSignedUrlKey(ctx context.Context, in *AddSignedUrlKeyBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified BackendBucket resource.
	Delete(ctx context.Context, in *DeleteBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a key for validating requests with signed URLs for this backend
	// bucket.
	DeleteSignedUrlKey(ctx context.Context, in *DeleteSignedUrlKeyBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified BackendBucket resource.
	Get(ctx context.Context, in *GetBackendBucketRequest, opts ...grpc.CallOption) (*BackendBucket, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyBackendBucketRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a BackendBucket resource in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of BackendBucket resources available to the specified
	// project.
	List(ctx context.Context, in *ListBackendBucketsRequest, opts ...grpc.CallOption) (*BackendBucketList, error)
	// Updates the specified BackendBucket resource with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the edge security policy for the specified backend bucket.
	SetEdgeSecurityPolicy(ctx context.Context, in *SetEdgeSecurityPolicyBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyBackendBucketRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsBackendBucketRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified BackendBucket resource with the data included in the
	// request.
	Update(ctx context.Context, in *UpdateBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error)
}

type backendBucketsClient struct {
	cc grpc.ClientConnInterface
}

func NewBackendBucketsClient(cc grpc.ClientConnInterface) BackendBucketsClient {
	return &backendBucketsClient{cc}
}

func (c *backendBucketsClient) AddSignedUrlKey(ctx context.Context, in *AddSignedUrlKeyBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_AddSignedUrlKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) Delete(ctx context.Context, in *DeleteBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) DeleteSignedUrlKey(ctx context.Context, in *DeleteSignedUrlKeyBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_DeleteSignedUrlKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) Get(ctx context.Context, in *GetBackendBucketRequest, opts ...grpc.CallOption) (*BackendBucket, error) {
	out := new(BackendBucket)
	err := c.cc.Invoke(ctx, BackendBuckets_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyBackendBucketRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, BackendBuckets_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) Insert(ctx context.Context, in *InsertBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) List(ctx context.Context, in *ListBackendBucketsRequest, opts ...grpc.CallOption) (*BackendBucketList, error) {
	out := new(BackendBucketList)
	err := c.cc.Invoke(ctx, BackendBuckets_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) Patch(ctx context.Context, in *PatchBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) SetEdgeSecurityPolicy(ctx context.Context, in *SetEdgeSecurityPolicyBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_SetEdgeSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyBackendBucketRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, BackendBuckets_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsBackendBucketRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, BackendBuckets_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendBucketsClient) Update(ctx context.Context, in *UpdateBackendBucketRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendBuckets_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackendBucketsServer is the server API for BackendBuckets service.
// All implementations should embed UnimplementedBackendBucketsServer
// for forward compatibility
type BackendBucketsServer interface {
	// Adds a key for validating requests with signed URLs for this backend
	// bucket.
	AddSignedUrlKey(context.Context, *AddSignedUrlKeyBackendBucketRequest) (*Operation, error)
	// Deletes the specified BackendBucket resource.
	Delete(context.Context, *DeleteBackendBucketRequest) (*Operation, error)
	// Deletes a key for validating requests with signed URLs for this backend
	// bucket.
	DeleteSignedUrlKey(context.Context, *DeleteSignedUrlKeyBackendBucketRequest) (*Operation, error)
	// Returns the specified BackendBucket resource.
	Get(context.Context, *GetBackendBucketRequest) (*BackendBucket, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyBackendBucketRequest) (*Policy, error)
	// Creates a BackendBucket resource in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertBackendBucketRequest) (*Operation, error)
	// Retrieves the list of BackendBucket resources available to the specified
	// project.
	List(context.Context, *ListBackendBucketsRequest) (*BackendBucketList, error)
	// Updates the specified BackendBucket resource with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchBackendBucketRequest) (*Operation, error)
	// Sets the edge security policy for the specified backend bucket.
	SetEdgeSecurityPolicy(context.Context, *SetEdgeSecurityPolicyBackendBucketRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyBackendBucketRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsBackendBucketRequest) (*TestPermissionsResponse, error)
	// Updates the specified BackendBucket resource with the data included in the
	// request.
	Update(context.Context, *UpdateBackendBucketRequest) (*Operation, error)
}

// UnimplementedBackendBucketsServer should be embedded to have forward compatible implementations.
type UnimplementedBackendBucketsServer struct {
}

func (UnimplementedBackendBucketsServer) AddSignedUrlKey(context.Context, *AddSignedUrlKeyBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSignedUrlKey not implemented")
}
func (UnimplementedBackendBucketsServer) Delete(context.Context, *DeleteBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedBackendBucketsServer) DeleteSignedUrlKey(context.Context, *DeleteSignedUrlKeyBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSignedUrlKey not implemented")
}
func (UnimplementedBackendBucketsServer) Get(context.Context, *GetBackendBucketRequest) (*BackendBucket, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedBackendBucketsServer) GetIamPolicy(context.Context, *GetIamPolicyBackendBucketRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedBackendBucketsServer) Insert(context.Context, *InsertBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedBackendBucketsServer) List(context.Context, *ListBackendBucketsRequest) (*BackendBucketList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedBackendBucketsServer) Patch(context.Context, *PatchBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedBackendBucketsServer) SetEdgeSecurityPolicy(context.Context, *SetEdgeSecurityPolicyBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEdgeSecurityPolicy not implemented")
}
func (UnimplementedBackendBucketsServer) SetIamPolicy(context.Context, *SetIamPolicyBackendBucketRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedBackendBucketsServer) TestIamPermissions(context.Context, *TestIamPermissionsBackendBucketRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedBackendBucketsServer) Update(context.Context, *UpdateBackendBucketRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeBackendBucketsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackendBucketsServer will
// result in compilation errors.
type UnsafeBackendBucketsServer interface {
	mustEmbedUnimplementedBackendBucketsServer()
}

func RegisterBackendBucketsServer(s grpc.ServiceRegistrar, srv BackendBucketsServer) {
	s.RegisterService(&BackendBuckets_ServiceDesc, srv)
}

func _BackendBuckets_AddSignedUrlKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSignedUrlKeyBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).AddSignedUrlKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_AddSignedUrlKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).AddSignedUrlKey(ctx, req.(*AddSignedUrlKeyBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).Delete(ctx, req.(*DeleteBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_DeleteSignedUrlKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSignedUrlKeyBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).DeleteSignedUrlKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_DeleteSignedUrlKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).DeleteSignedUrlKey(ctx, req.(*DeleteSignedUrlKeyBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).Get(ctx, req.(*GetBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).GetIamPolicy(ctx, req.(*GetIamPolicyBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).Insert(ctx, req.(*InsertBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackendBucketsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).List(ctx, req.(*ListBackendBucketsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).Patch(ctx, req.(*PatchBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_SetEdgeSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEdgeSecurityPolicyBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).SetEdgeSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_SetEdgeSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).SetEdgeSecurityPolicy(ctx, req.(*SetEdgeSecurityPolicyBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).SetIamPolicy(ctx, req.(*SetIamPolicyBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendBuckets_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBackendBucketRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendBucketsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendBuckets_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendBucketsServer).Update(ctx, req.(*UpdateBackendBucketRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackendBuckets_ServiceDesc is the grpc.ServiceDesc for BackendBuckets service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackendBuckets_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.BackendBuckets",
	HandlerType: (*BackendBucketsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSignedUrlKey",
			Handler:    _BackendBuckets_AddSignedUrlKey_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _BackendBuckets_Delete_Handler,
		},
		{
			MethodName: "DeleteSignedUrlKey",
			Handler:    _BackendBuckets_DeleteSignedUrlKey_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _BackendBuckets_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _BackendBuckets_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _BackendBuckets_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _BackendBuckets_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _BackendBuckets_Patch_Handler,
		},
		{
			MethodName: "SetEdgeSecurityPolicy",
			Handler:    _BackendBuckets_SetEdgeSecurityPolicy_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _BackendBuckets_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _BackendBuckets_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _BackendBuckets_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	BackendServices_AddSignedUrlKey_FullMethodName              = "/google.cloud.compute.v1.BackendServices/AddSignedUrlKey"
	BackendServices_AggregatedList_FullMethodName               = "/google.cloud.compute.v1.BackendServices/AggregatedList"
	BackendServices_Delete_FullMethodName                       = "/google.cloud.compute.v1.BackendServices/Delete"
	BackendServices_DeleteSignedUrlKey_FullMethodName           = "/google.cloud.compute.v1.BackendServices/DeleteSignedUrlKey"
	BackendServices_Get_FullMethodName                          = "/google.cloud.compute.v1.BackendServices/Get"
	BackendServices_GetEffectiveSecurityPolicies_FullMethodName = "/google.cloud.compute.v1.BackendServices/GetEffectiveSecurityPolicies"
	BackendServices_GetHealth_FullMethodName                    = "/google.cloud.compute.v1.BackendServices/GetHealth"
	BackendServices_GetIamPolicy_FullMethodName                 = "/google.cloud.compute.v1.BackendServices/GetIamPolicy"
	BackendServices_Insert_FullMethodName                       = "/google.cloud.compute.v1.BackendServices/Insert"
	BackendServices_List_FullMethodName                         = "/google.cloud.compute.v1.BackendServices/List"
	BackendServices_ListUsable_FullMethodName                   = "/google.cloud.compute.v1.BackendServices/ListUsable"
	BackendServices_Patch_FullMethodName                        = "/google.cloud.compute.v1.BackendServices/Patch"
	BackendServices_SetEdgeSecurityPolicy_FullMethodName        = "/google.cloud.compute.v1.BackendServices/SetEdgeSecurityPolicy"
	BackendServices_SetIamPolicy_FullMethodName                 = "/google.cloud.compute.v1.BackendServices/SetIamPolicy"
	BackendServices_SetSecurityPolicy_FullMethodName            = "/google.cloud.compute.v1.BackendServices/SetSecurityPolicy"
	BackendServices_TestIamPermissions_FullMethodName           = "/google.cloud.compute.v1.BackendServices/TestIamPermissions"
	BackendServices_Update_FullMethodName                       = "/google.cloud.compute.v1.BackendServices/Update"
)

// BackendServicesClient is the client API for BackendServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type BackendServicesClient interface {
	// Adds a key for validating requests with signed URLs for this backend
	// service.
	AddSignedUrlKey(ctx context.Context, in *AddSignedUrlKeyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of all BackendService resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceAggregatedList, error)
	// Deletes the specified BackendService resource.
	Delete(ctx context.Context, in *DeleteBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a key for validating requests with signed URLs for this backend
	// service.
	DeleteSignedUrlKey(ctx context.Context, in *DeleteSignedUrlKeyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified BackendService resource.
	Get(ctx context.Context, in *GetBackendServiceRequest, opts ...grpc.CallOption) (*BackendService, error)
	// Returns effective security policies applied to this backend service.
	GetEffectiveSecurityPolicies(ctx context.Context, in *GetEffectiveSecurityPoliciesBackendServiceRequest, opts ...grpc.CallOption) (*GetEffectiveSecurityPoliciesBackendServiceResponse, error)
	// Gets the most recent health check results for this
	// BackendService.
	//
	// Example request body:
	//
	//	{
	//	  "group": "/zones/us-east1-b/instanceGroups/lb-backend-example"
	//	}
	GetHealth(ctx context.Context, in *GetHealthBackendServiceRequest, opts ...grpc.CallOption) (*BackendServiceGroupHealth, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a BackendService resource in the specified project using
	// the data included in the request. For more information, see
	// Backend services overview.
	Insert(ctx context.Context, in *InsertBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of BackendService resources available to the specified
	// project.
	List(ctx context.Context, in *ListBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceList, error)
	// Retrieves a list of all usable backend services in the specified project.
	ListUsable(ctx context.Context, in *ListUsableBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceListUsable, error)
	// Patches the specified BackendService resource with the data included in the
	// request. For more information, see
	// Backend services overview. This method
	// supports PATCH semantics and uses the JSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the edge security policy for the specified backend service.
	SetEdgeSecurityPolicy(ctx context.Context, in *SetEdgeSecurityPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the Google Cloud Armor security policy for the specified backend
	// service. For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsBackendServiceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified BackendService resource with the data included in the
	// request. For more information, seeBackend
	// services overview.
	Update(ctx context.Context, in *UpdateBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
}

type backendServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewBackendServicesClient(cc grpc.ClientConnInterface) BackendServicesClient {
	return &backendServicesClient{cc}
}

func (c *backendServicesClient) AddSignedUrlKey(ctx context.Context, in *AddSignedUrlKeyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_AddSignedUrlKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) AggregatedList(ctx context.Context, in *AggregatedListBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceAggregatedList, error) {
	out := new(BackendServiceAggregatedList)
	err := c.cc.Invoke(ctx, BackendServices_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) Delete(ctx context.Context, in *DeleteBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) DeleteSignedUrlKey(ctx context.Context, in *DeleteSignedUrlKeyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_DeleteSignedUrlKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) Get(ctx context.Context, in *GetBackendServiceRequest, opts ...grpc.CallOption) (*BackendService, error) {
	out := new(BackendService)
	err := c.cc.Invoke(ctx, BackendServices_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) GetEffectiveSecurityPolicies(ctx context.Context, in *GetEffectiveSecurityPoliciesBackendServiceRequest, opts ...grpc.CallOption) (*GetEffectiveSecurityPoliciesBackendServiceResponse, error) {
	out := new(GetEffectiveSecurityPoliciesBackendServiceResponse)
	err := c.cc.Invoke(ctx, BackendServices_GetEffectiveSecurityPolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) GetHealth(ctx context.Context, in *GetHealthBackendServiceRequest, opts ...grpc.CallOption) (*BackendServiceGroupHealth, error) {
	out := new(BackendServiceGroupHealth)
	err := c.cc.Invoke(ctx, BackendServices_GetHealth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, BackendServices_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) Insert(ctx context.Context, in *InsertBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) List(ctx context.Context, in *ListBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceList, error) {
	out := new(BackendServiceList)
	err := c.cc.Invoke(ctx, BackendServices_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) ListUsable(ctx context.Context, in *ListUsableBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceListUsable, error) {
	out := new(BackendServiceListUsable)
	err := c.cc.Invoke(ctx, BackendServices_ListUsable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) Patch(ctx context.Context, in *PatchBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) SetEdgeSecurityPolicy(ctx context.Context, in *SetEdgeSecurityPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_SetEdgeSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, BackendServices_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_SetSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsBackendServiceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, BackendServices_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *backendServicesClient) Update(ctx context.Context, in *UpdateBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, BackendServices_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// BackendServicesServer is the server API for BackendServices service.
// All implementations should embed UnimplementedBackendServicesServer
// for forward compatibility
type BackendServicesServer interface {
	// Adds a key for validating requests with signed URLs for this backend
	// service.
	AddSignedUrlKey(context.Context, *AddSignedUrlKeyBackendServiceRequest) (*Operation, error)
	// Retrieves the list of all BackendService resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListBackendServicesRequest) (*BackendServiceAggregatedList, error)
	// Deletes the specified BackendService resource.
	Delete(context.Context, *DeleteBackendServiceRequest) (*Operation, error)
	// Deletes a key for validating requests with signed URLs for this backend
	// service.
	DeleteSignedUrlKey(context.Context, *DeleteSignedUrlKeyBackendServiceRequest) (*Operation, error)
	// Returns the specified BackendService resource.
	Get(context.Context, *GetBackendServiceRequest) (*BackendService, error)
	// Returns effective security policies applied to this backend service.
	GetEffectiveSecurityPolicies(context.Context, *GetEffectiveSecurityPoliciesBackendServiceRequest) (*GetEffectiveSecurityPoliciesBackendServiceResponse, error)
	// Gets the most recent health check results for this
	// BackendService.
	//
	// Example request body:
	//
	//	{
	//	  "group": "/zones/us-east1-b/instanceGroups/lb-backend-example"
	//	}
	GetHealth(context.Context, *GetHealthBackendServiceRequest) (*BackendServiceGroupHealth, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyBackendServiceRequest) (*Policy, error)
	// Creates a BackendService resource in the specified project using
	// the data included in the request. For more information, see
	// Backend services overview.
	Insert(context.Context, *InsertBackendServiceRequest) (*Operation, error)
	// Retrieves the list of BackendService resources available to the specified
	// project.
	List(context.Context, *ListBackendServicesRequest) (*BackendServiceList, error)
	// Retrieves a list of all usable backend services in the specified project.
	ListUsable(context.Context, *ListUsableBackendServicesRequest) (*BackendServiceListUsable, error)
	// Patches the specified BackendService resource with the data included in the
	// request. For more information, see
	// Backend services overview. This method
	// supports PATCH semantics and uses the JSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchBackendServiceRequest) (*Operation, error)
	// Sets the edge security policy for the specified backend service.
	SetEdgeSecurityPolicy(context.Context, *SetEdgeSecurityPolicyBackendServiceRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyBackendServiceRequest) (*Policy, error)
	// Sets the Google Cloud Armor security policy for the specified backend
	// service. For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(context.Context, *SetSecurityPolicyBackendServiceRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsBackendServiceRequest) (*TestPermissionsResponse, error)
	// Updates the specified BackendService resource with the data included in the
	// request. For more information, seeBackend
	// services overview.
	Update(context.Context, *UpdateBackendServiceRequest) (*Operation, error)
}

// UnimplementedBackendServicesServer should be embedded to have forward compatible implementations.
type UnimplementedBackendServicesServer struct {
}

func (UnimplementedBackendServicesServer) AddSignedUrlKey(context.Context, *AddSignedUrlKeyBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddSignedUrlKey not implemented")
}
func (UnimplementedBackendServicesServer) AggregatedList(context.Context, *AggregatedListBackendServicesRequest) (*BackendServiceAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedBackendServicesServer) Delete(context.Context, *DeleteBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedBackendServicesServer) DeleteSignedUrlKey(context.Context, *DeleteSignedUrlKeyBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteSignedUrlKey not implemented")
}
func (UnimplementedBackendServicesServer) Get(context.Context, *GetBackendServiceRequest) (*BackendService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedBackendServicesServer) GetEffectiveSecurityPolicies(context.Context, *GetEffectiveSecurityPoliciesBackendServiceRequest) (*GetEffectiveSecurityPoliciesBackendServiceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEffectiveSecurityPolicies not implemented")
}
func (UnimplementedBackendServicesServer) GetHealth(context.Context, *GetHealthBackendServiceRequest) (*BackendServiceGroupHealth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedBackendServicesServer) GetIamPolicy(context.Context, *GetIamPolicyBackendServiceRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedBackendServicesServer) Insert(context.Context, *InsertBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedBackendServicesServer) List(context.Context, *ListBackendServicesRequest) (*BackendServiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedBackendServicesServer) ListUsable(context.Context, *ListUsableBackendServicesRequest) (*BackendServiceListUsable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsable not implemented")
}
func (UnimplementedBackendServicesServer) Patch(context.Context, *PatchBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedBackendServicesServer) SetEdgeSecurityPolicy(context.Context, *SetEdgeSecurityPolicyBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetEdgeSecurityPolicy not implemented")
}
func (UnimplementedBackendServicesServer) SetIamPolicy(context.Context, *SetIamPolicyBackendServiceRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedBackendServicesServer) SetSecurityPolicy(context.Context, *SetSecurityPolicyBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSecurityPolicy not implemented")
}
func (UnimplementedBackendServicesServer) TestIamPermissions(context.Context, *TestIamPermissionsBackendServiceRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedBackendServicesServer) Update(context.Context, *UpdateBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeBackendServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to BackendServicesServer will
// result in compilation errors.
type UnsafeBackendServicesServer interface {
	mustEmbedUnimplementedBackendServicesServer()
}

func RegisterBackendServicesServer(s grpc.ServiceRegistrar, srv BackendServicesServer) {
	s.RegisterService(&BackendServices_ServiceDesc, srv)
}

func _BackendServices_AddSignedUrlKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddSignedUrlKeyBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).AddSignedUrlKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_AddSignedUrlKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).AddSignedUrlKey(ctx, req.(*AddSignedUrlKeyBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListBackendServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).AggregatedList(ctx, req.(*AggregatedListBackendServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).Delete(ctx, req.(*DeleteBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_DeleteSignedUrlKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSignedUrlKeyBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).DeleteSignedUrlKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_DeleteSignedUrlKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).DeleteSignedUrlKey(ctx, req.(*DeleteSignedUrlKeyBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).Get(ctx, req.(*GetBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_GetEffectiveSecurityPolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEffectiveSecurityPoliciesBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).GetEffectiveSecurityPolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_GetEffectiveSecurityPolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).GetEffectiveSecurityPolicies(ctx, req.(*GetEffectiveSecurityPoliciesBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).GetHealth(ctx, req.(*GetHealthBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).GetIamPolicy(ctx, req.(*GetIamPolicyBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).Insert(ctx, req.(*InsertBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBackendServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).List(ctx, req.(*ListBackendServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_ListUsable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsableBackendServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).ListUsable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_ListUsable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).ListUsable(ctx, req.(*ListUsableBackendServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).Patch(ctx, req.(*PatchBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_SetEdgeSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetEdgeSecurityPolicyBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).SetEdgeSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_SetEdgeSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).SetEdgeSecurityPolicy(ctx, req.(*SetEdgeSecurityPolicyBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).SetIamPolicy(ctx, req.(*SetIamPolicyBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_SetSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSecurityPolicyBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).SetSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_SetSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).SetSecurityPolicy(ctx, req.(*SetSecurityPolicyBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BackendServices_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BackendServicesServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: BackendServices_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BackendServicesServer).Update(ctx, req.(*UpdateBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// BackendServices_ServiceDesc is the grpc.ServiceDesc for BackendServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var BackendServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.BackendServices",
	HandlerType: (*BackendServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddSignedUrlKey",
			Handler:    _BackendServices_AddSignedUrlKey_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _BackendServices_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _BackendServices_Delete_Handler,
		},
		{
			MethodName: "DeleteSignedUrlKey",
			Handler:    _BackendServices_DeleteSignedUrlKey_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _BackendServices_Get_Handler,
		},
		{
			MethodName: "GetEffectiveSecurityPolicies",
			Handler:    _BackendServices_GetEffectiveSecurityPolicies_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _BackendServices_GetHealth_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _BackendServices_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _BackendServices_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _BackendServices_List_Handler,
		},
		{
			MethodName: "ListUsable",
			Handler:    _BackendServices_ListUsable_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _BackendServices_Patch_Handler,
		},
		{
			MethodName: "SetEdgeSecurityPolicy",
			Handler:    _BackendServices_SetEdgeSecurityPolicy_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _BackendServices_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetSecurityPolicy",
			Handler:    _BackendServices_SetSecurityPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _BackendServices_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _BackendServices_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	CrossSiteNetworks_Delete_FullMethodName = "/google.cloud.compute.v1.CrossSiteNetworks/Delete"
	CrossSiteNetworks_Get_FullMethodName    = "/google.cloud.compute.v1.CrossSiteNetworks/Get"
	CrossSiteNetworks_Insert_FullMethodName = "/google.cloud.compute.v1.CrossSiteNetworks/Insert"
	CrossSiteNetworks_List_FullMethodName   = "/google.cloud.compute.v1.CrossSiteNetworks/List"
	CrossSiteNetworks_Patch_FullMethodName  = "/google.cloud.compute.v1.CrossSiteNetworks/Patch"
)

// CrossSiteNetworksClient is the client API for CrossSiteNetworks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type CrossSiteNetworksClient interface {
	// Deletes the specified cross-site network in the given scope.
	Delete(ctx context.Context, in *DeleteCrossSiteNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified cross-site network in the given scope.
	Get(ctx context.Context, in *GetCrossSiteNetworkRequest, opts ...grpc.CallOption) (*CrossSiteNetwork, error)
	// Creates a cross-site network in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertCrossSiteNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the cross-site networks for a project in the given scope.
	List(ctx context.Context, in *ListCrossSiteNetworksRequest, opts ...grpc.CallOption) (*CrossSiteNetworkList, error)
	// Updates the specified cross-site network with the data included in
	// the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchCrossSiteNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
}

type crossSiteNetworksClient struct {
	cc grpc.ClientConnInterface
}

func NewCrossSiteNetworksClient(cc grpc.ClientConnInterface) CrossSiteNetworksClient {
	return &crossSiteNetworksClient{cc}
}

func (c *crossSiteNetworksClient) Delete(ctx context.Context, in *DeleteCrossSiteNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, CrossSiteNetworks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *crossSiteNetworksClient) Get(ctx context.Context, in *GetCrossSiteNetworkRequest, opts ...grpc.CallOption) (*CrossSiteNetwork, error) {
	out := new(CrossSiteNetwork)
	err := c.cc.Invoke(ctx, CrossSiteNetworks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *crossSiteNetworksClient) Insert(ctx context.Context, in *InsertCrossSiteNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, CrossSiteNetworks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *crossSiteNetworksClient) List(ctx context.Context, in *ListCrossSiteNetworksRequest, opts ...grpc.CallOption) (*CrossSiteNetworkList, error) {
	out := new(CrossSiteNetworkList)
	err := c.cc.Invoke(ctx, CrossSiteNetworks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *crossSiteNetworksClient) Patch(ctx context.Context, in *PatchCrossSiteNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, CrossSiteNetworks_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// CrossSiteNetworksServer is the server API for CrossSiteNetworks service.
// All implementations should embed UnimplementedCrossSiteNetworksServer
// for forward compatibility
type CrossSiteNetworksServer interface {
	// Deletes the specified cross-site network in the given scope.
	Delete(context.Context, *DeleteCrossSiteNetworkRequest) (*Operation, error)
	// Returns the specified cross-site network in the given scope.
	Get(context.Context, *GetCrossSiteNetworkRequest) (*CrossSiteNetwork, error)
	// Creates a cross-site network in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertCrossSiteNetworkRequest) (*Operation, error)
	// Lists the cross-site networks for a project in the given scope.
	List(context.Context, *ListCrossSiteNetworksRequest) (*CrossSiteNetworkList, error)
	// Updates the specified cross-site network with the data included in
	// the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchCrossSiteNetworkRequest) (*Operation, error)
}

// UnimplementedCrossSiteNetworksServer should be embedded to have forward compatible implementations.
type UnimplementedCrossSiteNetworksServer struct {
}

func (UnimplementedCrossSiteNetworksServer) Delete(context.Context, *DeleteCrossSiteNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedCrossSiteNetworksServer) Get(context.Context, *GetCrossSiteNetworkRequest) (*CrossSiteNetwork, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedCrossSiteNetworksServer) Insert(context.Context, *InsertCrossSiteNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedCrossSiteNetworksServer) List(context.Context, *ListCrossSiteNetworksRequest) (*CrossSiteNetworkList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedCrossSiteNetworksServer) Patch(context.Context, *PatchCrossSiteNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeCrossSiteNetworksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to CrossSiteNetworksServer will
// result in compilation errors.
type UnsafeCrossSiteNetworksServer interface {
	mustEmbedUnimplementedCrossSiteNetworksServer()
}

func RegisterCrossSiteNetworksServer(s grpc.ServiceRegistrar, srv CrossSiteNetworksServer) {
	s.RegisterService(&CrossSiteNetworks_ServiceDesc, srv)
}

func _CrossSiteNetworks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteCrossSiteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrossSiteNetworksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CrossSiteNetworks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrossSiteNetworksServer).Delete(ctx, req.(*DeleteCrossSiteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CrossSiteNetworks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetCrossSiteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrossSiteNetworksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CrossSiteNetworks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrossSiteNetworksServer).Get(ctx, req.(*GetCrossSiteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CrossSiteNetworks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertCrossSiteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrossSiteNetworksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CrossSiteNetworks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrossSiteNetworksServer).Insert(ctx, req.(*InsertCrossSiteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CrossSiteNetworks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListCrossSiteNetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrossSiteNetworksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CrossSiteNetworks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrossSiteNetworksServer).List(ctx, req.(*ListCrossSiteNetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _CrossSiteNetworks_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchCrossSiteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(CrossSiteNetworksServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: CrossSiteNetworks_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(CrossSiteNetworksServer).Patch(ctx, req.(*PatchCrossSiteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// CrossSiteNetworks_ServiceDesc is the grpc.ServiceDesc for CrossSiteNetworks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var CrossSiteNetworks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.CrossSiteNetworks",
	HandlerType: (*CrossSiteNetworksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _CrossSiteNetworks_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _CrossSiteNetworks_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _CrossSiteNetworks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _CrossSiteNetworks_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _CrossSiteNetworks_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	DiskTypes_AggregatedList_FullMethodName = "/google.cloud.compute.v1.DiskTypes/AggregatedList"
	DiskTypes_Get_FullMethodName            = "/google.cloud.compute.v1.DiskTypes/Get"
	DiskTypes_List_FullMethodName           = "/google.cloud.compute.v1.DiskTypes/List"
)

// DiskTypesClient is the client API for DiskTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DiskTypesClient interface {
	// Retrieves an aggregated list of disk types.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListDiskTypesRequest, opts ...grpc.CallOption) (*DiskTypeAggregatedList, error)
	// Returns the specified disk type.
	Get(ctx context.Context, in *GetDiskTypeRequest, opts ...grpc.CallOption) (*DiskType, error)
	// Retrieves a list of disk types available to the specified
	// project.
	List(ctx context.Context, in *ListDiskTypesRequest, opts ...grpc.CallOption) (*DiskTypeList, error)
}

type diskTypesClient struct {
	cc grpc.ClientConnInterface
}

func NewDiskTypesClient(cc grpc.ClientConnInterface) DiskTypesClient {
	return &diskTypesClient{cc}
}

func (c *diskTypesClient) AggregatedList(ctx context.Context, in *AggregatedListDiskTypesRequest, opts ...grpc.CallOption) (*DiskTypeAggregatedList, error) {
	out := new(DiskTypeAggregatedList)
	err := c.cc.Invoke(ctx, DiskTypes_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskTypesClient) Get(ctx context.Context, in *GetDiskTypeRequest, opts ...grpc.CallOption) (*DiskType, error) {
	out := new(DiskType)
	err := c.cc.Invoke(ctx, DiskTypes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *diskTypesClient) List(ctx context.Context, in *ListDiskTypesRequest, opts ...grpc.CallOption) (*DiskTypeList, error) {
	out := new(DiskTypeList)
	err := c.cc.Invoke(ctx, DiskTypes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DiskTypesServer is the server API for DiskTypes service.
// All implementations should embed UnimplementedDiskTypesServer
// for forward compatibility
type DiskTypesServer interface {
	// Retrieves an aggregated list of disk types.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListDiskTypesRequest) (*DiskTypeAggregatedList, error)
	// Returns the specified disk type.
	Get(context.Context, *GetDiskTypeRequest) (*DiskType, error)
	// Retrieves a list of disk types available to the specified
	// project.
	List(context.Context, *ListDiskTypesRequest) (*DiskTypeList, error)
}

// UnimplementedDiskTypesServer should be embedded to have forward compatible implementations.
type UnimplementedDiskTypesServer struct {
}

func (UnimplementedDiskTypesServer) AggregatedList(context.Context, *AggregatedListDiskTypesRequest) (*DiskTypeAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedDiskTypesServer) Get(context.Context, *GetDiskTypeRequest) (*DiskType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDiskTypesServer) List(context.Context, *ListDiskTypesRequest) (*DiskTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeDiskTypesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DiskTypesServer will
// result in compilation errors.
type UnsafeDiskTypesServer interface {
	mustEmbedUnimplementedDiskTypesServer()
}

func RegisterDiskTypesServer(s grpc.ServiceRegistrar, srv DiskTypesServer) {
	s.RegisterService(&DiskTypes_ServiceDesc, srv)
}

func _DiskTypes_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListDiskTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskTypesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiskTypes_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskTypesServer).AggregatedList(ctx, req.(*AggregatedListDiskTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskTypes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiskTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskTypesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiskTypes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskTypesServer).Get(ctx, req.(*GetDiskTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DiskTypes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDiskTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DiskTypesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DiskTypes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DiskTypesServer).List(ctx, req.(*ListDiskTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// DiskTypes_ServiceDesc is the grpc.ServiceDesc for DiskTypes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DiskTypes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.DiskTypes",
	HandlerType: (*DiskTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _DiskTypes_AggregatedList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _DiskTypes_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _DiskTypes_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Disks_AddResourcePolicies_FullMethodName       = "/google.cloud.compute.v1.Disks/AddResourcePolicies"
	Disks_AggregatedList_FullMethodName            = "/google.cloud.compute.v1.Disks/AggregatedList"
	Disks_BulkInsert_FullMethodName                = "/google.cloud.compute.v1.Disks/BulkInsert"
	Disks_BulkSetLabels_FullMethodName             = "/google.cloud.compute.v1.Disks/BulkSetLabels"
	Disks_CreateSnapshot_FullMethodName            = "/google.cloud.compute.v1.Disks/CreateSnapshot"
	Disks_Delete_FullMethodName                    = "/google.cloud.compute.v1.Disks/Delete"
	Disks_Get_FullMethodName                       = "/google.cloud.compute.v1.Disks/Get"
	Disks_GetIamPolicy_FullMethodName              = "/google.cloud.compute.v1.Disks/GetIamPolicy"
	Disks_Insert_FullMethodName                    = "/google.cloud.compute.v1.Disks/Insert"
	Disks_List_FullMethodName                      = "/google.cloud.compute.v1.Disks/List"
	Disks_RemoveResourcePolicies_FullMethodName    = "/google.cloud.compute.v1.Disks/RemoveResourcePolicies"
	Disks_Resize_FullMethodName                    = "/google.cloud.compute.v1.Disks/Resize"
	Disks_SetIamPolicy_FullMethodName              = "/google.cloud.compute.v1.Disks/SetIamPolicy"
	Disks_SetLabels_FullMethodName                 = "/google.cloud.compute.v1.Disks/SetLabels"
	Disks_StartAsyncReplication_FullMethodName     = "/google.cloud.compute.v1.Disks/StartAsyncReplication"
	Disks_StopAsyncReplication_FullMethodName      = "/google.cloud.compute.v1.Disks/StopAsyncReplication"
	Disks_StopGroupAsyncReplication_FullMethodName = "/google.cloud.compute.v1.Disks/StopGroupAsyncReplication"
	Disks_TestIamPermissions_FullMethodName        = "/google.cloud.compute.v1.Disks/TestIamPermissions"
	Disks_Update_FullMethodName                    = "/google.cloud.compute.v1.Disks/Update"
)

// DisksClient is the client API for Disks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DisksClient interface {
	// Adds existing resource policies to a disk. You can only add one
	// policy which will be applied to this disk for scheduling snapshot
	// creation.
	AddResourcePolicies(ctx context.Context, in *AddResourcePoliciesDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves an aggregated list of persistent disks.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListDisksRequest, opts ...grpc.CallOption) (*DiskAggregatedList, error)
	// Bulk create a set of disks.
	BulkInsert(ctx context.Context, in *BulkInsertDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on many disks at once. To learn more about labels, read theLabeling
	// Resources documentation.
	BulkSetLabels(ctx context.Context, in *BulkSetLabelsDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Creates a snapshot of a specified persistent disk. For regular snapshot
	// creation, consider using snapshots.insert
	// instead, as that method supports more features, such as creating snapshots
	// in a project different from the source disk project.
	CreateSnapshot(ctx context.Context, in *CreateSnapshotDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified persistent disk. Deleting a disk removes its data
	// permanently and is irreversible. However, deleting a disk does not
	// delete any snapshots
	// previously made from the disk. You must separatelydelete
	// snapshots.
	Delete(ctx context.Context, in *DeleteDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified persistent disk.
	Get(ctx context.Context, in *GetDiskRequest, opts ...grpc.CallOption) (*Disk, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyDiskRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a persistent disk in the specified project using the data
	// in the request. You can create a disk from a source
	// (sourceImage, sourceSnapshot, orsourceDisk) or create an empty 500 GB data disk by
	// omitting all properties. You can also create a disk that is larger than
	// the default size by specifying the sizeGb property.
	Insert(ctx context.Context, in *InsertDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of persistent disks contained within
	// the specified zone.
	List(ctx context.Context, in *ListDisksRequest, opts ...grpc.CallOption) (*DiskList, error)
	// Removes resource policies from a disk.
	RemoveResourcePolicies(ctx context.Context, in *RemoveResourcePoliciesDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Resizes the specified persistent disk.
	// You can only increase the size of the disk.
	Resize(ctx context.Context, in *ResizeDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyDiskRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on a disk. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Starts asynchronous replication.
	// Must be invoked on the primary disk.
	StartAsyncReplication(ctx context.Context, in *StartAsyncReplicationDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Stops asynchronous replication.
	// Can be invoked either on the primary or on the secondary disk.
	StopAsyncReplication(ctx context.Context, in *StopAsyncReplicationDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Stops asynchronous replication for a consistency group of disks.
	// Can be invoked either in the primary or secondary scope.
	StopGroupAsyncReplication(ctx context.Context, in *StopGroupAsyncReplicationDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsDiskRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified disk with the data included in the request.
	// The update is performed only on selected fields included as part
	// of update-mask. Only the following fields can be modified: user_license.
	Update(ctx context.Context, in *UpdateDiskRequest, opts ...grpc.CallOption) (*Operation, error)
}

type disksClient struct {
	cc grpc.ClientConnInterface
}

func NewDisksClient(cc grpc.ClientConnInterface) DisksClient {
	return &disksClient{cc}
}

func (c *disksClient) AddResourcePolicies(ctx context.Context, in *AddResourcePoliciesDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_AddResourcePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) AggregatedList(ctx context.Context, in *AggregatedListDisksRequest, opts ...grpc.CallOption) (*DiskAggregatedList, error) {
	out := new(DiskAggregatedList)
	err := c.cc.Invoke(ctx, Disks_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) BulkInsert(ctx context.Context, in *BulkInsertDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_BulkInsert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) BulkSetLabels(ctx context.Context, in *BulkSetLabelsDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_BulkSetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_CreateSnapshot_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Delete(ctx context.Context, in *DeleteDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Get(ctx context.Context, in *GetDiskRequest, opts ...grpc.CallOption) (*Disk, error) {
	out := new(Disk)
	err := c.cc.Invoke(ctx, Disks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyDiskRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Disks_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Insert(ctx context.Context, in *InsertDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) List(ctx context.Context, in *ListDisksRequest, opts ...grpc.CallOption) (*DiskList, error) {
	out := new(DiskList)
	err := c.cc.Invoke(ctx, Disks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) RemoveResourcePolicies(ctx context.Context, in *RemoveResourcePoliciesDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_RemoveResourcePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Resize(ctx context.Context, in *ResizeDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_Resize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyDiskRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Disks_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) SetLabels(ctx context.Context, in *SetLabelsDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) StartAsyncReplication(ctx context.Context, in *StartAsyncReplicationDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_StartAsyncReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) StopAsyncReplication(ctx context.Context, in *StopAsyncReplicationDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_StopAsyncReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) StopGroupAsyncReplication(ctx context.Context, in *StopGroupAsyncReplicationDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_StopGroupAsyncReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsDiskRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Disks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *disksClient) Update(ctx context.Context, in *UpdateDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Disks_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// DisksServer is the server API for Disks service.
// All implementations should embed UnimplementedDisksServer
// for forward compatibility
type DisksServer interface {
	// Adds existing resource policies to a disk. You can only add one
	// policy which will be applied to this disk for scheduling snapshot
	// creation.
	AddResourcePolicies(context.Context, *AddResourcePoliciesDiskRequest) (*Operation, error)
	// Retrieves an aggregated list of persistent disks.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListDisksRequest) (*DiskAggregatedList, error)
	// Bulk create a set of disks.
	BulkInsert(context.Context, *BulkInsertDiskRequest) (*Operation, error)
	// Sets the labels on many disks at once. To learn more about labels, read theLabeling
	// Resources documentation.
	BulkSetLabels(context.Context, *BulkSetLabelsDiskRequest) (*Operation, error)
	// Creates a snapshot of a specified persistent disk. For regular snapshot
	// creation, consider using snapshots.insert
	// instead, as that method supports more features, such as creating snapshots
	// in a project different from the source disk project.
	CreateSnapshot(context.Context, *CreateSnapshotDiskRequest) (*Operation, error)
	// Deletes the specified persistent disk. Deleting a disk removes its data
	// permanently and is irreversible. However, deleting a disk does not
	// delete any snapshots
	// previously made from the disk. You must separatelydelete
	// snapshots.
	Delete(context.Context, *DeleteDiskRequest) (*Operation, error)
	// Returns the specified persistent disk.
	Get(context.Context, *GetDiskRequest) (*Disk, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyDiskRequest) (*Policy, error)
	// Creates a persistent disk in the specified project using the data
	// in the request. You can create a disk from a source
	// (sourceImage, sourceSnapshot, orsourceDisk) or create an empty 500 GB data disk by
	// omitting all properties. You can also create a disk that is larger than
	// the default size by specifying the sizeGb property.
	Insert(context.Context, *InsertDiskRequest) (*Operation, error)
	// Retrieves a list of persistent disks contained within
	// the specified zone.
	List(context.Context, *ListDisksRequest) (*DiskList, error)
	// Removes resource policies from a disk.
	RemoveResourcePolicies(context.Context, *RemoveResourcePoliciesDiskRequest) (*Operation, error)
	// Resizes the specified persistent disk.
	// You can only increase the size of the disk.
	Resize(context.Context, *ResizeDiskRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyDiskRequest) (*Policy, error)
	// Sets the labels on a disk. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsDiskRequest) (*Operation, error)
	// Starts asynchronous replication.
	// Must be invoked on the primary disk.
	StartAsyncReplication(context.Context, *StartAsyncReplicationDiskRequest) (*Operation, error)
	// Stops asynchronous replication.
	// Can be invoked either on the primary or on the secondary disk.
	StopAsyncReplication(context.Context, *StopAsyncReplicationDiskRequest) (*Operation, error)
	// Stops asynchronous replication for a consistency group of disks.
	// Can be invoked either in the primary or secondary scope.
	StopGroupAsyncReplication(context.Context, *StopGroupAsyncReplicationDiskRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsDiskRequest) (*TestPermissionsResponse, error)
	// Updates the specified disk with the data included in the request.
	// The update is performed only on selected fields included as part
	// of update-mask. Only the following fields can be modified: user_license.
	Update(context.Context, *UpdateDiskRequest) (*Operation, error)
}

// UnimplementedDisksServer should be embedded to have forward compatible implementations.
type UnimplementedDisksServer struct {
}

func (UnimplementedDisksServer) AddResourcePolicies(context.Context, *AddResourcePoliciesDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddResourcePolicies not implemented")
}
func (UnimplementedDisksServer) AggregatedList(context.Context, *AggregatedListDisksRequest) (*DiskAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedDisksServer) BulkInsert(context.Context, *BulkInsertDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkInsert not implemented")
}
func (UnimplementedDisksServer) BulkSetLabels(context.Context, *BulkSetLabelsDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkSetLabels not implemented")
}
func (UnimplementedDisksServer) CreateSnapshot(context.Context, *CreateSnapshotDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (UnimplementedDisksServer) Delete(context.Context, *DeleteDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedDisksServer) Get(context.Context, *GetDiskRequest) (*Disk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedDisksServer) GetIamPolicy(context.Context, *GetIamPolicyDiskRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedDisksServer) Insert(context.Context, *InsertDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedDisksServer) List(context.Context, *ListDisksRequest) (*DiskList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedDisksServer) RemoveResourcePolicies(context.Context, *RemoveResourcePoliciesDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveResourcePolicies not implemented")
}
func (UnimplementedDisksServer) Resize(context.Context, *ResizeDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resize not implemented")
}
func (UnimplementedDisksServer) SetIamPolicy(context.Context, *SetIamPolicyDiskRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedDisksServer) SetLabels(context.Context, *SetLabelsDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedDisksServer) StartAsyncReplication(context.Context, *StartAsyncReplicationDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAsyncReplication not implemented")
}
func (UnimplementedDisksServer) StopAsyncReplication(context.Context, *StopAsyncReplicationDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAsyncReplication not implemented")
}
func (UnimplementedDisksServer) StopGroupAsyncReplication(context.Context, *StopGroupAsyncReplicationDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopGroupAsyncReplication not implemented")
}
func (UnimplementedDisksServer) TestIamPermissions(context.Context, *TestIamPermissionsDiskRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedDisksServer) Update(context.Context, *UpdateDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeDisksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DisksServer will
// result in compilation errors.
type UnsafeDisksServer interface {
	mustEmbedUnimplementedDisksServer()
}

func RegisterDisksServer(s grpc.ServiceRegistrar, srv DisksServer) {
	s.RegisterService(&Disks_ServiceDesc, srv)
}

func _Disks_AddResourcePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddResourcePoliciesDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).AddResourcePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_AddResourcePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).AddResourcePolicies(ctx, req.(*AddResourcePoliciesDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).AggregatedList(ctx, req.(*AggregatedListDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_BulkInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkInsertDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).BulkInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_BulkInsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).BulkInsert(ctx, req.(*BulkInsertDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_BulkSetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkSetLabelsDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).BulkSetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_BulkSetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).BulkSetLabels(ctx, req.(*BulkSetLabelsDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_CreateSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).CreateSnapshot(ctx, req.(*CreateSnapshotDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Delete(ctx, req.(*DeleteDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Get(ctx, req.(*GetDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).GetIamPolicy(ctx, req.(*GetIamPolicyDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Insert(ctx, req.(*InsertDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).List(ctx, req.(*ListDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_RemoveResourcePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveResourcePoliciesDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).RemoveResourcePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_RemoveResourcePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).RemoveResourcePolicies(ctx, req.(*RemoveResourcePoliciesDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Resize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Resize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_Resize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Resize(ctx, req.(*ResizeDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).SetIamPolicy(ctx, req.(*SetIamPolicyDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).SetLabels(ctx, req.(*SetLabelsDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_StartAsyncReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAsyncReplicationDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).StartAsyncReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_StartAsyncReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).StartAsyncReplication(ctx, req.(*StartAsyncReplicationDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_StopAsyncReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopAsyncReplicationDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).StopAsyncReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_StopAsyncReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).StopAsyncReplication(ctx, req.(*StopAsyncReplicationDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_StopGroupAsyncReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopGroupAsyncReplicationDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).StopGroupAsyncReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_StopGroupAsyncReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).StopGroupAsyncReplication(ctx, req.(*StopGroupAsyncReplicationDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Disks_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DisksServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Disks_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DisksServer).Update(ctx, req.(*UpdateDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Disks_ServiceDesc is the grpc.ServiceDesc for Disks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Disks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Disks",
	HandlerType: (*DisksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddResourcePolicies",
			Handler:    _Disks_AddResourcePolicies_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _Disks_AggregatedList_Handler,
		},
		{
			MethodName: "BulkInsert",
			Handler:    _Disks_BulkInsert_Handler,
		},
		{
			MethodName: "BulkSetLabels",
			Handler:    _Disks_BulkSetLabels_Handler,
		},
		{
			MethodName: "CreateSnapshot",
			Handler:    _Disks_CreateSnapshot_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Disks_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Disks_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Disks_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Disks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Disks_List_Handler,
		},
		{
			MethodName: "RemoveResourcePolicies",
			Handler:    _Disks_RemoveResourcePolicies_Handler,
		},
		{
			MethodName: "Resize",
			Handler:    _Disks_Resize_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Disks_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _Disks_SetLabels_Handler,
		},
		{
			MethodName: "StartAsyncReplication",
			Handler:    _Disks_StartAsyncReplication_Handler,
		},
		{
			MethodName: "StopAsyncReplication",
			Handler:    _Disks_StopAsyncReplication_Handler,
		},
		{
			MethodName: "StopGroupAsyncReplication",
			Handler:    _Disks_StopGroupAsyncReplication_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Disks_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Disks_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ExternalVpnGateways_Delete_FullMethodName             = "/google.cloud.compute.v1.ExternalVpnGateways/Delete"
	ExternalVpnGateways_Get_FullMethodName                = "/google.cloud.compute.v1.ExternalVpnGateways/Get"
	ExternalVpnGateways_Insert_FullMethodName             = "/google.cloud.compute.v1.ExternalVpnGateways/Insert"
	ExternalVpnGateways_List_FullMethodName               = "/google.cloud.compute.v1.ExternalVpnGateways/List"
	ExternalVpnGateways_SetLabels_FullMethodName          = "/google.cloud.compute.v1.ExternalVpnGateways/SetLabels"
	ExternalVpnGateways_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.ExternalVpnGateways/TestIamPermissions"
)

// ExternalVpnGatewaysClient is the client API for ExternalVpnGateways service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ExternalVpnGatewaysClient interface {
	// Deletes the specified externalVpnGateway.
	Delete(ctx context.Context, in *DeleteExternalVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified externalVpnGateway. Get a list of available
	// externalVpnGateways by making a list() request.
	Get(ctx context.Context, in *GetExternalVpnGatewayRequest, opts ...grpc.CallOption) (*ExternalVpnGateway, error)
	// Creates a ExternalVpnGateway in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertExternalVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of ExternalVpnGateway available to the specified
	// project.
	List(ctx context.Context, in *ListExternalVpnGatewaysRequest, opts ...grpc.CallOption) (*ExternalVpnGatewayList, error)
	// Sets the labels on an ExternalVpnGateway. To learn more about labels,
	// read the Labeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsExternalVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsExternalVpnGatewayRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type externalVpnGatewaysClient struct {
	cc grpc.ClientConnInterface
}

func NewExternalVpnGatewaysClient(cc grpc.ClientConnInterface) ExternalVpnGatewaysClient {
	return &externalVpnGatewaysClient{cc}
}

func (c *externalVpnGatewaysClient) Delete(ctx context.Context, in *DeleteExternalVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ExternalVpnGateways_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalVpnGatewaysClient) Get(ctx context.Context, in *GetExternalVpnGatewayRequest, opts ...grpc.CallOption) (*ExternalVpnGateway, error) {
	out := new(ExternalVpnGateway)
	err := c.cc.Invoke(ctx, ExternalVpnGateways_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalVpnGatewaysClient) Insert(ctx context.Context, in *InsertExternalVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ExternalVpnGateways_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalVpnGatewaysClient) List(ctx context.Context, in *ListExternalVpnGatewaysRequest, opts ...grpc.CallOption) (*ExternalVpnGatewayList, error) {
	out := new(ExternalVpnGatewayList)
	err := c.cc.Invoke(ctx, ExternalVpnGateways_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalVpnGatewaysClient) SetLabels(ctx context.Context, in *SetLabelsExternalVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ExternalVpnGateways_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *externalVpnGatewaysClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsExternalVpnGatewayRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, ExternalVpnGateways_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ExternalVpnGatewaysServer is the server API for ExternalVpnGateways service.
// All implementations should embed UnimplementedExternalVpnGatewaysServer
// for forward compatibility
type ExternalVpnGatewaysServer interface {
	// Deletes the specified externalVpnGateway.
	Delete(context.Context, *DeleteExternalVpnGatewayRequest) (*Operation, error)
	// Returns the specified externalVpnGateway. Get a list of available
	// externalVpnGateways by making a list() request.
	Get(context.Context, *GetExternalVpnGatewayRequest) (*ExternalVpnGateway, error)
	// Creates a ExternalVpnGateway in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertExternalVpnGatewayRequest) (*Operation, error)
	// Retrieves the list of ExternalVpnGateway available to the specified
	// project.
	List(context.Context, *ListExternalVpnGatewaysRequest) (*ExternalVpnGatewayList, error)
	// Sets the labels on an ExternalVpnGateway. To learn more about labels,
	// read the Labeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsExternalVpnGatewayRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsExternalVpnGatewayRequest) (*TestPermissionsResponse, error)
}

// UnimplementedExternalVpnGatewaysServer should be embedded to have forward compatible implementations.
type UnimplementedExternalVpnGatewaysServer struct {
}

func (UnimplementedExternalVpnGatewaysServer) Delete(context.Context, *DeleteExternalVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedExternalVpnGatewaysServer) Get(context.Context, *GetExternalVpnGatewayRequest) (*ExternalVpnGateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedExternalVpnGatewaysServer) Insert(context.Context, *InsertExternalVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedExternalVpnGatewaysServer) List(context.Context, *ListExternalVpnGatewaysRequest) (*ExternalVpnGatewayList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedExternalVpnGatewaysServer) SetLabels(context.Context, *SetLabelsExternalVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedExternalVpnGatewaysServer) TestIamPermissions(context.Context, *TestIamPermissionsExternalVpnGatewayRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeExternalVpnGatewaysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ExternalVpnGatewaysServer will
// result in compilation errors.
type UnsafeExternalVpnGatewaysServer interface {
	mustEmbedUnimplementedExternalVpnGatewaysServer()
}

func RegisterExternalVpnGatewaysServer(s grpc.ServiceRegistrar, srv ExternalVpnGatewaysServer) {
	s.RegisterService(&ExternalVpnGateways_ServiceDesc, srv)
}

func _ExternalVpnGateways_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteExternalVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalVpnGatewaysServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExternalVpnGateways_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalVpnGatewaysServer).Delete(ctx, req.(*DeleteExternalVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalVpnGateways_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetExternalVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalVpnGatewaysServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExternalVpnGateways_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalVpnGatewaysServer).Get(ctx, req.(*GetExternalVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalVpnGateways_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertExternalVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalVpnGatewaysServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExternalVpnGateways_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalVpnGatewaysServer).Insert(ctx, req.(*InsertExternalVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalVpnGateways_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListExternalVpnGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalVpnGatewaysServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExternalVpnGateways_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalVpnGatewaysServer).List(ctx, req.(*ListExternalVpnGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalVpnGateways_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsExternalVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalVpnGatewaysServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExternalVpnGateways_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalVpnGatewaysServer).SetLabels(ctx, req.(*SetLabelsExternalVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ExternalVpnGateways_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsExternalVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ExternalVpnGatewaysServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ExternalVpnGateways_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ExternalVpnGatewaysServer).TestIamPermissions(ctx, req.(*TestIamPermissionsExternalVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ExternalVpnGateways_ServiceDesc is the grpc.ServiceDesc for ExternalVpnGateways service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ExternalVpnGateways_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ExternalVpnGateways",
	HandlerType: (*ExternalVpnGatewaysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _ExternalVpnGateways_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ExternalVpnGateways_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _ExternalVpnGateways_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ExternalVpnGateways_List_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _ExternalVpnGateways_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _ExternalVpnGateways_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	FirewallPolicies_AddAssociation_FullMethodName     = "/google.cloud.compute.v1.FirewallPolicies/AddAssociation"
	FirewallPolicies_AddRule_FullMethodName            = "/google.cloud.compute.v1.FirewallPolicies/AddRule"
	FirewallPolicies_CloneRules_FullMethodName         = "/google.cloud.compute.v1.FirewallPolicies/CloneRules"
	FirewallPolicies_Delete_FullMethodName             = "/google.cloud.compute.v1.FirewallPolicies/Delete"
	FirewallPolicies_Get_FullMethodName                = "/google.cloud.compute.v1.FirewallPolicies/Get"
	FirewallPolicies_GetAssociation_FullMethodName     = "/google.cloud.compute.v1.FirewallPolicies/GetAssociation"
	FirewallPolicies_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.FirewallPolicies/GetIamPolicy"
	FirewallPolicies_GetRule_FullMethodName            = "/google.cloud.compute.v1.FirewallPolicies/GetRule"
	FirewallPolicies_Insert_FullMethodName             = "/google.cloud.compute.v1.FirewallPolicies/Insert"
	FirewallPolicies_List_FullMethodName               = "/google.cloud.compute.v1.FirewallPolicies/List"
	FirewallPolicies_ListAssociations_FullMethodName   = "/google.cloud.compute.v1.FirewallPolicies/ListAssociations"
	FirewallPolicies_Move_FullMethodName               = "/google.cloud.compute.v1.FirewallPolicies/Move"
	FirewallPolicies_Patch_FullMethodName              = "/google.cloud.compute.v1.FirewallPolicies/Patch"
	FirewallPolicies_PatchRule_FullMethodName          = "/google.cloud.compute.v1.FirewallPolicies/PatchRule"
	FirewallPolicies_RemoveAssociation_FullMethodName  = "/google.cloud.compute.v1.FirewallPolicies/RemoveAssociation"
	FirewallPolicies_RemoveRule_FullMethodName         = "/google.cloud.compute.v1.FirewallPolicies/RemoveRule"
	FirewallPolicies_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.FirewallPolicies/SetIamPolicy"
	FirewallPolicies_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.FirewallPolicies/TestIamPermissions"
)

// FirewallPoliciesClient is the client API for FirewallPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FirewallPoliciesClient interface {
	// Inserts an association for the specified firewall policy.
	AddAssociation(ctx context.Context, in *AddAssociationFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts a rule into a firewall policy.
	AddRule(ctx context.Context, in *AddRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Copies rules to the specified firewall policy.
	CloneRules(ctx context.Context, in *CloneRulesFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified policy.
	Delete(ctx context.Context, in *DeleteFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified firewall policy.
	Get(ctx context.Context, in *GetFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicy, error)
	// Gets an association with the specified name.
	GetAssociation(ctx context.Context, in *GetAssociationFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyAssociation, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Gets a rule of the specified priority.
	GetRule(ctx context.Context, in *GetRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(ctx context.Context, in *InsertFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all the policies that have been configured for the specified
	// folder or organization.
	List(ctx context.Context, in *ListFirewallPoliciesRequest, opts ...grpc.CallOption) (*FirewallPolicyList, error)
	// Lists associations of a specified target, i.e., organization or folder.
	ListAssociations(ctx context.Context, in *ListAssociationsFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPoliciesListAssociationsResponse, error)
	// Moves the specified firewall policy.
	Move(ctx context.Context, in *MoveFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches the specified policy with the data included in the request.
	Patch(ctx context.Context, in *PatchFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a rule of the specified priority.
	PatchRule(ctx context.Context, in *PatchRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes an association for the specified firewall policy.
	RemoveAssociation(ctx context.Context, in *RemoveAssociationFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a rule of the specified priority.
	RemoveRule(ctx context.Context, in *RemoveRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsFirewallPolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type firewallPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewFirewallPoliciesClient(cc grpc.ClientConnInterface) FirewallPoliciesClient {
	return &firewallPoliciesClient{cc}
}

func (c *firewallPoliciesClient) AddAssociation(ctx context.Context, in *AddAssociationFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_AddAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) AddRule(ctx context.Context, in *AddRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_AddRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) CloneRules(ctx context.Context, in *CloneRulesFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_CloneRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) Delete(ctx context.Context, in *DeleteFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) Get(ctx context.Context, in *GetFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicy, error) {
	out := new(FirewallPolicy)
	err := c.cc.Invoke(ctx, FirewallPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) GetAssociation(ctx context.Context, in *GetAssociationFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyAssociation, error) {
	out := new(FirewallPolicyAssociation)
	err := c.cc.Invoke(ctx, FirewallPolicies_GetAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, FirewallPolicies_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) GetRule(ctx context.Context, in *GetRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error) {
	out := new(FirewallPolicyRule)
	err := c.cc.Invoke(ctx, FirewallPolicies_GetRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) Insert(ctx context.Context, in *InsertFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) List(ctx context.Context, in *ListFirewallPoliciesRequest, opts ...grpc.CallOption) (*FirewallPolicyList, error) {
	out := new(FirewallPolicyList)
	err := c.cc.Invoke(ctx, FirewallPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) ListAssociations(ctx context.Context, in *ListAssociationsFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPoliciesListAssociationsResponse, error) {
	out := new(FirewallPoliciesListAssociationsResponse)
	err := c.cc.Invoke(ctx, FirewallPolicies_ListAssociations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) Move(ctx context.Context, in *MoveFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_Move_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) Patch(ctx context.Context, in *PatchFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) PatchRule(ctx context.Context, in *PatchRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_PatchRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) RemoveAssociation(ctx context.Context, in *RemoveAssociationFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_RemoveAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) RemoveRule(ctx context.Context, in *RemoveRuleFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FirewallPolicies_RemoveRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, FirewallPolicies_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallPoliciesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsFirewallPolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, FirewallPolicies_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FirewallPoliciesServer is the server API for FirewallPolicies service.
// All implementations should embed UnimplementedFirewallPoliciesServer
// for forward compatibility
type FirewallPoliciesServer interface {
	// Inserts an association for the specified firewall policy.
	AddAssociation(context.Context, *AddAssociationFirewallPolicyRequest) (*Operation, error)
	// Inserts a rule into a firewall policy.
	AddRule(context.Context, *AddRuleFirewallPolicyRequest) (*Operation, error)
	// Copies rules to the specified firewall policy.
	CloneRules(context.Context, *CloneRulesFirewallPolicyRequest) (*Operation, error)
	// Deletes the specified policy.
	Delete(context.Context, *DeleteFirewallPolicyRequest) (*Operation, error)
	// Returns the specified firewall policy.
	Get(context.Context, *GetFirewallPolicyRequest) (*FirewallPolicy, error)
	// Gets an association with the specified name.
	GetAssociation(context.Context, *GetAssociationFirewallPolicyRequest) (*FirewallPolicyAssociation, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyFirewallPolicyRequest) (*Policy, error)
	// Gets a rule of the specified priority.
	GetRule(context.Context, *GetRuleFirewallPolicyRequest) (*FirewallPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(context.Context, *InsertFirewallPolicyRequest) (*Operation, error)
	// Lists all the policies that have been configured for the specified
	// folder or organization.
	List(context.Context, *ListFirewallPoliciesRequest) (*FirewallPolicyList, error)
	// Lists associations of a specified target, i.e., organization or folder.
	ListAssociations(context.Context, *ListAssociationsFirewallPolicyRequest) (*FirewallPoliciesListAssociationsResponse, error)
	// Moves the specified firewall policy.
	Move(context.Context, *MoveFirewallPolicyRequest) (*Operation, error)
	// Patches the specified policy with the data included in the request.
	Patch(context.Context, *PatchFirewallPolicyRequest) (*Operation, error)
	// Patches a rule of the specified priority.
	PatchRule(context.Context, *PatchRuleFirewallPolicyRequest) (*Operation, error)
	// Removes an association for the specified firewall policy.
	RemoveAssociation(context.Context, *RemoveAssociationFirewallPolicyRequest) (*Operation, error)
	// Deletes a rule of the specified priority.
	RemoveRule(context.Context, *RemoveRuleFirewallPolicyRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyFirewallPolicyRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsFirewallPolicyRequest) (*TestPermissionsResponse, error)
}

// UnimplementedFirewallPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedFirewallPoliciesServer struct {
}

func (UnimplementedFirewallPoliciesServer) AddAssociation(context.Context, *AddAssociationFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAssociation not implemented")
}
func (UnimplementedFirewallPoliciesServer) AddRule(context.Context, *AddRuleFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedFirewallPoliciesServer) CloneRules(context.Context, *CloneRulesFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloneRules not implemented")
}
func (UnimplementedFirewallPoliciesServer) Delete(context.Context, *DeleteFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFirewallPoliciesServer) Get(context.Context, *GetFirewallPolicyRequest) (*FirewallPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFirewallPoliciesServer) GetAssociation(context.Context, *GetAssociationFirewallPolicyRequest) (*FirewallPolicyAssociation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssociation not implemented")
}
func (UnimplementedFirewallPoliciesServer) GetIamPolicy(context.Context, *GetIamPolicyFirewallPolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedFirewallPoliciesServer) GetRule(context.Context, *GetRuleFirewallPolicyRequest) (*FirewallPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedFirewallPoliciesServer) Insert(context.Context, *InsertFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedFirewallPoliciesServer) List(context.Context, *ListFirewallPoliciesRequest) (*FirewallPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedFirewallPoliciesServer) ListAssociations(context.Context, *ListAssociationsFirewallPolicyRequest) (*FirewallPoliciesListAssociationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAssociations not implemented")
}
func (UnimplementedFirewallPoliciesServer) Move(context.Context, *MoveFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedFirewallPoliciesServer) Patch(context.Context, *PatchFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFirewallPoliciesServer) PatchRule(context.Context, *PatchRuleFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRule not implemented")
}
func (UnimplementedFirewallPoliciesServer) RemoveAssociation(context.Context, *RemoveAssociationFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAssociation not implemented")
}
func (UnimplementedFirewallPoliciesServer) RemoveRule(context.Context, *RemoveRuleFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedFirewallPoliciesServer) SetIamPolicy(context.Context, *SetIamPolicyFirewallPolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedFirewallPoliciesServer) TestIamPermissions(context.Context, *TestIamPermissionsFirewallPolicyRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeFirewallPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FirewallPoliciesServer will
// result in compilation errors.
type UnsafeFirewallPoliciesServer interface {
	mustEmbedUnimplementedFirewallPoliciesServer()
}

func RegisterFirewallPoliciesServer(s grpc.ServiceRegistrar, srv FirewallPoliciesServer) {
	s.RegisterService(&FirewallPolicies_ServiceDesc, srv)
}

func _FirewallPolicies_AddAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAssociationFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).AddAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_AddAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).AddAssociation(ctx, req.(*AddAssociationFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).AddRule(ctx, req.(*AddRuleFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_CloneRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneRulesFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).CloneRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_CloneRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).CloneRules(ctx, req.(*CloneRulesFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).Delete(ctx, req.(*DeleteFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).Get(ctx, req.(*GetFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_GetAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssociationFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).GetAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_GetAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).GetAssociation(ctx, req.(*GetAssociationFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).GetIamPolicy(ctx, req.(*GetIamPolicyFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).GetRule(ctx, req.(*GetRuleFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).Insert(ctx, req.(*InsertFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFirewallPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).List(ctx, req.(*ListFirewallPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_ListAssociations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAssociationsFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).ListAssociations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_ListAssociations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).ListAssociations(ctx, req.(*ListAssociationsFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_Move_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).Move(ctx, req.(*MoveFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).Patch(ctx, req.(*PatchFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_PatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRuleFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).PatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_PatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).PatchRule(ctx, req.(*PatchRuleFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_RemoveAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveAssociationFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).RemoveAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_RemoveAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).RemoveAssociation(ctx, req.(*RemoveAssociationFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).RemoveRule(ctx, req.(*RemoveRuleFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).SetIamPolicy(ctx, req.(*SetIamPolicyFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FirewallPolicies_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallPoliciesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FirewallPolicies_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallPoliciesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FirewallPolicies_ServiceDesc is the grpc.ServiceDesc for FirewallPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FirewallPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.FirewallPolicies",
	HandlerType: (*FirewallPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddAssociation",
			Handler:    _FirewallPolicies_AddAssociation_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _FirewallPolicies_AddRule_Handler,
		},
		{
			MethodName: "CloneRules",
			Handler:    _FirewallPolicies_CloneRules_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FirewallPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FirewallPolicies_Get_Handler,
		},
		{
			MethodName: "GetAssociation",
			Handler:    _FirewallPolicies_GetAssociation_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _FirewallPolicies_GetIamPolicy_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _FirewallPolicies_GetRule_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _FirewallPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _FirewallPolicies_List_Handler,
		},
		{
			MethodName: "ListAssociations",
			Handler:    _FirewallPolicies_ListAssociations_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _FirewallPolicies_Move_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _FirewallPolicies_Patch_Handler,
		},
		{
			MethodName: "PatchRule",
			Handler:    _FirewallPolicies_PatchRule_Handler,
		},
		{
			MethodName: "RemoveAssociation",
			Handler:    _FirewallPolicies_RemoveAssociation_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _FirewallPolicies_RemoveRule_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _FirewallPolicies_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _FirewallPolicies_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Firewalls_Delete_FullMethodName             = "/google.cloud.compute.v1.Firewalls/Delete"
	Firewalls_Get_FullMethodName                = "/google.cloud.compute.v1.Firewalls/Get"
	Firewalls_Insert_FullMethodName             = "/google.cloud.compute.v1.Firewalls/Insert"
	Firewalls_List_FullMethodName               = "/google.cloud.compute.v1.Firewalls/List"
	Firewalls_Patch_FullMethodName              = "/google.cloud.compute.v1.Firewalls/Patch"
	Firewalls_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Firewalls/TestIamPermissions"
	Firewalls_Update_FullMethodName             = "/google.cloud.compute.v1.Firewalls/Update"
)

// FirewallsClient is the client API for Firewalls service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FirewallsClient interface {
	// Deletes the specified firewall.
	Delete(ctx context.Context, in *DeleteFirewallRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified firewall.
	Get(ctx context.Context, in *GetFirewallRequest, opts ...grpc.CallOption) (*Firewall, error)
	// Creates a firewall rule in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertFirewallRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of firewall rules available to the specified
	// project.
	List(ctx context.Context, in *ListFirewallsRequest, opts ...grpc.CallOption) (*FirewallList, error)
	// Updates the specified firewall rule with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchFirewallRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsFirewallRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified firewall rule with the data included in the
	// request.
	// Note that all fields will be updated if using PUT, even fields that are not
	// specified. To update individual fields, please use PATCH instead.
	Update(ctx context.Context, in *UpdateFirewallRequest, opts ...grpc.CallOption) (*Operation, error)
}

type firewallsClient struct {
	cc grpc.ClientConnInterface
}

func NewFirewallsClient(cc grpc.ClientConnInterface) FirewallsClient {
	return &firewallsClient{cc}
}

func (c *firewallsClient) Delete(ctx context.Context, in *DeleteFirewallRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Firewalls_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallsClient) Get(ctx context.Context, in *GetFirewallRequest, opts ...grpc.CallOption) (*Firewall, error) {
	out := new(Firewall)
	err := c.cc.Invoke(ctx, Firewalls_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallsClient) Insert(ctx context.Context, in *InsertFirewallRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Firewalls_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallsClient) List(ctx context.Context, in *ListFirewallsRequest, opts ...grpc.CallOption) (*FirewallList, error) {
	out := new(FirewallList)
	err := c.cc.Invoke(ctx, Firewalls_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallsClient) Patch(ctx context.Context, in *PatchFirewallRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Firewalls_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsFirewallRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Firewalls_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *firewallsClient) Update(ctx context.Context, in *UpdateFirewallRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Firewalls_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FirewallsServer is the server API for Firewalls service.
// All implementations should embed UnimplementedFirewallsServer
// for forward compatibility
type FirewallsServer interface {
	// Deletes the specified firewall.
	Delete(context.Context, *DeleteFirewallRequest) (*Operation, error)
	// Returns the specified firewall.
	Get(context.Context, *GetFirewallRequest) (*Firewall, error)
	// Creates a firewall rule in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertFirewallRequest) (*Operation, error)
	// Retrieves the list of firewall rules available to the specified
	// project.
	List(context.Context, *ListFirewallsRequest) (*FirewallList, error)
	// Updates the specified firewall rule with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchFirewallRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsFirewallRequest) (*TestPermissionsResponse, error)
	// Updates the specified firewall rule with the data included in the
	// request.
	// Note that all fields will be updated if using PUT, even fields that are not
	// specified. To update individual fields, please use PATCH instead.
	Update(context.Context, *UpdateFirewallRequest) (*Operation, error)
}

// UnimplementedFirewallsServer should be embedded to have forward compatible implementations.
type UnimplementedFirewallsServer struct {
}

func (UnimplementedFirewallsServer) Delete(context.Context, *DeleteFirewallRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFirewallsServer) Get(context.Context, *GetFirewallRequest) (*Firewall, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFirewallsServer) Insert(context.Context, *InsertFirewallRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedFirewallsServer) List(context.Context, *ListFirewallsRequest) (*FirewallList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedFirewallsServer) Patch(context.Context, *PatchFirewallRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedFirewallsServer) TestIamPermissions(context.Context, *TestIamPermissionsFirewallRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedFirewallsServer) Update(context.Context, *UpdateFirewallRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeFirewallsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FirewallsServer will
// result in compilation errors.
type UnsafeFirewallsServer interface {
	mustEmbedUnimplementedFirewallsServer()
}

func RegisterFirewallsServer(s grpc.ServiceRegistrar, srv FirewallsServer) {
	s.RegisterService(&Firewalls_ServiceDesc, srv)
}

func _Firewalls_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).Delete(ctx, req.(*DeleteFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalls_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).Get(ctx, req.(*GetFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalls_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).Insert(ctx, req.(*InsertFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalls_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFirewallsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).List(ctx, req.(*ListFirewallsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalls_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).Patch(ctx, req.(*PatchFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalls_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Firewalls_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFirewallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FirewallsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Firewalls_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FirewallsServer).Update(ctx, req.(*UpdateFirewallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Firewalls_ServiceDesc is the grpc.ServiceDesc for Firewalls service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Firewalls_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Firewalls",
	HandlerType: (*FirewallsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Firewalls_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Firewalls_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Firewalls_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Firewalls_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Firewalls_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Firewalls_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Firewalls_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ForwardingRules_AggregatedList_FullMethodName = "/google.cloud.compute.v1.ForwardingRules/AggregatedList"
	ForwardingRules_Delete_FullMethodName         = "/google.cloud.compute.v1.ForwardingRules/Delete"
	ForwardingRules_Get_FullMethodName            = "/google.cloud.compute.v1.ForwardingRules/Get"
	ForwardingRules_Insert_FullMethodName         = "/google.cloud.compute.v1.ForwardingRules/Insert"
	ForwardingRules_List_FullMethodName           = "/google.cloud.compute.v1.ForwardingRules/List"
	ForwardingRules_Patch_FullMethodName          = "/google.cloud.compute.v1.ForwardingRules/Patch"
	ForwardingRules_SetLabels_FullMethodName      = "/google.cloud.compute.v1.ForwardingRules/SetLabels"
	ForwardingRules_SetTarget_FullMethodName      = "/google.cloud.compute.v1.ForwardingRules/SetTarget"
)

// ForwardingRulesClient is the client API for ForwardingRules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ForwardingRulesClient interface {
	// Retrieves an aggregated list of forwarding rules.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListForwardingRulesRequest, opts ...grpc.CallOption) (*ForwardingRuleAggregatedList, error)
	// Deletes the specified ForwardingRule resource.
	Delete(ctx context.Context, in *DeleteForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified ForwardingRule resource.
	Get(ctx context.Context, in *GetForwardingRuleRequest, opts ...grpc.CallOption) (*ForwardingRule, error)
	// Creates a ForwardingRule resource in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of ForwardingRule resources available to the specified
	// project and region.
	List(ctx context.Context, in *ListForwardingRulesRequest, opts ...grpc.CallOption) (*ForwardingRuleList, error)
	// Updates the specified forwarding rule with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules. Currently, you can only
	// patch the network_tier field.
	Patch(ctx context.Context, in *PatchForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on the specified resource. To learn more about labels,
	// read the
	// Labeling Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes target URL for forwarding rule. The new target should be of the
	// same type as the old target.
	SetTarget(ctx context.Context, in *SetTargetForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
}

type forwardingRulesClient struct {
	cc grpc.ClientConnInterface
}

func NewForwardingRulesClient(cc grpc.ClientConnInterface) ForwardingRulesClient {
	return &forwardingRulesClient{cc}
}

func (c *forwardingRulesClient) AggregatedList(ctx context.Context, in *AggregatedListForwardingRulesRequest, opts ...grpc.CallOption) (*ForwardingRuleAggregatedList, error) {
	out := new(ForwardingRuleAggregatedList)
	err := c.cc.Invoke(ctx, ForwardingRules_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) Delete(ctx context.Context, in *DeleteForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ForwardingRules_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) Get(ctx context.Context, in *GetForwardingRuleRequest, opts ...grpc.CallOption) (*ForwardingRule, error) {
	out := new(ForwardingRule)
	err := c.cc.Invoke(ctx, ForwardingRules_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) Insert(ctx context.Context, in *InsertForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ForwardingRules_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) List(ctx context.Context, in *ListForwardingRulesRequest, opts ...grpc.CallOption) (*ForwardingRuleList, error) {
	out := new(ForwardingRuleList)
	err := c.cc.Invoke(ctx, ForwardingRules_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) Patch(ctx context.Context, in *PatchForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ForwardingRules_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) SetLabels(ctx context.Context, in *SetLabelsForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ForwardingRules_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *forwardingRulesClient) SetTarget(ctx context.Context, in *SetTargetForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ForwardingRules_SetTarget_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ForwardingRulesServer is the server API for ForwardingRules service.
// All implementations should embed UnimplementedForwardingRulesServer
// for forward compatibility
type ForwardingRulesServer interface {
	// Retrieves an aggregated list of forwarding rules.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListForwardingRulesRequest) (*ForwardingRuleAggregatedList, error)
	// Deletes the specified ForwardingRule resource.
	Delete(context.Context, *DeleteForwardingRuleRequest) (*Operation, error)
	// Returns the specified ForwardingRule resource.
	Get(context.Context, *GetForwardingRuleRequest) (*ForwardingRule, error)
	// Creates a ForwardingRule resource in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertForwardingRuleRequest) (*Operation, error)
	// Retrieves a list of ForwardingRule resources available to the specified
	// project and region.
	List(context.Context, *ListForwardingRulesRequest) (*ForwardingRuleList, error)
	// Updates the specified forwarding rule with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules. Currently, you can only
	// patch the network_tier field.
	Patch(context.Context, *PatchForwardingRuleRequest) (*Operation, error)
	// Sets the labels on the specified resource. To learn more about labels,
	// read the
	// Labeling Resources documentation.
	SetLabels(context.Context, *SetLabelsForwardingRuleRequest) (*Operation, error)
	// Changes target URL for forwarding rule. The new target should be of the
	// same type as the old target.
	SetTarget(context.Context, *SetTargetForwardingRuleRequest) (*Operation, error)
}

// UnimplementedForwardingRulesServer should be embedded to have forward compatible implementations.
type UnimplementedForwardingRulesServer struct {
}

func (UnimplementedForwardingRulesServer) AggregatedList(context.Context, *AggregatedListForwardingRulesRequest) (*ForwardingRuleAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedForwardingRulesServer) Delete(context.Context, *DeleteForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedForwardingRulesServer) Get(context.Context, *GetForwardingRuleRequest) (*ForwardingRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedForwardingRulesServer) Insert(context.Context, *InsertForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedForwardingRulesServer) List(context.Context, *ListForwardingRulesRequest) (*ForwardingRuleList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedForwardingRulesServer) Patch(context.Context, *PatchForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedForwardingRulesServer) SetLabels(context.Context, *SetLabelsForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedForwardingRulesServer) SetTarget(context.Context, *SetTargetForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTarget not implemented")
}

// UnsafeForwardingRulesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ForwardingRulesServer will
// result in compilation errors.
type UnsafeForwardingRulesServer interface {
	mustEmbedUnimplementedForwardingRulesServer()
}

func RegisterForwardingRulesServer(s grpc.ServiceRegistrar, srv ForwardingRulesServer) {
	s.RegisterService(&ForwardingRules_ServiceDesc, srv)
}

func _ForwardingRules_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListForwardingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).AggregatedList(ctx, req.(*AggregatedListForwardingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).Delete(ctx, req.(*DeleteForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).Get(ctx, req.(*GetForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).Insert(ctx, req.(*InsertForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListForwardingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).List(ctx, req.(*ListForwardingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).Patch(ctx, req.(*PatchForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).SetLabels(ctx, req.(*SetLabelsForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ForwardingRules_SetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTargetForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ForwardingRulesServer).SetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ForwardingRules_SetTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ForwardingRulesServer).SetTarget(ctx, req.(*SetTargetForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ForwardingRules_ServiceDesc is the grpc.ServiceDesc for ForwardingRules service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ForwardingRules_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ForwardingRules",
	HandlerType: (*ForwardingRulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _ForwardingRules_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ForwardingRules_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ForwardingRules_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _ForwardingRules_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ForwardingRules_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _ForwardingRules_Patch_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _ForwardingRules_SetLabels_Handler,
		},
		{
			MethodName: "SetTarget",
			Handler:    _ForwardingRules_SetTarget_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	FutureReservations_AggregatedList_FullMethodName = "/google.cloud.compute.v1.FutureReservations/AggregatedList"
	FutureReservations_Cancel_FullMethodName         = "/google.cloud.compute.v1.FutureReservations/Cancel"
	FutureReservations_Delete_FullMethodName         = "/google.cloud.compute.v1.FutureReservations/Delete"
	FutureReservations_Get_FullMethodName            = "/google.cloud.compute.v1.FutureReservations/Get"
	FutureReservations_Insert_FullMethodName         = "/google.cloud.compute.v1.FutureReservations/Insert"
	FutureReservations_List_FullMethodName           = "/google.cloud.compute.v1.FutureReservations/List"
	FutureReservations_Update_FullMethodName         = "/google.cloud.compute.v1.FutureReservations/Update"
)

// FutureReservationsClient is the client API for FutureReservations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type FutureReservationsClient interface {
	// Retrieves an aggregated list of future reservations.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListFutureReservationsRequest, opts ...grpc.CallOption) (*FutureReservationsAggregatedListResponse, error)
	// Cancel the specified future reservation.
	Cancel(ctx context.Context, in *CancelFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified future reservation.
	Delete(ctx context.Context, in *DeleteFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves information about the specified future reservation.
	Get(ctx context.Context, in *GetFutureReservationRequest, opts ...grpc.CallOption) (*FutureReservation, error)
	// Creates a new Future Reservation.
	Insert(ctx context.Context, in *InsertFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// A list of all the future reservations that have been configured for the
	// specified project in specified zone.
	List(ctx context.Context, in *ListFutureReservationsRequest, opts ...grpc.CallOption) (*FutureReservationsListResponse, error)
	// Updates the specified future reservation.
	Update(ctx context.Context, in *UpdateFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error)
}

type futureReservationsClient struct {
	cc grpc.ClientConnInterface
}

func NewFutureReservationsClient(cc grpc.ClientConnInterface) FutureReservationsClient {
	return &futureReservationsClient{cc}
}

func (c *futureReservationsClient) AggregatedList(ctx context.Context, in *AggregatedListFutureReservationsRequest, opts ...grpc.CallOption) (*FutureReservationsAggregatedListResponse, error) {
	out := new(FutureReservationsAggregatedListResponse)
	err := c.cc.Invoke(ctx, FutureReservations_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *futureReservationsClient) Cancel(ctx context.Context, in *CancelFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FutureReservations_Cancel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *futureReservationsClient) Delete(ctx context.Context, in *DeleteFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FutureReservations_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *futureReservationsClient) Get(ctx context.Context, in *GetFutureReservationRequest, opts ...grpc.CallOption) (*FutureReservation, error) {
	out := new(FutureReservation)
	err := c.cc.Invoke(ctx, FutureReservations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *futureReservationsClient) Insert(ctx context.Context, in *InsertFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FutureReservations_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *futureReservationsClient) List(ctx context.Context, in *ListFutureReservationsRequest, opts ...grpc.CallOption) (*FutureReservationsListResponse, error) {
	out := new(FutureReservationsListResponse)
	err := c.cc.Invoke(ctx, FutureReservations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *futureReservationsClient) Update(ctx context.Context, in *UpdateFutureReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, FutureReservations_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// FutureReservationsServer is the server API for FutureReservations service.
// All implementations should embed UnimplementedFutureReservationsServer
// for forward compatibility
type FutureReservationsServer interface {
	// Retrieves an aggregated list of future reservations.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListFutureReservationsRequest) (*FutureReservationsAggregatedListResponse, error)
	// Cancel the specified future reservation.
	Cancel(context.Context, *CancelFutureReservationRequest) (*Operation, error)
	// Deletes the specified future reservation.
	Delete(context.Context, *DeleteFutureReservationRequest) (*Operation, error)
	// Retrieves information about the specified future reservation.
	Get(context.Context, *GetFutureReservationRequest) (*FutureReservation, error)
	// Creates a new Future Reservation.
	Insert(context.Context, *InsertFutureReservationRequest) (*Operation, error)
	// A list of all the future reservations that have been configured for the
	// specified project in specified zone.
	List(context.Context, *ListFutureReservationsRequest) (*FutureReservationsListResponse, error)
	// Updates the specified future reservation.
	Update(context.Context, *UpdateFutureReservationRequest) (*Operation, error)
}

// UnimplementedFutureReservationsServer should be embedded to have forward compatible implementations.
type UnimplementedFutureReservationsServer struct {
}

func (UnimplementedFutureReservationsServer) AggregatedList(context.Context, *AggregatedListFutureReservationsRequest) (*FutureReservationsAggregatedListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedFutureReservationsServer) Cancel(context.Context, *CancelFutureReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedFutureReservationsServer) Delete(context.Context, *DeleteFutureReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedFutureReservationsServer) Get(context.Context, *GetFutureReservationRequest) (*FutureReservation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedFutureReservationsServer) Insert(context.Context, *InsertFutureReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedFutureReservationsServer) List(context.Context, *ListFutureReservationsRequest) (*FutureReservationsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedFutureReservationsServer) Update(context.Context, *UpdateFutureReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeFutureReservationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to FutureReservationsServer will
// result in compilation errors.
type UnsafeFutureReservationsServer interface {
	mustEmbedUnimplementedFutureReservationsServer()
}

func RegisterFutureReservationsServer(s grpc.ServiceRegistrar, srv FutureReservationsServer) {
	s.RegisterService(&FutureReservations_ServiceDesc, srv)
}

func _FutureReservations_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListFutureReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).AggregatedList(ctx, req.(*AggregatedListFutureReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FutureReservations_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelFutureReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_Cancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).Cancel(ctx, req.(*CancelFutureReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FutureReservations_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteFutureReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).Delete(ctx, req.(*DeleteFutureReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FutureReservations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFutureReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).Get(ctx, req.(*GetFutureReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FutureReservations_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertFutureReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).Insert(ctx, req.(*InsertFutureReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FutureReservations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFutureReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).List(ctx, req.(*ListFutureReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _FutureReservations_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFutureReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(FutureReservationsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: FutureReservations_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(FutureReservationsServer).Update(ctx, req.(*UpdateFutureReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// FutureReservations_ServiceDesc is the grpc.ServiceDesc for FutureReservations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var FutureReservations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.FutureReservations",
	HandlerType: (*FutureReservationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _FutureReservations_AggregatedList_Handler,
		},
		{
			MethodName: "Cancel",
			Handler:    _FutureReservations_Cancel_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _FutureReservations_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _FutureReservations_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _FutureReservations_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _FutureReservations_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _FutureReservations_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	GlobalAddresses_Delete_FullMethodName             = "/google.cloud.compute.v1.GlobalAddresses/Delete"
	GlobalAddresses_Get_FullMethodName                = "/google.cloud.compute.v1.GlobalAddresses/Get"
	GlobalAddresses_Insert_FullMethodName             = "/google.cloud.compute.v1.GlobalAddresses/Insert"
	GlobalAddresses_List_FullMethodName               = "/google.cloud.compute.v1.GlobalAddresses/List"
	GlobalAddresses_Move_FullMethodName               = "/google.cloud.compute.v1.GlobalAddresses/Move"
	GlobalAddresses_SetLabels_FullMethodName          = "/google.cloud.compute.v1.GlobalAddresses/SetLabels"
	GlobalAddresses_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.GlobalAddresses/TestIamPermissions"
)

// GlobalAddressesClient is the client API for GlobalAddresses service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalAddressesClient interface {
	// Deletes the specified address resource.
	Delete(ctx context.Context, in *DeleteGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified address resource.
	Get(ctx context.Context, in *GetGlobalAddressRequest, opts ...grpc.CallOption) (*Address, error)
	// Creates an address resource in the specified project by using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of global addresses.
	List(ctx context.Context, in *ListGlobalAddressesRequest, opts ...grpc.CallOption) (*AddressList, error)
	// Moves the specified address resource from one project to another project.
	Move(ctx context.Context, in *MoveGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on a GlobalAddress. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsGlobalAddressRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type globalAddressesClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalAddressesClient(cc grpc.ClientConnInterface) GlobalAddressesClient {
	return &globalAddressesClient{cc}
}

func (c *globalAddressesClient) Delete(ctx context.Context, in *DeleteGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalAddresses_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalAddressesClient) Get(ctx context.Context, in *GetGlobalAddressRequest, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := c.cc.Invoke(ctx, GlobalAddresses_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalAddressesClient) Insert(ctx context.Context, in *InsertGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalAddresses_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalAddressesClient) List(ctx context.Context, in *ListGlobalAddressesRequest, opts ...grpc.CallOption) (*AddressList, error) {
	out := new(AddressList)
	err := c.cc.Invoke(ctx, GlobalAddresses_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalAddressesClient) Move(ctx context.Context, in *MoveGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalAddresses_Move_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalAddressesClient) SetLabels(ctx context.Context, in *SetLabelsGlobalAddressRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalAddresses_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalAddressesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsGlobalAddressRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, GlobalAddresses_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalAddressesServer is the server API for GlobalAddresses service.
// All implementations should embed UnimplementedGlobalAddressesServer
// for forward compatibility
type GlobalAddressesServer interface {
	// Deletes the specified address resource.
	Delete(context.Context, *DeleteGlobalAddressRequest) (*Operation, error)
	// Returns the specified address resource.
	Get(context.Context, *GetGlobalAddressRequest) (*Address, error)
	// Creates an address resource in the specified project by using the data
	// included in the request.
	Insert(context.Context, *InsertGlobalAddressRequest) (*Operation, error)
	// Retrieves a list of global addresses.
	List(context.Context, *ListGlobalAddressesRequest) (*AddressList, error)
	// Moves the specified address resource from one project to another project.
	Move(context.Context, *MoveGlobalAddressRequest) (*Operation, error)
	// Sets the labels on a GlobalAddress. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsGlobalAddressRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsGlobalAddressRequest) (*TestPermissionsResponse, error)
}

// UnimplementedGlobalAddressesServer should be embedded to have forward compatible implementations.
type UnimplementedGlobalAddressesServer struct {
}

func (UnimplementedGlobalAddressesServer) Delete(context.Context, *DeleteGlobalAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGlobalAddressesServer) Get(context.Context, *GetGlobalAddressRequest) (*Address, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGlobalAddressesServer) Insert(context.Context, *InsertGlobalAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedGlobalAddressesServer) List(context.Context, *ListGlobalAddressesRequest) (*AddressList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGlobalAddressesServer) Move(context.Context, *MoveGlobalAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedGlobalAddressesServer) SetLabels(context.Context, *SetLabelsGlobalAddressRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedGlobalAddressesServer) TestIamPermissions(context.Context, *TestIamPermissionsGlobalAddressRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeGlobalAddressesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalAddressesServer will
// result in compilation errors.
type UnsafeGlobalAddressesServer interface {
	mustEmbedUnimplementedGlobalAddressesServer()
}

func RegisterGlobalAddressesServer(s grpc.ServiceRegistrar, srv GlobalAddressesServer) {
	s.RegisterService(&GlobalAddresses_ServiceDesc, srv)
}

func _GlobalAddresses_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).Delete(ctx, req.(*DeleteGlobalAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalAddresses_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).Get(ctx, req.(*GetGlobalAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalAddresses_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertGlobalAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).Insert(ctx, req.(*InsertGlobalAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalAddresses_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalAddressesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).List(ctx, req.(*ListGlobalAddressesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalAddresses_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveGlobalAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_Move_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).Move(ctx, req.(*MoveGlobalAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalAddresses_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsGlobalAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).SetLabels(ctx, req.(*SetLabelsGlobalAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalAddresses_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsGlobalAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalAddressesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalAddresses_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalAddressesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsGlobalAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalAddresses_ServiceDesc is the grpc.ServiceDesc for GlobalAddresses service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalAddresses_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.GlobalAddresses",
	HandlerType: (*GlobalAddressesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _GlobalAddresses_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GlobalAddresses_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _GlobalAddresses_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GlobalAddresses_List_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _GlobalAddresses_Move_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _GlobalAddresses_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _GlobalAddresses_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	GlobalForwardingRules_Delete_FullMethodName    = "/google.cloud.compute.v1.GlobalForwardingRules/Delete"
	GlobalForwardingRules_Get_FullMethodName       = "/google.cloud.compute.v1.GlobalForwardingRules/Get"
	GlobalForwardingRules_Insert_FullMethodName    = "/google.cloud.compute.v1.GlobalForwardingRules/Insert"
	GlobalForwardingRules_List_FullMethodName      = "/google.cloud.compute.v1.GlobalForwardingRules/List"
	GlobalForwardingRules_Patch_FullMethodName     = "/google.cloud.compute.v1.GlobalForwardingRules/Patch"
	GlobalForwardingRules_SetLabels_FullMethodName = "/google.cloud.compute.v1.GlobalForwardingRules/SetLabels"
	GlobalForwardingRules_SetTarget_FullMethodName = "/google.cloud.compute.v1.GlobalForwardingRules/SetTarget"
)

// GlobalForwardingRulesClient is the client API for GlobalForwardingRules service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalForwardingRulesClient interface {
	// Deletes the specified GlobalForwardingRule resource.
	Delete(ctx context.Context, in *DeleteGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified GlobalForwardingRule resource. Gets a list of
	// available forwarding rules by making a list() request.
	Get(ctx context.Context, in *GetGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*ForwardingRule, error)
	// Creates a GlobalForwardingRule resource in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of GlobalForwardingRule resources available to the
	// specified project.
	List(ctx context.Context, in *ListGlobalForwardingRulesRequest, opts ...grpc.CallOption) (*ForwardingRuleList, error)
	// Updates the specified forwarding rule with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules. Currently, you can only
	// patch the network_tier field.
	Patch(ctx context.Context, in *PatchGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on the specified resource. To learn more about labels,
	// read the
	// Labeling resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes target URL for the GlobalForwardingRule resource. The new target
	// should be of the same type as the old target.
	SetTarget(ctx context.Context, in *SetTargetGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error)
}

type globalForwardingRulesClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalForwardingRulesClient(cc grpc.ClientConnInterface) GlobalForwardingRulesClient {
	return &globalForwardingRulesClient{cc}
}

func (c *globalForwardingRulesClient) Delete(ctx context.Context, in *DeleteGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalForwardingRulesClient) Get(ctx context.Context, in *GetGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*ForwardingRule, error) {
	out := new(ForwardingRule)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalForwardingRulesClient) Insert(ctx context.Context, in *InsertGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalForwardingRulesClient) List(ctx context.Context, in *ListGlobalForwardingRulesRequest, opts ...grpc.CallOption) (*ForwardingRuleList, error) {
	out := new(ForwardingRuleList)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalForwardingRulesClient) Patch(ctx context.Context, in *PatchGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalForwardingRulesClient) SetLabels(ctx context.Context, in *SetLabelsGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalForwardingRulesClient) SetTarget(ctx context.Context, in *SetTargetGlobalForwardingRuleRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalForwardingRules_SetTarget_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalForwardingRulesServer is the server API for GlobalForwardingRules service.
// All implementations should embed UnimplementedGlobalForwardingRulesServer
// for forward compatibility
type GlobalForwardingRulesServer interface {
	// Deletes the specified GlobalForwardingRule resource.
	Delete(context.Context, *DeleteGlobalForwardingRuleRequest) (*Operation, error)
	// Returns the specified GlobalForwardingRule resource. Gets a list of
	// available forwarding rules by making a list() request.
	Get(context.Context, *GetGlobalForwardingRuleRequest) (*ForwardingRule, error)
	// Creates a GlobalForwardingRule resource in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertGlobalForwardingRuleRequest) (*Operation, error)
	// Retrieves a list of GlobalForwardingRule resources available to the
	// specified project.
	List(context.Context, *ListGlobalForwardingRulesRequest) (*ForwardingRuleList, error)
	// Updates the specified forwarding rule with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules. Currently, you can only
	// patch the network_tier field.
	Patch(context.Context, *PatchGlobalForwardingRuleRequest) (*Operation, error)
	// Sets the labels on the specified resource. To learn more about labels,
	// read the
	// Labeling resources documentation.
	SetLabels(context.Context, *SetLabelsGlobalForwardingRuleRequest) (*Operation, error)
	// Changes target URL for the GlobalForwardingRule resource. The new target
	// should be of the same type as the old target.
	SetTarget(context.Context, *SetTargetGlobalForwardingRuleRequest) (*Operation, error)
}

// UnimplementedGlobalForwardingRulesServer should be embedded to have forward compatible implementations.
type UnimplementedGlobalForwardingRulesServer struct {
}

func (UnimplementedGlobalForwardingRulesServer) Delete(context.Context, *DeleteGlobalForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGlobalForwardingRulesServer) Get(context.Context, *GetGlobalForwardingRuleRequest) (*ForwardingRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGlobalForwardingRulesServer) Insert(context.Context, *InsertGlobalForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedGlobalForwardingRulesServer) List(context.Context, *ListGlobalForwardingRulesRequest) (*ForwardingRuleList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGlobalForwardingRulesServer) Patch(context.Context, *PatchGlobalForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedGlobalForwardingRulesServer) SetLabels(context.Context, *SetLabelsGlobalForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedGlobalForwardingRulesServer) SetTarget(context.Context, *SetTargetGlobalForwardingRuleRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTarget not implemented")
}

// UnsafeGlobalForwardingRulesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalForwardingRulesServer will
// result in compilation errors.
type UnsafeGlobalForwardingRulesServer interface {
	mustEmbedUnimplementedGlobalForwardingRulesServer()
}

func RegisterGlobalForwardingRulesServer(s grpc.ServiceRegistrar, srv GlobalForwardingRulesServer) {
	s.RegisterService(&GlobalForwardingRules_ServiceDesc, srv)
}

func _GlobalForwardingRules_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).Delete(ctx, req.(*DeleteGlobalForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalForwardingRules_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).Get(ctx, req.(*GetGlobalForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalForwardingRules_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertGlobalForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).Insert(ctx, req.(*InsertGlobalForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalForwardingRules_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalForwardingRulesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).List(ctx, req.(*ListGlobalForwardingRulesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalForwardingRules_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchGlobalForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).Patch(ctx, req.(*PatchGlobalForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalForwardingRules_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsGlobalForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).SetLabels(ctx, req.(*SetLabelsGlobalForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalForwardingRules_SetTarget_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTargetGlobalForwardingRuleRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalForwardingRulesServer).SetTarget(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalForwardingRules_SetTarget_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalForwardingRulesServer).SetTarget(ctx, req.(*SetTargetGlobalForwardingRuleRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalForwardingRules_ServiceDesc is the grpc.ServiceDesc for GlobalForwardingRules service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalForwardingRules_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.GlobalForwardingRules",
	HandlerType: (*GlobalForwardingRulesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _GlobalForwardingRules_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GlobalForwardingRules_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _GlobalForwardingRules_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GlobalForwardingRules_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _GlobalForwardingRules_Patch_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _GlobalForwardingRules_SetLabels_Handler,
		},
		{
			MethodName: "SetTarget",
			Handler:    _GlobalForwardingRules_SetTarget_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	GlobalNetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/AttachNetworkEndpoints"
	GlobalNetworkEndpointGroups_Delete_FullMethodName                 = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/Delete"
	GlobalNetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/DetachNetworkEndpoints"
	GlobalNetworkEndpointGroups_Get_FullMethodName                    = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/Get"
	GlobalNetworkEndpointGroups_Insert_FullMethodName                 = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/Insert"
	GlobalNetworkEndpointGroups_List_FullMethodName                   = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/List"
	GlobalNetworkEndpointGroups_ListNetworkEndpoints_FullMethodName   = "/google.cloud.compute.v1.GlobalNetworkEndpointGroups/ListNetworkEndpoints"
)

// GlobalNetworkEndpointGroupsClient is the client API for GlobalNetworkEndpointGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalNetworkEndpointGroupsClient interface {
	// Attach a network endpoint to the specified network endpoint group.
	AttachNetworkEndpoints(ctx context.Context, in *AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified network endpoint group.Note that the NEG cannot be
	// deleted if there are backend services referencing it.
	Delete(ctx context.Context, in *DeleteGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Detach the network endpoint from the specified network endpoint group.
	DetachNetworkEndpoints(ctx context.Context, in *DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified network endpoint group.
	Get(ctx context.Context, in *GetGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*NetworkEndpointGroup, error)
	// Creates a network endpoint group in the specified project using the
	// parameters that are included in the request.
	Insert(ctx context.Context, in *InsertGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of network endpoint groups that are located in the
	// specified project.
	List(ctx context.Context, in *ListGlobalNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupList, error)
	// Lists the network endpoints in the specified network endpoint group.
	ListNetworkEndpoints(ctx context.Context, in *ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupsListNetworkEndpoints, error)
}

type globalNetworkEndpointGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalNetworkEndpointGroupsClient(cc grpc.ClientConnInterface) GlobalNetworkEndpointGroupsClient {
	return &globalNetworkEndpointGroupsClient{cc}
}

func (c *globalNetworkEndpointGroupsClient) AttachNetworkEndpoints(ctx context.Context, in *AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalNetworkEndpointGroupsClient) Delete(ctx context.Context, in *DeleteGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalNetworkEndpointGroupsClient) DetachNetworkEndpoints(ctx context.Context, in *DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalNetworkEndpointGroupsClient) Get(ctx context.Context, in *GetGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*NetworkEndpointGroup, error) {
	out := new(NetworkEndpointGroup)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalNetworkEndpointGroupsClient) Insert(ctx context.Context, in *InsertGlobalNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalNetworkEndpointGroupsClient) List(ctx context.Context, in *ListGlobalNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupList, error) {
	out := new(NetworkEndpointGroupList)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalNetworkEndpointGroupsClient) ListNetworkEndpoints(ctx context.Context, in *ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupsListNetworkEndpoints, error) {
	out := new(NetworkEndpointGroupsListNetworkEndpoints)
	err := c.cc.Invoke(ctx, GlobalNetworkEndpointGroups_ListNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalNetworkEndpointGroupsServer is the server API for GlobalNetworkEndpointGroups service.
// All implementations should embed UnimplementedGlobalNetworkEndpointGroupsServer
// for forward compatibility
type GlobalNetworkEndpointGroupsServer interface {
	// Attach a network endpoint to the specified network endpoint group.
	AttachNetworkEndpoints(context.Context, *AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest) (*Operation, error)
	// Deletes the specified network endpoint group.Note that the NEG cannot be
	// deleted if there are backend services referencing it.
	Delete(context.Context, *DeleteGlobalNetworkEndpointGroupRequest) (*Operation, error)
	// Detach the network endpoint from the specified network endpoint group.
	DetachNetworkEndpoints(context.Context, *DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest) (*Operation, error)
	// Returns the specified network endpoint group.
	Get(context.Context, *GetGlobalNetworkEndpointGroupRequest) (*NetworkEndpointGroup, error)
	// Creates a network endpoint group in the specified project using the
	// parameters that are included in the request.
	Insert(context.Context, *InsertGlobalNetworkEndpointGroupRequest) (*Operation, error)
	// Retrieves the list of network endpoint groups that are located in the
	// specified project.
	List(context.Context, *ListGlobalNetworkEndpointGroupsRequest) (*NetworkEndpointGroupList, error)
	// Lists the network endpoints in the specified network endpoint group.
	ListNetworkEndpoints(context.Context, *ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest) (*NetworkEndpointGroupsListNetworkEndpoints, error)
}

// UnimplementedGlobalNetworkEndpointGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedGlobalNetworkEndpointGroupsServer struct {
}

func (UnimplementedGlobalNetworkEndpointGroupsServer) AttachNetworkEndpoints(context.Context, *AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachNetworkEndpoints not implemented")
}
func (UnimplementedGlobalNetworkEndpointGroupsServer) Delete(context.Context, *DeleteGlobalNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGlobalNetworkEndpointGroupsServer) DetachNetworkEndpoints(context.Context, *DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachNetworkEndpoints not implemented")
}
func (UnimplementedGlobalNetworkEndpointGroupsServer) Get(context.Context, *GetGlobalNetworkEndpointGroupRequest) (*NetworkEndpointGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGlobalNetworkEndpointGroupsServer) Insert(context.Context, *InsertGlobalNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedGlobalNetworkEndpointGroupsServer) List(context.Context, *ListGlobalNetworkEndpointGroupsRequest) (*NetworkEndpointGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGlobalNetworkEndpointGroupsServer) ListNetworkEndpoints(context.Context, *ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest) (*NetworkEndpointGroupsListNetworkEndpoints, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworkEndpoints not implemented")
}

// UnsafeGlobalNetworkEndpointGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalNetworkEndpointGroupsServer will
// result in compilation errors.
type UnsafeGlobalNetworkEndpointGroupsServer interface {
	mustEmbedUnimplementedGlobalNetworkEndpointGroupsServer()
}

func RegisterGlobalNetworkEndpointGroupsServer(s grpc.ServiceRegistrar, srv GlobalNetworkEndpointGroupsServer) {
	s.RegisterService(&GlobalNetworkEndpointGroups_ServiceDesc, srv)
}

func _GlobalNetworkEndpointGroups_AttachNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).AttachNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).AttachNetworkEndpoints(ctx, req.(*AttachNetworkEndpointsGlobalNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalNetworkEndpointGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).Delete(ctx, req.(*DeleteGlobalNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalNetworkEndpointGroups_DetachNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).DetachNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).DetachNetworkEndpoints(ctx, req.(*DetachNetworkEndpointsGlobalNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalNetworkEndpointGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).Get(ctx, req.(*GetGlobalNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalNetworkEndpointGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertGlobalNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).Insert(ctx, req.(*InsertGlobalNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalNetworkEndpointGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).List(ctx, req.(*ListGlobalNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalNetworkEndpointGroups_ListNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalNetworkEndpointGroupsServer).ListNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalNetworkEndpointGroups_ListNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalNetworkEndpointGroupsServer).ListNetworkEndpoints(ctx, req.(*ListNetworkEndpointsGlobalNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalNetworkEndpointGroups_ServiceDesc is the grpc.ServiceDesc for GlobalNetworkEndpointGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalNetworkEndpointGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.GlobalNetworkEndpointGroups",
	HandlerType: (*GlobalNetworkEndpointGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AttachNetworkEndpoints",
			Handler:    _GlobalNetworkEndpointGroups_AttachNetworkEndpoints_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GlobalNetworkEndpointGroups_Delete_Handler,
		},
		{
			MethodName: "DetachNetworkEndpoints",
			Handler:    _GlobalNetworkEndpointGroups_DetachNetworkEndpoints_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GlobalNetworkEndpointGroups_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _GlobalNetworkEndpointGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GlobalNetworkEndpointGroups_List_Handler,
		},
		{
			MethodName: "ListNetworkEndpoints",
			Handler:    _GlobalNetworkEndpointGroups_ListNetworkEndpoints_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	GlobalOperations_AggregatedList_FullMethodName = "/google.cloud.compute.v1.GlobalOperations/AggregatedList"
	GlobalOperations_Delete_FullMethodName         = "/google.cloud.compute.v1.GlobalOperations/Delete"
	GlobalOperations_Get_FullMethodName            = "/google.cloud.compute.v1.GlobalOperations/Get"
	GlobalOperations_List_FullMethodName           = "/google.cloud.compute.v1.GlobalOperations/List"
	GlobalOperations_Wait_FullMethodName           = "/google.cloud.compute.v1.GlobalOperations/Wait"
)

// GlobalOperationsClient is the client API for GlobalOperations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalOperationsClient interface {
	// Retrieves an aggregated list of all operations.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListGlobalOperationsRequest, opts ...grpc.CallOption) (*OperationAggregatedList, error)
	// Deletes the specified Operations resource.
	Delete(ctx context.Context, in *DeleteGlobalOperationRequest, opts ...grpc.CallOption) (*DeleteGlobalOperationResponse, error)
	// Retrieves the specified Operations resource.
	Get(ctx context.Context, in *GetGlobalOperationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of Operation resources contained within the specified
	// project.
	List(ctx context.Context, in *ListGlobalOperationsRequest, opts ...grpc.CallOption) (*OperationList, error)
	// Waits for the specified Operation resource to return as `DONE`
	// or for the request to approach the 2 minute deadline, and retrieves the
	// specified Operation resource. This method differs from the
	// `GET` method in that it waits for no more than the default
	// deadline (2 minutes) and then returns the current state of the operation,
	// which might be `DONE` or still in progress.
	//
	// This method is called on a best-effort basis. Specifically:
	//
	//   - In uncommon cases, when the server is overloaded, the request might
	//     return before the default deadline is reached, or might return after zero
	//     seconds.
	//   - If the default deadline is reached, there is no guarantee that the
	//     operation is actually done when the method returns. Be prepared to retry
	//     if the operation is not `DONE`.
	Wait(ctx context.Context, in *WaitGlobalOperationRequest, opts ...grpc.CallOption) (*Operation, error)
}

type globalOperationsClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalOperationsClient(cc grpc.ClientConnInterface) GlobalOperationsClient {
	return &globalOperationsClient{cc}
}

func (c *globalOperationsClient) AggregatedList(ctx context.Context, in *AggregatedListGlobalOperationsRequest, opts ...grpc.CallOption) (*OperationAggregatedList, error) {
	out := new(OperationAggregatedList)
	err := c.cc.Invoke(ctx, GlobalOperations_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalOperationsClient) Delete(ctx context.Context, in *DeleteGlobalOperationRequest, opts ...grpc.CallOption) (*DeleteGlobalOperationResponse, error) {
	out := new(DeleteGlobalOperationResponse)
	err := c.cc.Invoke(ctx, GlobalOperations_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalOperationsClient) Get(ctx context.Context, in *GetGlobalOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalOperations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalOperationsClient) List(ctx context.Context, in *ListGlobalOperationsRequest, opts ...grpc.CallOption) (*OperationList, error) {
	out := new(OperationList)
	err := c.cc.Invoke(ctx, GlobalOperations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalOperationsClient) Wait(ctx context.Context, in *WaitGlobalOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalOperations_Wait_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalOperationsServer is the server API for GlobalOperations service.
// All implementations should embed UnimplementedGlobalOperationsServer
// for forward compatibility
type GlobalOperationsServer interface {
	// Retrieves an aggregated list of all operations.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListGlobalOperationsRequest) (*OperationAggregatedList, error)
	// Deletes the specified Operations resource.
	Delete(context.Context, *DeleteGlobalOperationRequest) (*DeleteGlobalOperationResponse, error)
	// Retrieves the specified Operations resource.
	Get(context.Context, *GetGlobalOperationRequest) (*Operation, error)
	// Retrieves a list of Operation resources contained within the specified
	// project.
	List(context.Context, *ListGlobalOperationsRequest) (*OperationList, error)
	// Waits for the specified Operation resource to return as `DONE`
	// or for the request to approach the 2 minute deadline, and retrieves the
	// specified Operation resource. This method differs from the
	// `GET` method in that it waits for no more than the default
	// deadline (2 minutes) and then returns the current state of the operation,
	// which might be `DONE` or still in progress.
	//
	// This method is called on a best-effort basis. Specifically:
	//
	//   - In uncommon cases, when the server is overloaded, the request might
	//     return before the default deadline is reached, or might return after zero
	//     seconds.
	//   - If the default deadline is reached, there is no guarantee that the
	//     operation is actually done when the method returns. Be prepared to retry
	//     if the operation is not `DONE`.
	Wait(context.Context, *WaitGlobalOperationRequest) (*Operation, error)
}

// UnimplementedGlobalOperationsServer should be embedded to have forward compatible implementations.
type UnimplementedGlobalOperationsServer struct {
}

func (UnimplementedGlobalOperationsServer) AggregatedList(context.Context, *AggregatedListGlobalOperationsRequest) (*OperationAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedGlobalOperationsServer) Delete(context.Context, *DeleteGlobalOperationRequest) (*DeleteGlobalOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGlobalOperationsServer) Get(context.Context, *GetGlobalOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGlobalOperationsServer) List(context.Context, *ListGlobalOperationsRequest) (*OperationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGlobalOperationsServer) Wait(context.Context, *WaitGlobalOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}

// UnsafeGlobalOperationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalOperationsServer will
// result in compilation errors.
type UnsafeGlobalOperationsServer interface {
	mustEmbedUnimplementedGlobalOperationsServer()
}

func RegisterGlobalOperationsServer(s grpc.ServiceRegistrar, srv GlobalOperationsServer) {
	s.RegisterService(&GlobalOperations_ServiceDesc, srv)
}

func _GlobalOperations_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListGlobalOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOperationsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOperations_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOperationsServer).AggregatedList(ctx, req.(*AggregatedListGlobalOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalOperations_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOperationsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOperations_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOperationsServer).Delete(ctx, req.(*DeleteGlobalOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalOperations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOperationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOperations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOperationsServer).Get(ctx, req.(*GetGlobalOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalOperations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOperationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOperations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOperationsServer).List(ctx, req.(*ListGlobalOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalOperations_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitGlobalOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOperationsServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOperations_Wait_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOperationsServer).Wait(ctx, req.(*WaitGlobalOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalOperations_ServiceDesc is the grpc.ServiceDesc for GlobalOperations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalOperations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.GlobalOperations",
	HandlerType: (*GlobalOperationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _GlobalOperations_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _GlobalOperations_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GlobalOperations_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GlobalOperations_List_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _GlobalOperations_Wait_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	GlobalOrganizationOperations_Delete_FullMethodName = "/google.cloud.compute.v1.GlobalOrganizationOperations/Delete"
	GlobalOrganizationOperations_Get_FullMethodName    = "/google.cloud.compute.v1.GlobalOrganizationOperations/Get"
	GlobalOrganizationOperations_List_FullMethodName   = "/google.cloud.compute.v1.GlobalOrganizationOperations/List"
)

// GlobalOrganizationOperationsClient is the client API for GlobalOrganizationOperations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalOrganizationOperationsClient interface {
	// Deletes the specified Operations resource.
	Delete(ctx context.Context, in *DeleteGlobalOrganizationOperationRequest, opts ...grpc.CallOption) (*DeleteGlobalOrganizationOperationResponse, error)
	// Retrieves the specified Operations resource. Gets a list of operations
	// by making a `list()` request.
	Get(ctx context.Context, in *GetGlobalOrganizationOperationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of Operation resources contained within the specified
	// organization.
	List(ctx context.Context, in *ListGlobalOrganizationOperationsRequest, opts ...grpc.CallOption) (*OperationList, error)
}

type globalOrganizationOperationsClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalOrganizationOperationsClient(cc grpc.ClientConnInterface) GlobalOrganizationOperationsClient {
	return &globalOrganizationOperationsClient{cc}
}

func (c *globalOrganizationOperationsClient) Delete(ctx context.Context, in *DeleteGlobalOrganizationOperationRequest, opts ...grpc.CallOption) (*DeleteGlobalOrganizationOperationResponse, error) {
	out := new(DeleteGlobalOrganizationOperationResponse)
	err := c.cc.Invoke(ctx, GlobalOrganizationOperations_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalOrganizationOperationsClient) Get(ctx context.Context, in *GetGlobalOrganizationOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalOrganizationOperations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalOrganizationOperationsClient) List(ctx context.Context, in *ListGlobalOrganizationOperationsRequest, opts ...grpc.CallOption) (*OperationList, error) {
	out := new(OperationList)
	err := c.cc.Invoke(ctx, GlobalOrganizationOperations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalOrganizationOperationsServer is the server API for GlobalOrganizationOperations service.
// All implementations should embed UnimplementedGlobalOrganizationOperationsServer
// for forward compatibility
type GlobalOrganizationOperationsServer interface {
	// Deletes the specified Operations resource.
	Delete(context.Context, *DeleteGlobalOrganizationOperationRequest) (*DeleteGlobalOrganizationOperationResponse, error)
	// Retrieves the specified Operations resource. Gets a list of operations
	// by making a `list()` request.
	Get(context.Context, *GetGlobalOrganizationOperationRequest) (*Operation, error)
	// Retrieves a list of Operation resources contained within the specified
	// organization.
	List(context.Context, *ListGlobalOrganizationOperationsRequest) (*OperationList, error)
}

// UnimplementedGlobalOrganizationOperationsServer should be embedded to have forward compatible implementations.
type UnimplementedGlobalOrganizationOperationsServer struct {
}

func (UnimplementedGlobalOrganizationOperationsServer) Delete(context.Context, *DeleteGlobalOrganizationOperationRequest) (*DeleteGlobalOrganizationOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGlobalOrganizationOperationsServer) Get(context.Context, *GetGlobalOrganizationOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGlobalOrganizationOperationsServer) List(context.Context, *ListGlobalOrganizationOperationsRequest) (*OperationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeGlobalOrganizationOperationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalOrganizationOperationsServer will
// result in compilation errors.
type UnsafeGlobalOrganizationOperationsServer interface {
	mustEmbedUnimplementedGlobalOrganizationOperationsServer()
}

func RegisterGlobalOrganizationOperationsServer(s grpc.ServiceRegistrar, srv GlobalOrganizationOperationsServer) {
	s.RegisterService(&GlobalOrganizationOperations_ServiceDesc, srv)
}

func _GlobalOrganizationOperations_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalOrganizationOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOrganizationOperationsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOrganizationOperations_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOrganizationOperationsServer).Delete(ctx, req.(*DeleteGlobalOrganizationOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalOrganizationOperations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalOrganizationOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOrganizationOperationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOrganizationOperations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOrganizationOperationsServer).Get(ctx, req.(*GetGlobalOrganizationOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalOrganizationOperations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalOrganizationOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalOrganizationOperationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalOrganizationOperations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalOrganizationOperationsServer).List(ctx, req.(*ListGlobalOrganizationOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalOrganizationOperations_ServiceDesc is the grpc.ServiceDesc for GlobalOrganizationOperations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalOrganizationOperations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.GlobalOrganizationOperations",
	HandlerType: (*GlobalOrganizationOperationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _GlobalOrganizationOperations_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GlobalOrganizationOperations_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GlobalOrganizationOperations_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	GlobalPublicDelegatedPrefixes_Delete_FullMethodName = "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Delete"
	GlobalPublicDelegatedPrefixes_Get_FullMethodName    = "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Get"
	GlobalPublicDelegatedPrefixes_Insert_FullMethodName = "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Insert"
	GlobalPublicDelegatedPrefixes_List_FullMethodName   = "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/List"
	GlobalPublicDelegatedPrefixes_Patch_FullMethodName  = "/google.cloud.compute.v1.GlobalPublicDelegatedPrefixes/Patch"
)

// GlobalPublicDelegatedPrefixesClient is the client API for GlobalPublicDelegatedPrefixes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type GlobalPublicDelegatedPrefixesClient interface {
	// Deletes the specified global PublicDelegatedPrefix.
	Delete(ctx context.Context, in *DeleteGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified global PublicDelegatedPrefix resource.
	Get(ctx context.Context, in *GetGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefix, error)
	// Creates a global PublicDelegatedPrefix in the specified project using the
	// parameters that are included in the request.
	Insert(ctx context.Context, in *InsertGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the global PublicDelegatedPrefixes for a project.
	List(ctx context.Context, in *ListGlobalPublicDelegatedPrefixesRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefixList, error)
	// Patches the specified global PublicDelegatedPrefix resource with the data
	// included in the request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
}

type globalPublicDelegatedPrefixesClient struct {
	cc grpc.ClientConnInterface
}

func NewGlobalPublicDelegatedPrefixesClient(cc grpc.ClientConnInterface) GlobalPublicDelegatedPrefixesClient {
	return &globalPublicDelegatedPrefixesClient{cc}
}

func (c *globalPublicDelegatedPrefixesClient) Delete(ctx context.Context, in *DeleteGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalPublicDelegatedPrefixes_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalPublicDelegatedPrefixesClient) Get(ctx context.Context, in *GetGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefix, error) {
	out := new(PublicDelegatedPrefix)
	err := c.cc.Invoke(ctx, GlobalPublicDelegatedPrefixes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalPublicDelegatedPrefixesClient) Insert(ctx context.Context, in *InsertGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalPublicDelegatedPrefixes_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalPublicDelegatedPrefixesClient) List(ctx context.Context, in *ListGlobalPublicDelegatedPrefixesRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefixList, error) {
	out := new(PublicDelegatedPrefixList)
	err := c.cc.Invoke(ctx, GlobalPublicDelegatedPrefixes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *globalPublicDelegatedPrefixesClient) Patch(ctx context.Context, in *PatchGlobalPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, GlobalPublicDelegatedPrefixes_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// GlobalPublicDelegatedPrefixesServer is the server API for GlobalPublicDelegatedPrefixes service.
// All implementations should embed UnimplementedGlobalPublicDelegatedPrefixesServer
// for forward compatibility
type GlobalPublicDelegatedPrefixesServer interface {
	// Deletes the specified global PublicDelegatedPrefix.
	Delete(context.Context, *DeleteGlobalPublicDelegatedPrefixeRequest) (*Operation, error)
	// Returns the specified global PublicDelegatedPrefix resource.
	Get(context.Context, *GetGlobalPublicDelegatedPrefixeRequest) (*PublicDelegatedPrefix, error)
	// Creates a global PublicDelegatedPrefix in the specified project using the
	// parameters that are included in the request.
	Insert(context.Context, *InsertGlobalPublicDelegatedPrefixeRequest) (*Operation, error)
	// Lists the global PublicDelegatedPrefixes for a project.
	List(context.Context, *ListGlobalPublicDelegatedPrefixesRequest) (*PublicDelegatedPrefixList, error)
	// Patches the specified global PublicDelegatedPrefix resource with the data
	// included in the request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchGlobalPublicDelegatedPrefixeRequest) (*Operation, error)
}

// UnimplementedGlobalPublicDelegatedPrefixesServer should be embedded to have forward compatible implementations.
type UnimplementedGlobalPublicDelegatedPrefixesServer struct {
}

func (UnimplementedGlobalPublicDelegatedPrefixesServer) Delete(context.Context, *DeleteGlobalPublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedGlobalPublicDelegatedPrefixesServer) Get(context.Context, *GetGlobalPublicDelegatedPrefixeRequest) (*PublicDelegatedPrefix, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedGlobalPublicDelegatedPrefixesServer) Insert(context.Context, *InsertGlobalPublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedGlobalPublicDelegatedPrefixesServer) List(context.Context, *ListGlobalPublicDelegatedPrefixesRequest) (*PublicDelegatedPrefixList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedGlobalPublicDelegatedPrefixesServer) Patch(context.Context, *PatchGlobalPublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeGlobalPublicDelegatedPrefixesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to GlobalPublicDelegatedPrefixesServer will
// result in compilation errors.
type UnsafeGlobalPublicDelegatedPrefixesServer interface {
	mustEmbedUnimplementedGlobalPublicDelegatedPrefixesServer()
}

func RegisterGlobalPublicDelegatedPrefixesServer(s grpc.ServiceRegistrar, srv GlobalPublicDelegatedPrefixesServer) {
	s.RegisterService(&GlobalPublicDelegatedPrefixes_ServiceDesc, srv)
}

func _GlobalPublicDelegatedPrefixes_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteGlobalPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalPublicDelegatedPrefixesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalPublicDelegatedPrefixes_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalPublicDelegatedPrefixesServer).Delete(ctx, req.(*DeleteGlobalPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalPublicDelegatedPrefixes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGlobalPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalPublicDelegatedPrefixesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalPublicDelegatedPrefixes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalPublicDelegatedPrefixesServer).Get(ctx, req.(*GetGlobalPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalPublicDelegatedPrefixes_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertGlobalPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalPublicDelegatedPrefixesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalPublicDelegatedPrefixes_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalPublicDelegatedPrefixesServer).Insert(ctx, req.(*InsertGlobalPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalPublicDelegatedPrefixes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListGlobalPublicDelegatedPrefixesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalPublicDelegatedPrefixesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalPublicDelegatedPrefixes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalPublicDelegatedPrefixesServer).List(ctx, req.(*ListGlobalPublicDelegatedPrefixesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _GlobalPublicDelegatedPrefixes_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchGlobalPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GlobalPublicDelegatedPrefixesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: GlobalPublicDelegatedPrefixes_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GlobalPublicDelegatedPrefixesServer).Patch(ctx, req.(*PatchGlobalPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// GlobalPublicDelegatedPrefixes_ServiceDesc is the grpc.ServiceDesc for GlobalPublicDelegatedPrefixes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var GlobalPublicDelegatedPrefixes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.GlobalPublicDelegatedPrefixes",
	HandlerType: (*GlobalPublicDelegatedPrefixesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _GlobalPublicDelegatedPrefixes_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _GlobalPublicDelegatedPrefixes_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _GlobalPublicDelegatedPrefixes_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _GlobalPublicDelegatedPrefixes_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _GlobalPublicDelegatedPrefixes_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	HealthChecks_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.HealthChecks/AggregatedList"
	HealthChecks_Delete_FullMethodName             = "/google.cloud.compute.v1.HealthChecks/Delete"
	HealthChecks_Get_FullMethodName                = "/google.cloud.compute.v1.HealthChecks/Get"
	HealthChecks_Insert_FullMethodName             = "/google.cloud.compute.v1.HealthChecks/Insert"
	HealthChecks_List_FullMethodName               = "/google.cloud.compute.v1.HealthChecks/List"
	HealthChecks_Patch_FullMethodName              = "/google.cloud.compute.v1.HealthChecks/Patch"
	HealthChecks_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.HealthChecks/TestIamPermissions"
	HealthChecks_Update_FullMethodName             = "/google.cloud.compute.v1.HealthChecks/Update"
)

// HealthChecksClient is the client API for HealthChecks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type HealthChecksClient interface {
	// Retrieves the list of all HealthCheck resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListHealthChecksRequest, opts ...grpc.CallOption) (*HealthChecksAggregatedList, error)
	// Deletes the specified HealthCheck resource.
	Delete(ctx context.Context, in *DeleteHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified HealthCheck resource.
	Get(ctx context.Context, in *GetHealthCheckRequest, opts ...grpc.CallOption) (*HealthCheck, error)
	// Creates a HealthCheck resource in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of HealthCheck resources available to the specified
	// project.
	List(ctx context.Context, in *ListHealthChecksRequest, opts ...grpc.CallOption) (*HealthCheckList, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsHealthCheckRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request.
	Update(ctx context.Context, in *UpdateHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
}

type healthChecksClient struct {
	cc grpc.ClientConnInterface
}

func NewHealthChecksClient(cc grpc.ClientConnInterface) HealthChecksClient {
	return &healthChecksClient{cc}
}

func (c *healthChecksClient) AggregatedList(ctx context.Context, in *AggregatedListHealthChecksRequest, opts ...grpc.CallOption) (*HealthChecksAggregatedList, error) {
	out := new(HealthChecksAggregatedList)
	err := c.cc.Invoke(ctx, HealthChecks_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) Delete(ctx context.Context, in *DeleteHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, HealthChecks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) Get(ctx context.Context, in *GetHealthCheckRequest, opts ...grpc.CallOption) (*HealthCheck, error) {
	out := new(HealthCheck)
	err := c.cc.Invoke(ctx, HealthChecks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) Insert(ctx context.Context, in *InsertHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, HealthChecks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) List(ctx context.Context, in *ListHealthChecksRequest, opts ...grpc.CallOption) (*HealthCheckList, error) {
	out := new(HealthCheckList)
	err := c.cc.Invoke(ctx, HealthChecks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) Patch(ctx context.Context, in *PatchHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, HealthChecks_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsHealthCheckRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, HealthChecks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *healthChecksClient) Update(ctx context.Context, in *UpdateHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, HealthChecks_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// HealthChecksServer is the server API for HealthChecks service.
// All implementations should embed UnimplementedHealthChecksServer
// for forward compatibility
type HealthChecksServer interface {
	// Retrieves the list of all HealthCheck resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListHealthChecksRequest) (*HealthChecksAggregatedList, error)
	// Deletes the specified HealthCheck resource.
	Delete(context.Context, *DeleteHealthCheckRequest) (*Operation, error)
	// Returns the specified HealthCheck resource.
	Get(context.Context, *GetHealthCheckRequest) (*HealthCheck, error)
	// Creates a HealthCheck resource in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertHealthCheckRequest) (*Operation, error)
	// Retrieves the list of HealthCheck resources available to the specified
	// project.
	List(context.Context, *ListHealthChecksRequest) (*HealthCheckList, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchHealthCheckRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsHealthCheckRequest) (*TestPermissionsResponse, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request.
	Update(context.Context, *UpdateHealthCheckRequest) (*Operation, error)
}

// UnimplementedHealthChecksServer should be embedded to have forward compatible implementations.
type UnimplementedHealthChecksServer struct {
}

func (UnimplementedHealthChecksServer) AggregatedList(context.Context, *AggregatedListHealthChecksRequest) (*HealthChecksAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedHealthChecksServer) Delete(context.Context, *DeleteHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedHealthChecksServer) Get(context.Context, *GetHealthCheckRequest) (*HealthCheck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedHealthChecksServer) Insert(context.Context, *InsertHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedHealthChecksServer) List(context.Context, *ListHealthChecksRequest) (*HealthCheckList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedHealthChecksServer) Patch(context.Context, *PatchHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedHealthChecksServer) TestIamPermissions(context.Context, *TestIamPermissionsHealthCheckRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedHealthChecksServer) Update(context.Context, *UpdateHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeHealthChecksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to HealthChecksServer will
// result in compilation errors.
type UnsafeHealthChecksServer interface {
	mustEmbedUnimplementedHealthChecksServer()
}

func RegisterHealthChecksServer(s grpc.ServiceRegistrar, srv HealthChecksServer) {
	s.RegisterService(&HealthChecks_ServiceDesc, srv)
}

func _HealthChecks_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListHealthChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).AggregatedList(ctx, req.(*AggregatedListHealthChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).Delete(ctx, req.(*DeleteHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).Get(ctx, req.(*GetHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).Insert(ctx, req.(*InsertHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListHealthChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).List(ctx, req.(*ListHealthChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).Patch(ctx, req.(*PatchHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _HealthChecks_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(HealthChecksServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: HealthChecks_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(HealthChecksServer).Update(ctx, req.(*UpdateHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// HealthChecks_ServiceDesc is the grpc.ServiceDesc for HealthChecks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var HealthChecks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.HealthChecks",
	HandlerType: (*HealthChecksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _HealthChecks_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _HealthChecks_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _HealthChecks_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _HealthChecks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _HealthChecks_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _HealthChecks_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _HealthChecks_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _HealthChecks_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ImageFamilyViews_Get_FullMethodName = "/google.cloud.compute.v1.ImageFamilyViews/Get"
)

// ImageFamilyViewsClient is the client API for ImageFamilyViews service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImageFamilyViewsClient interface {
	// Returns the latest image that is part of an image family, is not
	// deprecated and is rolled out in the specified zone.
	Get(ctx context.Context, in *GetImageFamilyViewRequest, opts ...grpc.CallOption) (*ImageFamilyView, error)
}

type imageFamilyViewsClient struct {
	cc grpc.ClientConnInterface
}

func NewImageFamilyViewsClient(cc grpc.ClientConnInterface) ImageFamilyViewsClient {
	return &imageFamilyViewsClient{cc}
}

func (c *imageFamilyViewsClient) Get(ctx context.Context, in *GetImageFamilyViewRequest, opts ...grpc.CallOption) (*ImageFamilyView, error) {
	out := new(ImageFamilyView)
	err := c.cc.Invoke(ctx, ImageFamilyViews_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImageFamilyViewsServer is the server API for ImageFamilyViews service.
// All implementations should embed UnimplementedImageFamilyViewsServer
// for forward compatibility
type ImageFamilyViewsServer interface {
	// Returns the latest image that is part of an image family, is not
	// deprecated and is rolled out in the specified zone.
	Get(context.Context, *GetImageFamilyViewRequest) (*ImageFamilyView, error)
}

// UnimplementedImageFamilyViewsServer should be embedded to have forward compatible implementations.
type UnimplementedImageFamilyViewsServer struct {
}

func (UnimplementedImageFamilyViewsServer) Get(context.Context, *GetImageFamilyViewRequest) (*ImageFamilyView, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}

// UnsafeImageFamilyViewsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImageFamilyViewsServer will
// result in compilation errors.
type UnsafeImageFamilyViewsServer interface {
	mustEmbedUnimplementedImageFamilyViewsServer()
}

func RegisterImageFamilyViewsServer(s grpc.ServiceRegistrar, srv ImageFamilyViewsServer) {
	s.RegisterService(&ImageFamilyViews_ServiceDesc, srv)
}

func _ImageFamilyViews_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageFamilyViewRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImageFamilyViewsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ImageFamilyViews_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImageFamilyViewsServer).Get(ctx, req.(*GetImageFamilyViewRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ImageFamilyViews_ServiceDesc is the grpc.ServiceDesc for ImageFamilyViews service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ImageFamilyViews_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ImageFamilyViews",
	HandlerType: (*ImageFamilyViewsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ImageFamilyViews_Get_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Images_Delete_FullMethodName             = "/google.cloud.compute.v1.Images/Delete"
	Images_Deprecate_FullMethodName          = "/google.cloud.compute.v1.Images/Deprecate"
	Images_Get_FullMethodName                = "/google.cloud.compute.v1.Images/Get"
	Images_GetFromFamily_FullMethodName      = "/google.cloud.compute.v1.Images/GetFromFamily"
	Images_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Images/GetIamPolicy"
	Images_Insert_FullMethodName             = "/google.cloud.compute.v1.Images/Insert"
	Images_List_FullMethodName               = "/google.cloud.compute.v1.Images/List"
	Images_Patch_FullMethodName              = "/google.cloud.compute.v1.Images/Patch"
	Images_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Images/SetIamPolicy"
	Images_SetLabels_FullMethodName          = "/google.cloud.compute.v1.Images/SetLabels"
	Images_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Images/TestIamPermissions"
)

// ImagesClient is the client API for Images service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ImagesClient interface {
	// Deletes the specified image.
	Delete(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the deprecation status of an image.
	//
	// If an empty request body is given, clears the deprecation status instead.
	Deprecate(ctx context.Context, in *DeprecateImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified image.
	Get(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*Image, error)
	// Returns the latest image that is part of an image family and is not
	// deprecated. For more information on image families, seePublic
	// image families documentation.
	GetFromFamily(ctx context.Context, in *GetFromFamilyImageRequest, opts ...grpc.CallOption) (*Image, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyImageRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates an image in the specified project using the data included
	// in the request.
	Insert(ctx context.Context, in *InsertImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of custom images
	// available to the specified project. Custom images are images you
	// create that belong to your project. This method does not
	// get any images that belong to other projects, including publicly-available
	// images, like Debian 8. If you want to get a list of publicly-available
	// images, use this method to make a request to the respective image project,
	// such as debian-cloud or windows-cloud.
	List(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ImageList, error)
	// Patches the specified image with the data included in the request.
	// Only the following fields can be modified: family, description,
	// deprecation status.
	Patch(ctx context.Context, in *PatchImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyImageRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on an image. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsImageRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type imagesClient struct {
	cc grpc.ClientConnInterface
}

func NewImagesClient(cc grpc.ClientConnInterface) ImagesClient {
	return &imagesClient{cc}
}

func (c *imagesClient) Delete(ctx context.Context, in *DeleteImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Images_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) Deprecate(ctx context.Context, in *DeprecateImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Images_Deprecate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) Get(ctx context.Context, in *GetImageRequest, opts ...grpc.CallOption) (*Image, error) {
	out := new(Image)
	err := c.cc.Invoke(ctx, Images_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetFromFamily(ctx context.Context, in *GetFromFamilyImageRequest, opts ...grpc.CallOption) (*Image, error) {
	out := new(Image)
	err := c.cc.Invoke(ctx, Images_GetFromFamily_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyImageRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Images_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) Insert(ctx context.Context, in *InsertImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Images_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) List(ctx context.Context, in *ListImagesRequest, opts ...grpc.CallOption) (*ImageList, error) {
	out := new(ImageList)
	err := c.cc.Invoke(ctx, Images_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) Patch(ctx context.Context, in *PatchImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Images_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyImageRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Images_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) SetLabels(ctx context.Context, in *SetLabelsImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Images_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *imagesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsImageRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Images_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ImagesServer is the server API for Images service.
// All implementations should embed UnimplementedImagesServer
// for forward compatibility
type ImagesServer interface {
	// Deletes the specified image.
	Delete(context.Context, *DeleteImageRequest) (*Operation, error)
	// Sets the deprecation status of an image.
	//
	// If an empty request body is given, clears the deprecation status instead.
	Deprecate(context.Context, *DeprecateImageRequest) (*Operation, error)
	// Returns the specified image.
	Get(context.Context, *GetImageRequest) (*Image, error)
	// Returns the latest image that is part of an image family and is not
	// deprecated. For more information on image families, seePublic
	// image families documentation.
	GetFromFamily(context.Context, *GetFromFamilyImageRequest) (*Image, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyImageRequest) (*Policy, error)
	// Creates an image in the specified project using the data included
	// in the request.
	Insert(context.Context, *InsertImageRequest) (*Operation, error)
	// Retrieves the list of custom images
	// available to the specified project. Custom images are images you
	// create that belong to your project. This method does not
	// get any images that belong to other projects, including publicly-available
	// images, like Debian 8. If you want to get a list of publicly-available
	// images, use this method to make a request to the respective image project,
	// such as debian-cloud or windows-cloud.
	List(context.Context, *ListImagesRequest) (*ImageList, error)
	// Patches the specified image with the data included in the request.
	// Only the following fields can be modified: family, description,
	// deprecation status.
	Patch(context.Context, *PatchImageRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyImageRequest) (*Policy, error)
	// Sets the labels on an image. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsImageRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsImageRequest) (*TestPermissionsResponse, error)
}

// UnimplementedImagesServer should be embedded to have forward compatible implementations.
type UnimplementedImagesServer struct {
}

func (UnimplementedImagesServer) Delete(context.Context, *DeleteImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedImagesServer) Deprecate(context.Context, *DeprecateImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Deprecate not implemented")
}
func (UnimplementedImagesServer) Get(context.Context, *GetImageRequest) (*Image, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedImagesServer) GetFromFamily(context.Context, *GetFromFamilyImageRequest) (*Image, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFromFamily not implemented")
}
func (UnimplementedImagesServer) GetIamPolicy(context.Context, *GetIamPolicyImageRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedImagesServer) Insert(context.Context, *InsertImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedImagesServer) List(context.Context, *ListImagesRequest) (*ImageList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedImagesServer) Patch(context.Context, *PatchImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedImagesServer) SetIamPolicy(context.Context, *SetIamPolicyImageRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedImagesServer) SetLabels(context.Context, *SetLabelsImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedImagesServer) TestIamPermissions(context.Context, *TestIamPermissionsImageRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeImagesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ImagesServer will
// result in compilation errors.
type UnsafeImagesServer interface {
	mustEmbedUnimplementedImagesServer()
}

func RegisterImagesServer(s grpc.ServiceRegistrar, srv ImagesServer) {
	s.RegisterService(&Images_ServiceDesc, srv)
}

func _Images_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Delete(ctx, req.(*DeleteImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_Deprecate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeprecateImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Deprecate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_Deprecate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Deprecate(ctx, req.(*DeprecateImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Get(ctx, req.(*GetImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetFromFamily_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFromFamilyImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetFromFamily(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_GetFromFamily_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetFromFamily(ctx, req.(*GetFromFamilyImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).GetIamPolicy(ctx, req.(*GetIamPolicyImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Insert(ctx, req.(*InsertImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).List(ctx, req.(*ListImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).Patch(ctx, req.(*PatchImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).SetIamPolicy(ctx, req.(*SetIamPolicyImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).SetLabels(ctx, req.(*SetLabelsImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Images_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ImagesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Images_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ImagesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Images_ServiceDesc is the grpc.ServiceDesc for Images service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Images_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Images",
	HandlerType: (*ImagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Images_Delete_Handler,
		},
		{
			MethodName: "Deprecate",
			Handler:    _Images_Deprecate_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Images_Get_Handler,
		},
		{
			MethodName: "GetFromFamily",
			Handler:    _Images_GetFromFamily_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Images_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Images_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Images_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Images_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Images_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _Images_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Images_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InstanceGroupManagerResizeRequests_Cancel_FullMethodName = "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Cancel"
	InstanceGroupManagerResizeRequests_Delete_FullMethodName = "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Delete"
	InstanceGroupManagerResizeRequests_Get_FullMethodName    = "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Get"
	InstanceGroupManagerResizeRequests_Insert_FullMethodName = "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/Insert"
	InstanceGroupManagerResizeRequests_List_FullMethodName   = "/google.cloud.compute.v1.InstanceGroupManagerResizeRequests/List"
)

// InstanceGroupManagerResizeRequestsClient is the client API for InstanceGroupManagerResizeRequests service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceGroupManagerResizeRequestsClient interface {
	// Cancels the specified resize request and removes it from the queue.
	// Cancelled resize request does no longer wait for the resources to be
	// provisioned. Cancel is only possible for requests that are accepted in the
	// queue.
	Cancel(ctx context.Context, in *CancelInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified, inactive resize request. Requests that are still
	// active cannot be deleted. Deleting request does not delete instances that
	// were provisioned previously.
	Delete(ctx context.Context, in *DeleteInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns all of the details about the specified resize request.
	Get(ctx context.Context, in *GetInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*InstanceGroupManagerResizeRequest, error)
	// Creates a new resize request that starts provisioning VMs immediately
	// or queues VM creation.
	Insert(ctx context.Context, in *InsertInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of resize requests that are contained in the
	// managed instance group.
	List(ctx context.Context, in *ListInstanceGroupManagerResizeRequestsRequest, opts ...grpc.CallOption) (*InstanceGroupManagerResizeRequestsListResponse, error)
}

type instanceGroupManagerResizeRequestsClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceGroupManagerResizeRequestsClient(cc grpc.ClientConnInterface) InstanceGroupManagerResizeRequestsClient {
	return &instanceGroupManagerResizeRequestsClient{cc}
}

func (c *instanceGroupManagerResizeRequestsClient) Cancel(ctx context.Context, in *CancelInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagerResizeRequests_Cancel_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagerResizeRequestsClient) Delete(ctx context.Context, in *DeleteInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagerResizeRequests_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagerResizeRequestsClient) Get(ctx context.Context, in *GetInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*InstanceGroupManagerResizeRequest, error) {
	out := new(InstanceGroupManagerResizeRequest)
	err := c.cc.Invoke(ctx, InstanceGroupManagerResizeRequests_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagerResizeRequestsClient) Insert(ctx context.Context, in *InsertInstanceGroupManagerResizeRequestRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagerResizeRequests_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagerResizeRequestsClient) List(ctx context.Context, in *ListInstanceGroupManagerResizeRequestsRequest, opts ...grpc.CallOption) (*InstanceGroupManagerResizeRequestsListResponse, error) {
	out := new(InstanceGroupManagerResizeRequestsListResponse)
	err := c.cc.Invoke(ctx, InstanceGroupManagerResizeRequests_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceGroupManagerResizeRequestsServer is the server API for InstanceGroupManagerResizeRequests service.
// All implementations should embed UnimplementedInstanceGroupManagerResizeRequestsServer
// for forward compatibility
type InstanceGroupManagerResizeRequestsServer interface {
	// Cancels the specified resize request and removes it from the queue.
	// Cancelled resize request does no longer wait for the resources to be
	// provisioned. Cancel is only possible for requests that are accepted in the
	// queue.
	Cancel(context.Context, *CancelInstanceGroupManagerResizeRequestRequest) (*Operation, error)
	// Deletes the specified, inactive resize request. Requests that are still
	// active cannot be deleted. Deleting request does not delete instances that
	// were provisioned previously.
	Delete(context.Context, *DeleteInstanceGroupManagerResizeRequestRequest) (*Operation, error)
	// Returns all of the details about the specified resize request.
	Get(context.Context, *GetInstanceGroupManagerResizeRequestRequest) (*InstanceGroupManagerResizeRequest, error)
	// Creates a new resize request that starts provisioning VMs immediately
	// or queues VM creation.
	Insert(context.Context, *InsertInstanceGroupManagerResizeRequestRequest) (*Operation, error)
	// Retrieves a list of resize requests that are contained in the
	// managed instance group.
	List(context.Context, *ListInstanceGroupManagerResizeRequestsRequest) (*InstanceGroupManagerResizeRequestsListResponse, error)
}

// UnimplementedInstanceGroupManagerResizeRequestsServer should be embedded to have forward compatible implementations.
type UnimplementedInstanceGroupManagerResizeRequestsServer struct {
}

func (UnimplementedInstanceGroupManagerResizeRequestsServer) Cancel(context.Context, *CancelInstanceGroupManagerResizeRequestRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}
func (UnimplementedInstanceGroupManagerResizeRequestsServer) Delete(context.Context, *DeleteInstanceGroupManagerResizeRequestRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceGroupManagerResizeRequestsServer) Get(context.Context, *GetInstanceGroupManagerResizeRequestRequest) (*InstanceGroupManagerResizeRequest, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceGroupManagerResizeRequestsServer) Insert(context.Context, *InsertInstanceGroupManagerResizeRequestRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInstanceGroupManagerResizeRequestsServer) List(context.Context, *ListInstanceGroupManagerResizeRequestsRequest) (*InstanceGroupManagerResizeRequestsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeInstanceGroupManagerResizeRequestsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceGroupManagerResizeRequestsServer will
// result in compilation errors.
type UnsafeInstanceGroupManagerResizeRequestsServer interface {
	mustEmbedUnimplementedInstanceGroupManagerResizeRequestsServer()
}

func RegisterInstanceGroupManagerResizeRequestsServer(s grpc.ServiceRegistrar, srv InstanceGroupManagerResizeRequestsServer) {
	s.RegisterService(&InstanceGroupManagerResizeRequests_ServiceDesc, srv)
}

func _InstanceGroupManagerResizeRequests_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelInstanceGroupManagerResizeRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagerResizeRequestsServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagerResizeRequests_Cancel_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagerResizeRequestsServer).Cancel(ctx, req.(*CancelInstanceGroupManagerResizeRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagerResizeRequests_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceGroupManagerResizeRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagerResizeRequestsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagerResizeRequests_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagerResizeRequestsServer).Delete(ctx, req.(*DeleteInstanceGroupManagerResizeRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagerResizeRequests_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceGroupManagerResizeRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagerResizeRequestsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagerResizeRequests_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagerResizeRequestsServer).Get(ctx, req.(*GetInstanceGroupManagerResizeRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagerResizeRequests_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInstanceGroupManagerResizeRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagerResizeRequestsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagerResizeRequests_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagerResizeRequestsServer).Insert(ctx, req.(*InsertInstanceGroupManagerResizeRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagerResizeRequests_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstanceGroupManagerResizeRequestsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagerResizeRequestsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagerResizeRequests_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagerResizeRequestsServer).List(ctx, req.(*ListInstanceGroupManagerResizeRequestsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceGroupManagerResizeRequests_ServiceDesc is the grpc.ServiceDesc for InstanceGroupManagerResizeRequests service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceGroupManagerResizeRequests_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InstanceGroupManagerResizeRequests",
	HandlerType: (*InstanceGroupManagerResizeRequestsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Cancel",
			Handler:    _InstanceGroupManagerResizeRequests_Cancel_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceGroupManagerResizeRequests_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstanceGroupManagerResizeRequests_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InstanceGroupManagerResizeRequests_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InstanceGroupManagerResizeRequests_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InstanceGroupManagers_AbandonInstances_FullMethodName         = "/google.cloud.compute.v1.InstanceGroupManagers/AbandonInstances"
	InstanceGroupManagers_AggregatedList_FullMethodName           = "/google.cloud.compute.v1.InstanceGroupManagers/AggregatedList"
	InstanceGroupManagers_ApplyUpdatesToInstances_FullMethodName  = "/google.cloud.compute.v1.InstanceGroupManagers/ApplyUpdatesToInstances"
	InstanceGroupManagers_CreateInstances_FullMethodName          = "/google.cloud.compute.v1.InstanceGroupManagers/CreateInstances"
	InstanceGroupManagers_Delete_FullMethodName                   = "/google.cloud.compute.v1.InstanceGroupManagers/Delete"
	InstanceGroupManagers_DeleteInstances_FullMethodName          = "/google.cloud.compute.v1.InstanceGroupManagers/DeleteInstances"
	InstanceGroupManagers_DeletePerInstanceConfigs_FullMethodName = "/google.cloud.compute.v1.InstanceGroupManagers/DeletePerInstanceConfigs"
	InstanceGroupManagers_Get_FullMethodName                      = "/google.cloud.compute.v1.InstanceGroupManagers/Get"
	InstanceGroupManagers_Insert_FullMethodName                   = "/google.cloud.compute.v1.InstanceGroupManagers/Insert"
	InstanceGroupManagers_List_FullMethodName                     = "/google.cloud.compute.v1.InstanceGroupManagers/List"
	InstanceGroupManagers_ListErrors_FullMethodName               = "/google.cloud.compute.v1.InstanceGroupManagers/ListErrors"
	InstanceGroupManagers_ListManagedInstances_FullMethodName     = "/google.cloud.compute.v1.InstanceGroupManagers/ListManagedInstances"
	InstanceGroupManagers_ListPerInstanceConfigs_FullMethodName   = "/google.cloud.compute.v1.InstanceGroupManagers/ListPerInstanceConfigs"
	InstanceGroupManagers_Patch_FullMethodName                    = "/google.cloud.compute.v1.InstanceGroupManagers/Patch"
	InstanceGroupManagers_PatchPerInstanceConfigs_FullMethodName  = "/google.cloud.compute.v1.InstanceGroupManagers/PatchPerInstanceConfigs"
	InstanceGroupManagers_RecreateInstances_FullMethodName        = "/google.cloud.compute.v1.InstanceGroupManagers/RecreateInstances"
	InstanceGroupManagers_Resize_FullMethodName                   = "/google.cloud.compute.v1.InstanceGroupManagers/Resize"
	InstanceGroupManagers_ResumeInstances_FullMethodName          = "/google.cloud.compute.v1.InstanceGroupManagers/ResumeInstances"
	InstanceGroupManagers_SetInstanceTemplate_FullMethodName      = "/google.cloud.compute.v1.InstanceGroupManagers/SetInstanceTemplate"
	InstanceGroupManagers_SetTargetPools_FullMethodName           = "/google.cloud.compute.v1.InstanceGroupManagers/SetTargetPools"
	InstanceGroupManagers_StartInstances_FullMethodName           = "/google.cloud.compute.v1.InstanceGroupManagers/StartInstances"
	InstanceGroupManagers_StopInstances_FullMethodName            = "/google.cloud.compute.v1.InstanceGroupManagers/StopInstances"
	InstanceGroupManagers_SuspendInstances_FullMethodName         = "/google.cloud.compute.v1.InstanceGroupManagers/SuspendInstances"
	InstanceGroupManagers_UpdatePerInstanceConfigs_FullMethodName = "/google.cloud.compute.v1.InstanceGroupManagers/UpdatePerInstanceConfigs"
)

// InstanceGroupManagersClient is the client API for InstanceGroupManagers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceGroupManagersClient interface {
	// Flags the specified instances to be removed from the
	// managed instance group. Abandoning an instance does not delete the
	// instance, but it does remove the instance from any target pools that are
	// applied by the managed instance group. This method reduces thetargetSize of the managed instance group by the
	// number of instances that you abandon. This operation is marked asDONE when the action is scheduled even if the instances have
	// not yet been removed from the group. You must separately verify the
	// status of the abandoning action with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	AbandonInstances(ctx context.Context, in *AbandonInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of managed instance groups and groups them by zone.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagerAggregatedList, error)
	// Applies changes to selected instances on the managed instance group.
	// This method can be used to apply new overrides and/or new versions.
	ApplyUpdatesToInstances(ctx context.Context, in *ApplyUpdatesToInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Creates instances with per-instance configurations in this managed instance
	// group. Instances are created using the current instance template. Thecreate instances operation is marked DONE if thecreateInstances request is successful. The underlying actions
	// take additional time. You must separately verify the status of thecreating or actions with the listmanagedinstances
	// method.
	CreateInstances(ctx context.Context, in *CreateInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified managed instance group and all of the instances
	// in that group. Note that the instance group must not belong to a
	// backend service. Read
	// Deleting an instance group for more information.
	Delete(ctx context.Context, in *DeleteInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group for immediate
	// deletion. The instances are also removed from any target
	// pools of which they were a member. This method reduces thetargetSize of the managed instance group by the number of
	// instances that you delete. This operation is marked as DONE
	// when the action is scheduled even if the instances are still being deleted.
	// You must separately verify the status of the deleting action
	// with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	DeleteInstances(ctx context.Context, in *DeleteInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes selected per-instance configurations for the managed instance
	// group.
	DeletePerInstanceConfigs(ctx context.Context, in *DeletePerInstanceConfigsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns all of the details about the specified managed instance group.
	Get(ctx context.Context, in *GetInstanceGroupManagerRequest, opts ...grpc.CallOption) (*InstanceGroupManager, error)
	// Creates a managed instance group using the information that you specify
	// in the request. After the group is created, instances in the group are
	// created using the specified instance template.
	// This operation is marked as DONE when the group is created
	// even if the instances in the group have not yet been created. You
	// must separately verify the status of the individual instances with thelistmanagedinstances
	// method.
	//
	// A managed instance group can have up to 1000 VM instances per group. Please
	// contact Cloud Support if you need an increase in
	// this limit.
	Insert(ctx context.Context, in *InsertInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of managed instance groups that are contained within the
	// specified project and zone.
	List(ctx context.Context, in *ListInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagerList, error)
	// Lists all errors thrown by actions on instances for a given managed
	// instance group. The filter and orderBy query
	// parameters are not supported.
	ListErrors(ctx context.Context, in *ListErrorsInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagersListErrorsResponse, error)
	// Lists all of the instances in the managed instance group. Each instance
	// in the list has a currentAction, which indicates the action
	// that the managed instance group is performing on the instance. For example,
	// if the group is still creating an instance, the currentAction
	// is CREATING. If a previous action failed, the
	// list displays the errors for that failed action. The orderBy
	// query parameter is not supported. The `pageToken` query parameter is
	// supported only if the group's `listManagedInstancesResults` field is set
	// to `PAGINATED`.
	ListManagedInstances(ctx context.Context, in *ListManagedInstancesInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagersListManagedInstancesResponse, error)
	// Lists all of the per-instance configurations defined for the managed
	// instance group. The orderBy query parameter is not supported.
	ListPerInstanceConfigs(ctx context.Context, in *ListPerInstanceConfigsInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagersListPerInstanceConfigsResp, error)
	// Updates a managed instance group using the information that you specify
	// in the request.
	// This operation is marked as DONE when the group is patched
	// even if the instances in the group are still in the process of being
	// patched. You must separately verify the status of the individual instances
	// with thelistManagedInstances
	// method. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	//
	// If you update your group to specify a new template or instance
	// configuration, it's possible that your intended specification for each VM
	// in the group is different from the current state of that VM. To learn how
	// to apply an updated configuration to the VMs in a MIG, seeUpdating instances in
	// a MIG.
	Patch(ctx context.Context, in *PatchInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts or patches per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	PatchPerInstanceConfigs(ctx context.Context, in *PatchPerInstanceConfigsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified VM instances in the managed instance group to be
	// immediately recreated. Each instance is recreated using the group's current
	// configuration. This operation is marked as DONE when the flag
	// is set even if the instances have not yet been recreated. You must
	// separately verify the status of each instance by checking itscurrentAction field; for more information, see Checking
	// the status of managed instances.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	RecreateInstances(ctx context.Context, in *RecreateInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Resizes the managed instance group. If you increase the size, the group
	// creates new instances using the current instance template. If you decrease
	// the size, the group deletes instances. The resize operation is markedDONE when the resize actions are scheduled even if the group
	// has not yet added or deleted any instances. You must separately
	// verify the status of the creating or deleting
	// actions with thelistmanagedinstances
	// method.
	//
	// When resizing down, the instance group arbitrarily chooses the order in
	// which VMs are deleted. The group takes into account some VM attributes when
	// making the selection including:
	//
	// + The status of the VM instance.
	// + The health of the VM instance.
	// + The instance template version the VM is based on.
	// + For regional managed instance groups, the location of the VM instance.
	//
	// This list is subject to change.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	Resize(ctx context.Context, in *ResizeInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// resumed. This method increases thetargetSize and decreases the targetSuspendedSize
	// of the managed instance group by the number of instances that you resume.
	// The resumeInstances operation is marked DONE if
	// the resumeInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theRESUMING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are suspended. For
	// example, if an instance was previously suspended using the suspendInstances
	// method, it can be resumed using the resumeInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are resumed.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	ResumeInstances(ctx context.Context, in *ResumeInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Specifies the instance template to use when creating new instances in this
	// group. The templates for existing instances in the group do not change
	// unless you run recreateInstances, runapplyUpdatesToInstances, or set the group'supdatePolicy.type to PROACTIVE.
	SetInstanceTemplate(ctx context.Context, in *SetInstanceTemplateInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Modifies the target pools to which all instances in this managed instance
	// group are assigned. The target pools automatically apply to all of the
	// instances in the managed instance group. This operation is markedDONE when you make the request even if the instances have not
	// yet been added to their target pools. The change might take some time to
	// apply to all of the instances in the group depending on the size of the
	// group.
	SetTargetPools(ctx context.Context, in *SetTargetPoolsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// started. This method increases thetargetSize and decreases the targetStoppedSize
	// of the managed instance group by the number of instances that you start.
	// The startInstances operation is marked DONE if
	// the startInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTARTING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are stopped. For
	// example, if an instance was previously stopped using the stopInstances
	// method, it can be started using the startInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are started.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StartInstances(ctx context.Context, in *StartInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately stopped. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetStoppedSize
	// of the managed instance group by the number of instances that you stop.
	// The stopInstances operation is marked DONE if
	// the stopInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTOPPING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays stopping the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is stopped.
	//
	// Stopped instances can be started using the startInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StopInstances(ctx context.Context, in *StopInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately suspended. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetSuspendedSize
	// of the managed instance group by the number of instances that you suspend.
	// The suspendInstances operation is marked DONE if
	// the suspendInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSUSPENDING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays suspension of the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is suspended.
	//
	// Suspended instances can be resumed using the resumeInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	SuspendInstances(ctx context.Context, in *SuspendInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts or updates per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	UpdatePerInstanceConfigs(ctx context.Context, in *UpdatePerInstanceConfigsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
}

type instanceGroupManagersClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceGroupManagersClient(cc grpc.ClientConnInterface) InstanceGroupManagersClient {
	return &instanceGroupManagersClient{cc}
}

func (c *instanceGroupManagersClient) AbandonInstances(ctx context.Context, in *AbandonInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_AbandonInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) AggregatedList(ctx context.Context, in *AggregatedListInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagerAggregatedList, error) {
	out := new(InstanceGroupManagerAggregatedList)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) ApplyUpdatesToInstances(ctx context.Context, in *ApplyUpdatesToInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_ApplyUpdatesToInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) CreateInstances(ctx context.Context, in *CreateInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_CreateInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) Delete(ctx context.Context, in *DeleteInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) DeleteInstances(ctx context.Context, in *DeleteInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_DeleteInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) DeletePerInstanceConfigs(ctx context.Context, in *DeletePerInstanceConfigsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_DeletePerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) Get(ctx context.Context, in *GetInstanceGroupManagerRequest, opts ...grpc.CallOption) (*InstanceGroupManager, error) {
	out := new(InstanceGroupManager)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) Insert(ctx context.Context, in *InsertInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) List(ctx context.Context, in *ListInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagerList, error) {
	out := new(InstanceGroupManagerList)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) ListErrors(ctx context.Context, in *ListErrorsInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagersListErrorsResponse, error) {
	out := new(InstanceGroupManagersListErrorsResponse)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_ListErrors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) ListManagedInstances(ctx context.Context, in *ListManagedInstancesInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagersListManagedInstancesResponse, error) {
	out := new(InstanceGroupManagersListManagedInstancesResponse)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_ListManagedInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) ListPerInstanceConfigs(ctx context.Context, in *ListPerInstanceConfigsInstanceGroupManagersRequest, opts ...grpc.CallOption) (*InstanceGroupManagersListPerInstanceConfigsResp, error) {
	out := new(InstanceGroupManagersListPerInstanceConfigsResp)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_ListPerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) Patch(ctx context.Context, in *PatchInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) PatchPerInstanceConfigs(ctx context.Context, in *PatchPerInstanceConfigsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_PatchPerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) RecreateInstances(ctx context.Context, in *RecreateInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_RecreateInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) Resize(ctx context.Context, in *ResizeInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_Resize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) ResumeInstances(ctx context.Context, in *ResumeInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_ResumeInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) SetInstanceTemplate(ctx context.Context, in *SetInstanceTemplateInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_SetInstanceTemplate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) SetTargetPools(ctx context.Context, in *SetTargetPoolsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_SetTargetPools_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) StartInstances(ctx context.Context, in *StartInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_StartInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) StopInstances(ctx context.Context, in *StopInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_StopInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) SuspendInstances(ctx context.Context, in *SuspendInstancesInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_SuspendInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupManagersClient) UpdatePerInstanceConfigs(ctx context.Context, in *UpdatePerInstanceConfigsInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroupManagers_UpdatePerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceGroupManagersServer is the server API for InstanceGroupManagers service.
// All implementations should embed UnimplementedInstanceGroupManagersServer
// for forward compatibility
type InstanceGroupManagersServer interface {
	// Flags the specified instances to be removed from the
	// managed instance group. Abandoning an instance does not delete the
	// instance, but it does remove the instance from any target pools that are
	// applied by the managed instance group. This method reduces thetargetSize of the managed instance group by the
	// number of instances that you abandon. This operation is marked asDONE when the action is scheduled even if the instances have
	// not yet been removed from the group. You must separately verify the
	// status of the abandoning action with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	AbandonInstances(context.Context, *AbandonInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Retrieves the list of managed instance groups and groups them by zone.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListInstanceGroupManagersRequest) (*InstanceGroupManagerAggregatedList, error)
	// Applies changes to selected instances on the managed instance group.
	// This method can be used to apply new overrides and/or new versions.
	ApplyUpdatesToInstances(context.Context, *ApplyUpdatesToInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Creates instances with per-instance configurations in this managed instance
	// group. Instances are created using the current instance template. Thecreate instances operation is marked DONE if thecreateInstances request is successful. The underlying actions
	// take additional time. You must separately verify the status of thecreating or actions with the listmanagedinstances
	// method.
	CreateInstances(context.Context, *CreateInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Deletes the specified managed instance group and all of the instances
	// in that group. Note that the instance group must not belong to a
	// backend service. Read
	// Deleting an instance group for more information.
	Delete(context.Context, *DeleteInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group for immediate
	// deletion. The instances are also removed from any target
	// pools of which they were a member. This method reduces thetargetSize of the managed instance group by the number of
	// instances that you delete. This operation is marked as DONE
	// when the action is scheduled even if the instances are still being deleted.
	// You must separately verify the status of the deleting action
	// with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	DeleteInstances(context.Context, *DeleteInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Deletes selected per-instance configurations for the managed instance
	// group.
	DeletePerInstanceConfigs(context.Context, *DeletePerInstanceConfigsInstanceGroupManagerRequest) (*Operation, error)
	// Returns all of the details about the specified managed instance group.
	Get(context.Context, *GetInstanceGroupManagerRequest) (*InstanceGroupManager, error)
	// Creates a managed instance group using the information that you specify
	// in the request. After the group is created, instances in the group are
	// created using the specified instance template.
	// This operation is marked as DONE when the group is created
	// even if the instances in the group have not yet been created. You
	// must separately verify the status of the individual instances with thelistmanagedinstances
	// method.
	//
	// A managed instance group can have up to 1000 VM instances per group. Please
	// contact Cloud Support if you need an increase in
	// this limit.
	Insert(context.Context, *InsertInstanceGroupManagerRequest) (*Operation, error)
	// Retrieves a list of managed instance groups that are contained within the
	// specified project and zone.
	List(context.Context, *ListInstanceGroupManagersRequest) (*InstanceGroupManagerList, error)
	// Lists all errors thrown by actions on instances for a given managed
	// instance group. The filter and orderBy query
	// parameters are not supported.
	ListErrors(context.Context, *ListErrorsInstanceGroupManagersRequest) (*InstanceGroupManagersListErrorsResponse, error)
	// Lists all of the instances in the managed instance group. Each instance
	// in the list has a currentAction, which indicates the action
	// that the managed instance group is performing on the instance. For example,
	// if the group is still creating an instance, the currentAction
	// is CREATING. If a previous action failed, the
	// list displays the errors for that failed action. The orderBy
	// query parameter is not supported. The `pageToken` query parameter is
	// supported only if the group's `listManagedInstancesResults` field is set
	// to `PAGINATED`.
	ListManagedInstances(context.Context, *ListManagedInstancesInstanceGroupManagersRequest) (*InstanceGroupManagersListManagedInstancesResponse, error)
	// Lists all of the per-instance configurations defined for the managed
	// instance group. The orderBy query parameter is not supported.
	ListPerInstanceConfigs(context.Context, *ListPerInstanceConfigsInstanceGroupManagersRequest) (*InstanceGroupManagersListPerInstanceConfigsResp, error)
	// Updates a managed instance group using the information that you specify
	// in the request.
	// This operation is marked as DONE when the group is patched
	// even if the instances in the group are still in the process of being
	// patched. You must separately verify the status of the individual instances
	// with thelistManagedInstances
	// method. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	//
	// If you update your group to specify a new template or instance
	// configuration, it's possible that your intended specification for each VM
	// in the group is different from the current state of that VM. To learn how
	// to apply an updated configuration to the VMs in a MIG, seeUpdating instances in
	// a MIG.
	Patch(context.Context, *PatchInstanceGroupManagerRequest) (*Operation, error)
	// Inserts or patches per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	PatchPerInstanceConfigs(context.Context, *PatchPerInstanceConfigsInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified VM instances in the managed instance group to be
	// immediately recreated. Each instance is recreated using the group's current
	// configuration. This operation is marked as DONE when the flag
	// is set even if the instances have not yet been recreated. You must
	// separately verify the status of each instance by checking itscurrentAction field; for more information, see Checking
	// the status of managed instances.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	RecreateInstances(context.Context, *RecreateInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Resizes the managed instance group. If you increase the size, the group
	// creates new instances using the current instance template. If you decrease
	// the size, the group deletes instances. The resize operation is markedDONE when the resize actions are scheduled even if the group
	// has not yet added or deleted any instances. You must separately
	// verify the status of the creating or deleting
	// actions with thelistmanagedinstances
	// method.
	//
	// When resizing down, the instance group arbitrarily chooses the order in
	// which VMs are deleted. The group takes into account some VM attributes when
	// making the selection including:
	//
	// + The status of the VM instance.
	// + The health of the VM instance.
	// + The instance template version the VM is based on.
	// + For regional managed instance groups, the location of the VM instance.
	//
	// This list is subject to change.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	Resize(context.Context, *ResizeInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// resumed. This method increases thetargetSize and decreases the targetSuspendedSize
	// of the managed instance group by the number of instances that you resume.
	// The resumeInstances operation is marked DONE if
	// the resumeInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theRESUMING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are suspended. For
	// example, if an instance was previously suspended using the suspendInstances
	// method, it can be resumed using the resumeInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are resumed.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	ResumeInstances(context.Context, *ResumeInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Specifies the instance template to use when creating new instances in this
	// group. The templates for existing instances in the group do not change
	// unless you run recreateInstances, runapplyUpdatesToInstances, or set the group'supdatePolicy.type to PROACTIVE.
	SetInstanceTemplate(context.Context, *SetInstanceTemplateInstanceGroupManagerRequest) (*Operation, error)
	// Modifies the target pools to which all instances in this managed instance
	// group are assigned. The target pools automatically apply to all of the
	// instances in the managed instance group. This operation is markedDONE when you make the request even if the instances have not
	// yet been added to their target pools. The change might take some time to
	// apply to all of the instances in the group depending on the size of the
	// group.
	SetTargetPools(context.Context, *SetTargetPoolsInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// started. This method increases thetargetSize and decreases the targetStoppedSize
	// of the managed instance group by the number of instances that you start.
	// The startInstances operation is marked DONE if
	// the startInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTARTING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are stopped. For
	// example, if an instance was previously stopped using the stopInstances
	// method, it can be started using the startInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are started.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StartInstances(context.Context, *StartInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately stopped. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetStoppedSize
	// of the managed instance group by the number of instances that you stop.
	// The stopInstances operation is marked DONE if
	// the stopInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTOPPING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays stopping the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is stopped.
	//
	// Stopped instances can be started using the startInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StopInstances(context.Context, *StopInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately suspended. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetSuspendedSize
	// of the managed instance group by the number of instances that you suspend.
	// The suspendInstances operation is marked DONE if
	// the suspendInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSUSPENDING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays suspension of the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is suspended.
	//
	// Suspended instances can be resumed using the resumeInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	SuspendInstances(context.Context, *SuspendInstancesInstanceGroupManagerRequest) (*Operation, error)
	// Inserts or updates per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	UpdatePerInstanceConfigs(context.Context, *UpdatePerInstanceConfigsInstanceGroupManagerRequest) (*Operation, error)
}

// UnimplementedInstanceGroupManagersServer should be embedded to have forward compatible implementations.
type UnimplementedInstanceGroupManagersServer struct {
}

func (UnimplementedInstanceGroupManagersServer) AbandonInstances(context.Context, *AbandonInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbandonInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) AggregatedList(context.Context, *AggregatedListInstanceGroupManagersRequest) (*InstanceGroupManagerAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedInstanceGroupManagersServer) ApplyUpdatesToInstances(context.Context, *ApplyUpdatesToInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyUpdatesToInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) CreateInstances(context.Context, *CreateInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) Delete(context.Context, *DeleteInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceGroupManagersServer) DeleteInstances(context.Context, *DeleteInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) DeletePerInstanceConfigs(context.Context, *DeletePerInstanceConfigsInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePerInstanceConfigs not implemented")
}
func (UnimplementedInstanceGroupManagersServer) Get(context.Context, *GetInstanceGroupManagerRequest) (*InstanceGroupManager, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceGroupManagersServer) Insert(context.Context, *InsertInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInstanceGroupManagersServer) List(context.Context, *ListInstanceGroupManagersRequest) (*InstanceGroupManagerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInstanceGroupManagersServer) ListErrors(context.Context, *ListErrorsInstanceGroupManagersRequest) (*InstanceGroupManagersListErrorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListErrors not implemented")
}
func (UnimplementedInstanceGroupManagersServer) ListManagedInstances(context.Context, *ListManagedInstancesInstanceGroupManagersRequest) (*InstanceGroupManagersListManagedInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListManagedInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) ListPerInstanceConfigs(context.Context, *ListPerInstanceConfigsInstanceGroupManagersRequest) (*InstanceGroupManagersListPerInstanceConfigsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPerInstanceConfigs not implemented")
}
func (UnimplementedInstanceGroupManagersServer) Patch(context.Context, *PatchInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedInstanceGroupManagersServer) PatchPerInstanceConfigs(context.Context, *PatchPerInstanceConfigsInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchPerInstanceConfigs not implemented")
}
func (UnimplementedInstanceGroupManagersServer) RecreateInstances(context.Context, *RecreateInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecreateInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) Resize(context.Context, *ResizeInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resize not implemented")
}
func (UnimplementedInstanceGroupManagersServer) ResumeInstances(context.Context, *ResumeInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) SetInstanceTemplate(context.Context, *SetInstanceTemplateInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInstanceTemplate not implemented")
}
func (UnimplementedInstanceGroupManagersServer) SetTargetPools(context.Context, *SetTargetPoolsInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTargetPools not implemented")
}
func (UnimplementedInstanceGroupManagersServer) StartInstances(context.Context, *StartInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) StopInstances(context.Context, *StopInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) SuspendInstances(context.Context, *SuspendInstancesInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspendInstances not implemented")
}
func (UnimplementedInstanceGroupManagersServer) UpdatePerInstanceConfigs(context.Context, *UpdatePerInstanceConfigsInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePerInstanceConfigs not implemented")
}

// UnsafeInstanceGroupManagersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceGroupManagersServer will
// result in compilation errors.
type UnsafeInstanceGroupManagersServer interface {
	mustEmbedUnimplementedInstanceGroupManagersServer()
}

func RegisterInstanceGroupManagersServer(s grpc.ServiceRegistrar, srv InstanceGroupManagersServer) {
	s.RegisterService(&InstanceGroupManagers_ServiceDesc, srv)
}

func _InstanceGroupManagers_AbandonInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbandonInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).AbandonInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_AbandonInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).AbandonInstances(ctx, req.(*AbandonInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).AggregatedList(ctx, req.(*AggregatedListInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_ApplyUpdatesToInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyUpdatesToInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).ApplyUpdatesToInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_ApplyUpdatesToInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).ApplyUpdatesToInstances(ctx, req.(*ApplyUpdatesToInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_CreateInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).CreateInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_CreateInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).CreateInstances(ctx, req.(*CreateInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).Delete(ctx, req.(*DeleteInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_DeleteInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).DeleteInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_DeleteInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).DeleteInstances(ctx, req.(*DeleteInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_DeletePerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePerInstanceConfigsInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).DeletePerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_DeletePerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).DeletePerInstanceConfigs(ctx, req.(*DeletePerInstanceConfigsInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).Get(ctx, req.(*GetInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).Insert(ctx, req.(*InsertInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).List(ctx, req.(*ListInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_ListErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListErrorsInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).ListErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_ListErrors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).ListErrors(ctx, req.(*ListErrorsInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_ListManagedInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListManagedInstancesInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).ListManagedInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_ListManagedInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).ListManagedInstances(ctx, req.(*ListManagedInstancesInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_ListPerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPerInstanceConfigsInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).ListPerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_ListPerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).ListPerInstanceConfigs(ctx, req.(*ListPerInstanceConfigsInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).Patch(ctx, req.(*PatchInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_PatchPerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPerInstanceConfigsInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).PatchPerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_PatchPerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).PatchPerInstanceConfigs(ctx, req.(*PatchPerInstanceConfigsInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_RecreateInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecreateInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).RecreateInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_RecreateInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).RecreateInstances(ctx, req.(*RecreateInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_Resize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).Resize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_Resize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).Resize(ctx, req.(*ResizeInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_ResumeInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).ResumeInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_ResumeInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).ResumeInstances(ctx, req.(*ResumeInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_SetInstanceTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetInstanceTemplateInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).SetInstanceTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_SetInstanceTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).SetInstanceTemplate(ctx, req.(*SetInstanceTemplateInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_SetTargetPools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTargetPoolsInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).SetTargetPools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_SetTargetPools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).SetTargetPools(ctx, req.(*SetTargetPoolsInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_StartInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).StartInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_StartInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).StartInstances(ctx, req.(*StartInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_StopInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).StopInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_StopInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).StopInstances(ctx, req.(*StopInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_SuspendInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendInstancesInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).SuspendInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_SuspendInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).SuspendInstances(ctx, req.(*SuspendInstancesInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroupManagers_UpdatePerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePerInstanceConfigsInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupManagersServer).UpdatePerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroupManagers_UpdatePerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupManagersServer).UpdatePerInstanceConfigs(ctx, req.(*UpdatePerInstanceConfigsInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceGroupManagers_ServiceDesc is the grpc.ServiceDesc for InstanceGroupManagers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceGroupManagers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InstanceGroupManagers",
	HandlerType: (*InstanceGroupManagersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AbandonInstances",
			Handler:    _InstanceGroupManagers_AbandonInstances_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _InstanceGroupManagers_AggregatedList_Handler,
		},
		{
			MethodName: "ApplyUpdatesToInstances",
			Handler:    _InstanceGroupManagers_ApplyUpdatesToInstances_Handler,
		},
		{
			MethodName: "CreateInstances",
			Handler:    _InstanceGroupManagers_CreateInstances_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceGroupManagers_Delete_Handler,
		},
		{
			MethodName: "DeleteInstances",
			Handler:    _InstanceGroupManagers_DeleteInstances_Handler,
		},
		{
			MethodName: "DeletePerInstanceConfigs",
			Handler:    _InstanceGroupManagers_DeletePerInstanceConfigs_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstanceGroupManagers_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InstanceGroupManagers_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InstanceGroupManagers_List_Handler,
		},
		{
			MethodName: "ListErrors",
			Handler:    _InstanceGroupManagers_ListErrors_Handler,
		},
		{
			MethodName: "ListManagedInstances",
			Handler:    _InstanceGroupManagers_ListManagedInstances_Handler,
		},
		{
			MethodName: "ListPerInstanceConfigs",
			Handler:    _InstanceGroupManagers_ListPerInstanceConfigs_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _InstanceGroupManagers_Patch_Handler,
		},
		{
			MethodName: "PatchPerInstanceConfigs",
			Handler:    _InstanceGroupManagers_PatchPerInstanceConfigs_Handler,
		},
		{
			MethodName: "RecreateInstances",
			Handler:    _InstanceGroupManagers_RecreateInstances_Handler,
		},
		{
			MethodName: "Resize",
			Handler:    _InstanceGroupManagers_Resize_Handler,
		},
		{
			MethodName: "ResumeInstances",
			Handler:    _InstanceGroupManagers_ResumeInstances_Handler,
		},
		{
			MethodName: "SetInstanceTemplate",
			Handler:    _InstanceGroupManagers_SetInstanceTemplate_Handler,
		},
		{
			MethodName: "SetTargetPools",
			Handler:    _InstanceGroupManagers_SetTargetPools_Handler,
		},
		{
			MethodName: "StartInstances",
			Handler:    _InstanceGroupManagers_StartInstances_Handler,
		},
		{
			MethodName: "StopInstances",
			Handler:    _InstanceGroupManagers_StopInstances_Handler,
		},
		{
			MethodName: "SuspendInstances",
			Handler:    _InstanceGroupManagers_SuspendInstances_Handler,
		},
		{
			MethodName: "UpdatePerInstanceConfigs",
			Handler:    _InstanceGroupManagers_UpdatePerInstanceConfigs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InstanceGroups_AddInstances_FullMethodName       = "/google.cloud.compute.v1.InstanceGroups/AddInstances"
	InstanceGroups_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.InstanceGroups/AggregatedList"
	InstanceGroups_Delete_FullMethodName             = "/google.cloud.compute.v1.InstanceGroups/Delete"
	InstanceGroups_Get_FullMethodName                = "/google.cloud.compute.v1.InstanceGroups/Get"
	InstanceGroups_Insert_FullMethodName             = "/google.cloud.compute.v1.InstanceGroups/Insert"
	InstanceGroups_List_FullMethodName               = "/google.cloud.compute.v1.InstanceGroups/List"
	InstanceGroups_ListInstances_FullMethodName      = "/google.cloud.compute.v1.InstanceGroups/ListInstances"
	InstanceGroups_RemoveInstances_FullMethodName    = "/google.cloud.compute.v1.InstanceGroups/RemoveInstances"
	InstanceGroups_SetNamedPorts_FullMethodName      = "/google.cloud.compute.v1.InstanceGroups/SetNamedPorts"
	InstanceGroups_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.InstanceGroups/TestIamPermissions"
)

// InstanceGroupsClient is the client API for InstanceGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceGroupsClient interface {
	// Adds a list of instances to the specified instance group.  All of the
	// instances in the instance group must be in the same network/subnetwork.
	// Read
	// Adding instances for more information.
	AddInstances(ctx context.Context, in *AddInstancesInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of instance groups and sorts them by zone.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListInstanceGroupsRequest, opts ...grpc.CallOption) (*InstanceGroupAggregatedList, error)
	// Deletes the specified instance group. The instances in the group are not
	// deleted. Note that instance group must not belong to a backend service.
	// Read
	// Deleting an instance group for more information.
	Delete(ctx context.Context, in *DeleteInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified zonal instance group. Get a list of available zonal
	// instance groups by making a list() request.
	//
	// For managed instance groups, use theinstanceGroupManagers
	// or regionInstanceGroupManagers
	// methods instead.
	Get(ctx context.Context, in *GetInstanceGroupRequest, opts ...grpc.CallOption) (*InstanceGroup, error)
	// Creates an instance group in the specified project using the
	// parameters that are included in the request.
	Insert(ctx context.Context, in *InsertInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of zonal instance group resources contained within the
	// specified zone.
	//
	// For managed instance groups, use theinstanceGroupManagers
	// or regionInstanceGroupManagers
	// methods instead.
	List(ctx context.Context, in *ListInstanceGroupsRequest, opts ...grpc.CallOption) (*InstanceGroupList, error)
	// Lists the instances in the specified instance group.
	// The orderBy query parameter is not supported.
	// The filter query parameter is supported, but only for
	// expressions that use `eq` (equal) or `ne` (not equal) operators.
	ListInstances(ctx context.Context, in *ListInstancesInstanceGroupsRequest, opts ...grpc.CallOption) (*InstanceGroupsListInstances, error)
	// Removes one or more instances from the specified instance group, but does
	// not delete those instances.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration before the VM instance is removed or deleted.
	RemoveInstances(ctx context.Context, in *RemoveInstancesInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the named ports for the specified instance group.
	SetNamedPorts(ctx context.Context, in *SetNamedPortsInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstanceGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type instanceGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceGroupsClient(cc grpc.ClientConnInterface) InstanceGroupsClient {
	return &instanceGroupsClient{cc}
}

func (c *instanceGroupsClient) AddInstances(ctx context.Context, in *AddInstancesInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroups_AddInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) AggregatedList(ctx context.Context, in *AggregatedListInstanceGroupsRequest, opts ...grpc.CallOption) (*InstanceGroupAggregatedList, error) {
	out := new(InstanceGroupAggregatedList)
	err := c.cc.Invoke(ctx, InstanceGroups_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) Delete(ctx context.Context, in *DeleteInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) Get(ctx context.Context, in *GetInstanceGroupRequest, opts ...grpc.CallOption) (*InstanceGroup, error) {
	out := new(InstanceGroup)
	err := c.cc.Invoke(ctx, InstanceGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) Insert(ctx context.Context, in *InsertInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) List(ctx context.Context, in *ListInstanceGroupsRequest, opts ...grpc.CallOption) (*InstanceGroupList, error) {
	out := new(InstanceGroupList)
	err := c.cc.Invoke(ctx, InstanceGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) ListInstances(ctx context.Context, in *ListInstancesInstanceGroupsRequest, opts ...grpc.CallOption) (*InstanceGroupsListInstances, error) {
	out := new(InstanceGroupsListInstances)
	err := c.cc.Invoke(ctx, InstanceGroups_ListInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) RemoveInstances(ctx context.Context, in *RemoveInstancesInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroups_RemoveInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) SetNamedPorts(ctx context.Context, in *SetNamedPortsInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceGroups_SetNamedPorts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceGroupsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstanceGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, InstanceGroups_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceGroupsServer is the server API for InstanceGroups service.
// All implementations should embed UnimplementedInstanceGroupsServer
// for forward compatibility
type InstanceGroupsServer interface {
	// Adds a list of instances to the specified instance group.  All of the
	// instances in the instance group must be in the same network/subnetwork.
	// Read
	// Adding instances for more information.
	AddInstances(context.Context, *AddInstancesInstanceGroupRequest) (*Operation, error)
	// Retrieves the list of instance groups and sorts them by zone.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListInstanceGroupsRequest) (*InstanceGroupAggregatedList, error)
	// Deletes the specified instance group. The instances in the group are not
	// deleted. Note that instance group must not belong to a backend service.
	// Read
	// Deleting an instance group for more information.
	Delete(context.Context, *DeleteInstanceGroupRequest) (*Operation, error)
	// Returns the specified zonal instance group. Get a list of available zonal
	// instance groups by making a list() request.
	//
	// For managed instance groups, use theinstanceGroupManagers
	// or regionInstanceGroupManagers
	// methods instead.
	Get(context.Context, *GetInstanceGroupRequest) (*InstanceGroup, error)
	// Creates an instance group in the specified project using the
	// parameters that are included in the request.
	Insert(context.Context, *InsertInstanceGroupRequest) (*Operation, error)
	// Retrieves the list of zonal instance group resources contained within the
	// specified zone.
	//
	// For managed instance groups, use theinstanceGroupManagers
	// or regionInstanceGroupManagers
	// methods instead.
	List(context.Context, *ListInstanceGroupsRequest) (*InstanceGroupList, error)
	// Lists the instances in the specified instance group.
	// The orderBy query parameter is not supported.
	// The filter query parameter is supported, but only for
	// expressions that use `eq` (equal) or `ne` (not equal) operators.
	ListInstances(context.Context, *ListInstancesInstanceGroupsRequest) (*InstanceGroupsListInstances, error)
	// Removes one or more instances from the specified instance group, but does
	// not delete those instances.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration before the VM instance is removed or deleted.
	RemoveInstances(context.Context, *RemoveInstancesInstanceGroupRequest) (*Operation, error)
	// Sets the named ports for the specified instance group.
	SetNamedPorts(context.Context, *SetNamedPortsInstanceGroupRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsInstanceGroupRequest) (*TestPermissionsResponse, error)
}

// UnimplementedInstanceGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedInstanceGroupsServer struct {
}

func (UnimplementedInstanceGroupsServer) AddInstances(context.Context, *AddInstancesInstanceGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInstances not implemented")
}
func (UnimplementedInstanceGroupsServer) AggregatedList(context.Context, *AggregatedListInstanceGroupsRequest) (*InstanceGroupAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedInstanceGroupsServer) Delete(context.Context, *DeleteInstanceGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceGroupsServer) Get(context.Context, *GetInstanceGroupRequest) (*InstanceGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceGroupsServer) Insert(context.Context, *InsertInstanceGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInstanceGroupsServer) List(context.Context, *ListInstanceGroupsRequest) (*InstanceGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInstanceGroupsServer) ListInstances(context.Context, *ListInstancesInstanceGroupsRequest) (*InstanceGroupsListInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (UnimplementedInstanceGroupsServer) RemoveInstances(context.Context, *RemoveInstancesInstanceGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveInstances not implemented")
}
func (UnimplementedInstanceGroupsServer) SetNamedPorts(context.Context, *SetNamedPortsInstanceGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNamedPorts not implemented")
}
func (UnimplementedInstanceGroupsServer) TestIamPermissions(context.Context, *TestIamPermissionsInstanceGroupRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeInstanceGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceGroupsServer will
// result in compilation errors.
type UnsafeInstanceGroupsServer interface {
	mustEmbedUnimplementedInstanceGroupsServer()
}

func RegisterInstanceGroupsServer(s grpc.ServiceRegistrar, srv InstanceGroupsServer) {
	s.RegisterService(&InstanceGroups_ServiceDesc, srv)
}

func _InstanceGroups_AddInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInstancesInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).AddInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_AddInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).AddInstances(ctx, req.(*AddInstancesInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListInstanceGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).AggregatedList(ctx, req.(*AggregatedListInstanceGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).Delete(ctx, req.(*DeleteInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).Get(ctx, req.(*GetInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).Insert(ctx, req.(*InsertInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstanceGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).List(ctx, req.(*ListInstanceGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesInstanceGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_ListInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).ListInstances(ctx, req.(*ListInstancesInstanceGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_RemoveInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveInstancesInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).RemoveInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_RemoveInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).RemoveInstances(ctx, req.(*RemoveInstancesInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_SetNamedPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNamedPortsInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).SetNamedPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_SetNamedPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).SetNamedPorts(ctx, req.(*SetNamedPortsInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceGroups_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceGroupsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceGroups_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceGroupsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceGroups_ServiceDesc is the grpc.ServiceDesc for InstanceGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InstanceGroups",
	HandlerType: (*InstanceGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddInstances",
			Handler:    _InstanceGroups_AddInstances_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _InstanceGroups_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceGroups_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstanceGroups_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InstanceGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InstanceGroups_List_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _InstanceGroups_ListInstances_Handler,
		},
		{
			MethodName: "RemoveInstances",
			Handler:    _InstanceGroups_RemoveInstances_Handler,
		},
		{
			MethodName: "SetNamedPorts",
			Handler:    _InstanceGroups_SetNamedPorts_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _InstanceGroups_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InstanceSettingsService_Get_FullMethodName   = "/google.cloud.compute.v1.InstanceSettingsService/Get"
	InstanceSettingsService_Patch_FullMethodName = "/google.cloud.compute.v1.InstanceSettingsService/Patch"
)

// InstanceSettingsServiceClient is the client API for InstanceSettingsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceSettingsServiceClient interface {
	// Get Instance settings.
	Get(ctx context.Context, in *GetInstanceSettingRequest, opts ...grpc.CallOption) (*InstanceSettings, error)
	// Patch Instance settings
	Patch(ctx context.Context, in *PatchInstanceSettingRequest, opts ...grpc.CallOption) (*Operation, error)
}

type instanceSettingsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceSettingsServiceClient(cc grpc.ClientConnInterface) InstanceSettingsServiceClient {
	return &instanceSettingsServiceClient{cc}
}

func (c *instanceSettingsServiceClient) Get(ctx context.Context, in *GetInstanceSettingRequest, opts ...grpc.CallOption) (*InstanceSettings, error) {
	out := new(InstanceSettings)
	err := c.cc.Invoke(ctx, InstanceSettingsService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceSettingsServiceClient) Patch(ctx context.Context, in *PatchInstanceSettingRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceSettingsService_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceSettingsServiceServer is the server API for InstanceSettingsService service.
// All implementations should embed UnimplementedInstanceSettingsServiceServer
// for forward compatibility
type InstanceSettingsServiceServer interface {
	// Get Instance settings.
	Get(context.Context, *GetInstanceSettingRequest) (*InstanceSettings, error)
	// Patch Instance settings
	Patch(context.Context, *PatchInstanceSettingRequest) (*Operation, error)
}

// UnimplementedInstanceSettingsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedInstanceSettingsServiceServer struct {
}

func (UnimplementedInstanceSettingsServiceServer) Get(context.Context, *GetInstanceSettingRequest) (*InstanceSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceSettingsServiceServer) Patch(context.Context, *PatchInstanceSettingRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeInstanceSettingsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceSettingsServiceServer will
// result in compilation errors.
type UnsafeInstanceSettingsServiceServer interface {
	mustEmbedUnimplementedInstanceSettingsServiceServer()
}

func RegisterInstanceSettingsServiceServer(s grpc.ServiceRegistrar, srv InstanceSettingsServiceServer) {
	s.RegisterService(&InstanceSettingsService_ServiceDesc, srv)
}

func _InstanceSettingsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceSettingsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceSettingsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceSettingsServiceServer).Get(ctx, req.(*GetInstanceSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceSettingsService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchInstanceSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceSettingsServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceSettingsService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceSettingsServiceServer).Patch(ctx, req.(*PatchInstanceSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceSettingsService_ServiceDesc is the grpc.ServiceDesc for InstanceSettingsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceSettingsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InstanceSettingsService",
	HandlerType: (*InstanceSettingsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _InstanceSettingsService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _InstanceSettingsService_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InstanceTemplates_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.InstanceTemplates/AggregatedList"
	InstanceTemplates_Delete_FullMethodName             = "/google.cloud.compute.v1.InstanceTemplates/Delete"
	InstanceTemplates_Get_FullMethodName                = "/google.cloud.compute.v1.InstanceTemplates/Get"
	InstanceTemplates_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.InstanceTemplates/GetIamPolicy"
	InstanceTemplates_Insert_FullMethodName             = "/google.cloud.compute.v1.InstanceTemplates/Insert"
	InstanceTemplates_List_FullMethodName               = "/google.cloud.compute.v1.InstanceTemplates/List"
	InstanceTemplates_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.InstanceTemplates/SetIamPolicy"
	InstanceTemplates_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.InstanceTemplates/TestIamPermissions"
)

// InstanceTemplatesClient is the client API for InstanceTemplates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstanceTemplatesClient interface {
	// Retrieves the list of all InstanceTemplates resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListInstanceTemplatesRequest, opts ...grpc.CallOption) (*InstanceTemplateAggregatedList, error)
	// Deletes the specified instance template. Deleting an instance template is
	// permanent and cannot be undone. It is not possible to delete templates
	// that are already in use by a managed instance group.
	Delete(ctx context.Context, in *DeleteInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified instance template.
	Get(ctx context.Context, in *GetInstanceTemplateRequest, opts ...grpc.CallOption) (*InstanceTemplate, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyInstanceTemplateRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates an instance template in the specified project using the
	// data that is included in the request. If you are creating a new template to
	// update an existing instance group, your new instance template must use the
	// same network or, if applicable, the same subnetwork as the original
	// template.
	Insert(ctx context.Context, in *InsertInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of instance templates that are contained within
	// the specified project.
	List(ctx context.Context, in *ListInstanceTemplatesRequest, opts ...grpc.CallOption) (*InstanceTemplateList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyInstanceTemplateRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstanceTemplateRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type instanceTemplatesClient struct {
	cc grpc.ClientConnInterface
}

func NewInstanceTemplatesClient(cc grpc.ClientConnInterface) InstanceTemplatesClient {
	return &instanceTemplatesClient{cc}
}

func (c *instanceTemplatesClient) AggregatedList(ctx context.Context, in *AggregatedListInstanceTemplatesRequest, opts ...grpc.CallOption) (*InstanceTemplateAggregatedList, error) {
	out := new(InstanceTemplateAggregatedList)
	err := c.cc.Invoke(ctx, InstanceTemplates_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) Delete(ctx context.Context, in *DeleteInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceTemplates_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) Get(ctx context.Context, in *GetInstanceTemplateRequest, opts ...grpc.CallOption) (*InstanceTemplate, error) {
	out := new(InstanceTemplate)
	err := c.cc.Invoke(ctx, InstanceTemplates_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyInstanceTemplateRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InstanceTemplates_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) Insert(ctx context.Context, in *InsertInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstanceTemplates_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) List(ctx context.Context, in *ListInstanceTemplatesRequest, opts ...grpc.CallOption) (*InstanceTemplateList, error) {
	out := new(InstanceTemplateList)
	err := c.cc.Invoke(ctx, InstanceTemplates_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyInstanceTemplateRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InstanceTemplates_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instanceTemplatesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstanceTemplateRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, InstanceTemplates_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstanceTemplatesServer is the server API for InstanceTemplates service.
// All implementations should embed UnimplementedInstanceTemplatesServer
// for forward compatibility
type InstanceTemplatesServer interface {
	// Retrieves the list of all InstanceTemplates resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListInstanceTemplatesRequest) (*InstanceTemplateAggregatedList, error)
	// Deletes the specified instance template. Deleting an instance template is
	// permanent and cannot be undone. It is not possible to delete templates
	// that are already in use by a managed instance group.
	Delete(context.Context, *DeleteInstanceTemplateRequest) (*Operation, error)
	// Returns the specified instance template.
	Get(context.Context, *GetInstanceTemplateRequest) (*InstanceTemplate, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyInstanceTemplateRequest) (*Policy, error)
	// Creates an instance template in the specified project using the
	// data that is included in the request. If you are creating a new template to
	// update an existing instance group, your new instance template must use the
	// same network or, if applicable, the same subnetwork as the original
	// template.
	Insert(context.Context, *InsertInstanceTemplateRequest) (*Operation, error)
	// Retrieves a list of instance templates that are contained within
	// the specified project.
	List(context.Context, *ListInstanceTemplatesRequest) (*InstanceTemplateList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyInstanceTemplateRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsInstanceTemplateRequest) (*TestPermissionsResponse, error)
}

// UnimplementedInstanceTemplatesServer should be embedded to have forward compatible implementations.
type UnimplementedInstanceTemplatesServer struct {
}

func (UnimplementedInstanceTemplatesServer) AggregatedList(context.Context, *AggregatedListInstanceTemplatesRequest) (*InstanceTemplateAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedInstanceTemplatesServer) Delete(context.Context, *DeleteInstanceTemplateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstanceTemplatesServer) Get(context.Context, *GetInstanceTemplateRequest) (*InstanceTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstanceTemplatesServer) GetIamPolicy(context.Context, *GetIamPolicyInstanceTemplateRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedInstanceTemplatesServer) Insert(context.Context, *InsertInstanceTemplateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInstanceTemplatesServer) List(context.Context, *ListInstanceTemplatesRequest) (*InstanceTemplateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInstanceTemplatesServer) SetIamPolicy(context.Context, *SetIamPolicyInstanceTemplateRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedInstanceTemplatesServer) TestIamPermissions(context.Context, *TestIamPermissionsInstanceTemplateRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeInstanceTemplatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstanceTemplatesServer will
// result in compilation errors.
type UnsafeInstanceTemplatesServer interface {
	mustEmbedUnimplementedInstanceTemplatesServer()
}

func RegisterInstanceTemplatesServer(s grpc.ServiceRegistrar, srv InstanceTemplatesServer) {
	s.RegisterService(&InstanceTemplates_ServiceDesc, srv)
}

func _InstanceTemplates_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListInstanceTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).AggregatedList(ctx, req.(*AggregatedListInstanceTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).Delete(ctx, req.(*DeleteInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).Get(ctx, req.(*GetInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).GetIamPolicy(ctx, req.(*GetIamPolicyInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).Insert(ctx, req.(*InsertInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstanceTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).List(ctx, req.(*ListInstanceTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).SetIamPolicy(ctx, req.(*SetIamPolicyInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstanceTemplates_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstanceTemplatesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstanceTemplates_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstanceTemplatesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstanceTemplates_ServiceDesc is the grpc.ServiceDesc for InstanceTemplates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstanceTemplates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InstanceTemplates",
	HandlerType: (*InstanceTemplatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _InstanceTemplates_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstanceTemplates_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstanceTemplates_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _InstanceTemplates_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InstanceTemplates_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InstanceTemplates_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _InstanceTemplates_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _InstanceTemplates_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Instances_AddAccessConfig_FullMethodName                    = "/google.cloud.compute.v1.Instances/AddAccessConfig"
	Instances_AddNetworkInterface_FullMethodName                = "/google.cloud.compute.v1.Instances/AddNetworkInterface"
	Instances_AddResourcePolicies_FullMethodName                = "/google.cloud.compute.v1.Instances/AddResourcePolicies"
	Instances_AggregatedList_FullMethodName                     = "/google.cloud.compute.v1.Instances/AggregatedList"
	Instances_AttachDisk_FullMethodName                         = "/google.cloud.compute.v1.Instances/AttachDisk"
	Instances_BulkInsert_FullMethodName                         = "/google.cloud.compute.v1.Instances/BulkInsert"
	Instances_Delete_FullMethodName                             = "/google.cloud.compute.v1.Instances/Delete"
	Instances_DeleteAccessConfig_FullMethodName                 = "/google.cloud.compute.v1.Instances/DeleteAccessConfig"
	Instances_DeleteNetworkInterface_FullMethodName             = "/google.cloud.compute.v1.Instances/DeleteNetworkInterface"
	Instances_DetachDisk_FullMethodName                         = "/google.cloud.compute.v1.Instances/DetachDisk"
	Instances_Get_FullMethodName                                = "/google.cloud.compute.v1.Instances/Get"
	Instances_GetEffectiveFirewalls_FullMethodName              = "/google.cloud.compute.v1.Instances/GetEffectiveFirewalls"
	Instances_GetGuestAttributes_FullMethodName                 = "/google.cloud.compute.v1.Instances/GetGuestAttributes"
	Instances_GetIamPolicy_FullMethodName                       = "/google.cloud.compute.v1.Instances/GetIamPolicy"
	Instances_GetScreenshot_FullMethodName                      = "/google.cloud.compute.v1.Instances/GetScreenshot"
	Instances_GetSerialPortOutput_FullMethodName                = "/google.cloud.compute.v1.Instances/GetSerialPortOutput"
	Instances_GetShieldedInstanceIdentity_FullMethodName        = "/google.cloud.compute.v1.Instances/GetShieldedInstanceIdentity"
	Instances_Insert_FullMethodName                             = "/google.cloud.compute.v1.Instances/Insert"
	Instances_List_FullMethodName                               = "/google.cloud.compute.v1.Instances/List"
	Instances_ListReferrers_FullMethodName                      = "/google.cloud.compute.v1.Instances/ListReferrers"
	Instances_PerformMaintenance_FullMethodName                 = "/google.cloud.compute.v1.Instances/PerformMaintenance"
	Instances_RemoveResourcePolicies_FullMethodName             = "/google.cloud.compute.v1.Instances/RemoveResourcePolicies"
	Instances_ReportHostAsFaulty_FullMethodName                 = "/google.cloud.compute.v1.Instances/ReportHostAsFaulty"
	Instances_Reset_FullMethodName                              = "/google.cloud.compute.v1.Instances/Reset"
	Instances_Resume_FullMethodName                             = "/google.cloud.compute.v1.Instances/Resume"
	Instances_SendDiagnosticInterrupt_FullMethodName            = "/google.cloud.compute.v1.Instances/SendDiagnosticInterrupt"
	Instances_SetDeletionProtection_FullMethodName              = "/google.cloud.compute.v1.Instances/SetDeletionProtection"
	Instances_SetDiskAutoDelete_FullMethodName                  = "/google.cloud.compute.v1.Instances/SetDiskAutoDelete"
	Instances_SetIamPolicy_FullMethodName                       = "/google.cloud.compute.v1.Instances/SetIamPolicy"
	Instances_SetLabels_FullMethodName                          = "/google.cloud.compute.v1.Instances/SetLabels"
	Instances_SetMachineResources_FullMethodName                = "/google.cloud.compute.v1.Instances/SetMachineResources"
	Instances_SetMachineType_FullMethodName                     = "/google.cloud.compute.v1.Instances/SetMachineType"
	Instances_SetMetadata_FullMethodName                        = "/google.cloud.compute.v1.Instances/SetMetadata"
	Instances_SetMinCpuPlatform_FullMethodName                  = "/google.cloud.compute.v1.Instances/SetMinCpuPlatform"
	Instances_SetName_FullMethodName                            = "/google.cloud.compute.v1.Instances/SetName"
	Instances_SetScheduling_FullMethodName                      = "/google.cloud.compute.v1.Instances/SetScheduling"
	Instances_SetSecurityPolicy_FullMethodName                  = "/google.cloud.compute.v1.Instances/SetSecurityPolicy"
	Instances_SetServiceAccount_FullMethodName                  = "/google.cloud.compute.v1.Instances/SetServiceAccount"
	Instances_SetShieldedInstanceIntegrityPolicy_FullMethodName = "/google.cloud.compute.v1.Instances/SetShieldedInstanceIntegrityPolicy"
	Instances_SetTags_FullMethodName                            = "/google.cloud.compute.v1.Instances/SetTags"
	Instances_SimulateMaintenanceEvent_FullMethodName           = "/google.cloud.compute.v1.Instances/SimulateMaintenanceEvent"
	Instances_Start_FullMethodName                              = "/google.cloud.compute.v1.Instances/Start"
	Instances_StartWithEncryptionKey_FullMethodName             = "/google.cloud.compute.v1.Instances/StartWithEncryptionKey"
	Instances_Stop_FullMethodName                               = "/google.cloud.compute.v1.Instances/Stop"
	Instances_Suspend_FullMethodName                            = "/google.cloud.compute.v1.Instances/Suspend"
	Instances_TestIamPermissions_FullMethodName                 = "/google.cloud.compute.v1.Instances/TestIamPermissions"
	Instances_Update_FullMethodName                             = "/google.cloud.compute.v1.Instances/Update"
	Instances_UpdateAccessConfig_FullMethodName                 = "/google.cloud.compute.v1.Instances/UpdateAccessConfig"
	Instances_UpdateDisplayDevice_FullMethodName                = "/google.cloud.compute.v1.Instances/UpdateDisplayDevice"
	Instances_UpdateNetworkInterface_FullMethodName             = "/google.cloud.compute.v1.Instances/UpdateNetworkInterface"
	Instances_UpdateShieldedInstanceConfig_FullMethodName       = "/google.cloud.compute.v1.Instances/UpdateShieldedInstanceConfig"
)

// InstancesClient is the client API for Instances service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstancesClient interface {
	// Adds an access config to an instance's network interface.
	AddAccessConfig(ctx context.Context, in *AddAccessConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Adds one dynamic network interface to an active instance.
	AddNetworkInterface(ctx context.Context, in *AddNetworkInterfaceInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Adds existing resource policies to an instance. You can only add one
	// policy right now which will be applied to this instance for scheduling live
	// migrations.
	AddResourcePolicies(ctx context.Context, in *AddResourcePoliciesInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves an aggregated list of all of the instances in your project
	// across all regions and zones.
	//
	// The performance of this method degrades when a filter is specified on a
	// project that has a very large number of instances.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListInstancesRequest, opts ...grpc.CallOption) (*InstanceAggregatedList, error)
	// Attaches an existing Disk resource to an instance. You must first
	// create the disk before you can attach it. It is not possible to create
	// and attach a disk at the same time. For more information, readAdding a
	// persistent disk to your instance.
	AttachDisk(ctx context.Context, in *AttachDiskInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Creates multiple instances. Count specifies the number of instances to
	// create. For more information, seeAbout bulk
	// creation of VMs.
	BulkInsert(ctx context.Context, in *BulkInsertInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified Instance resource. For more information, seeDeleting
	// an instance.
	Delete(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes an access config from an instance's network interface.
	DeleteAccessConfig(ctx context.Context, in *DeleteAccessConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes one dynamic network interface from an active instance.
	// InstancesDeleteNetworkInterfaceRequest indicates:
	// - instance from which to delete, using project+zone+resource_id fields;
	// - dynamic network interface to be deleted, using network_interface_name
	// field;
	DeleteNetworkInterface(ctx context.Context, in *DeleteNetworkInterfaceInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Detaches a disk from an instance.
	DetachDisk(ctx context.Context, in *DetachDiskInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified Instance resource.
	Get(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*Instance, error)
	// Returns effective firewalls applied to an interface of the instance.
	GetEffectiveFirewalls(ctx context.Context, in *GetEffectiveFirewallsInstanceRequest, opts ...grpc.CallOption) (*InstancesGetEffectiveFirewallsResponse, error)
	// Returns the specified guest attributes entry.
	GetGuestAttributes(ctx context.Context, in *GetGuestAttributesInstanceRequest, opts ...grpc.CallOption) (*GuestAttributes, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyInstanceRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns the screenshot from the specified instance.
	GetScreenshot(ctx context.Context, in *GetScreenshotInstanceRequest, opts ...grpc.CallOption) (*Screenshot, error)
	// Returns the last 1 MB of serial port output from the specified instance.
	GetSerialPortOutput(ctx context.Context, in *GetSerialPortOutputInstanceRequest, opts ...grpc.CallOption) (*SerialPortOutput, error)
	// Returns the Shielded Instance Identity of an instance
	GetShieldedInstanceIdentity(ctx context.Context, in *GetShieldedInstanceIdentityInstanceRequest, opts ...grpc.CallOption) (*ShieldedInstanceIdentity, error)
	// Creates an instance resource in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of instances contained within
	// the specified zone.
	List(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*InstanceList, error)
	// Retrieves a list of resources that refer to the VM instance specified in
	// the request. For example, if the VM instance is part of a managed or
	// unmanaged instance group, the referrers list includes the instance group.
	// For more information, readViewing
	// referrers to VM instances.
	ListReferrers(ctx context.Context, in *ListReferrersInstancesRequest, opts ...grpc.CallOption) (*InstanceListReferrers, error)
	// Perform a manual maintenance on the instance.
	PerformMaintenance(ctx context.Context, in *PerformMaintenanceInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes resource policies from an instance.
	RemoveResourcePolicies(ctx context.Context, in *RemoveResourcePoliciesInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Mark the host as faulty and try to restart the instance on a new host.
	ReportHostAsFaulty(ctx context.Context, in *ReportHostAsFaultyInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Performs a reset on the instance. This is a hard reset. The VM
	// does not do a graceful shutdown. For more information, seeResetting
	// an instance.
	Reset(ctx context.Context, in *ResetInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Resumes an instance that was suspended using theinstances().suspend
	// method.
	Resume(ctx context.Context, in *ResumeInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sends diagnostic interrupt to the instance.
	SendDiagnosticInterrupt(ctx context.Context, in *SendDiagnosticInterruptInstanceRequest, opts ...grpc.CallOption) (*SendDiagnosticInterruptInstanceResponse, error)
	// Sets deletion protection on the instance.
	SetDeletionProtection(ctx context.Context, in *SetDeletionProtectionInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the auto-delete flag for a disk attached to an instance.
	SetDiskAutoDelete(ctx context.Context, in *SetDiskAutoDeleteInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyInstanceRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets labels on an instance.  To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the number and/or type of accelerator for a stopped instance to the
	// values specified in the request.
	SetMachineResources(ctx context.Context, in *SetMachineResourcesInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the machine type for a stopped instance to the machine
	// type specified in the request.
	SetMachineType(ctx context.Context, in *SetMachineTypeInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets metadata for the specified instance to the data included
	// in the request.
	SetMetadata(ctx context.Context, in *SetMetadataInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the minimum CPU platform that this instance should use.
	// This method can only
	// be called on a stopped instance. For more information, readSpecifying a
	// Minimum CPU Platform.
	SetMinCpuPlatform(ctx context.Context, in *SetMinCpuPlatformInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets name of an instance.
	SetName(ctx context.Context, in *SetNameInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets an instance's scheduling options. You can only call this method on astopped instance,
	// that is, a VM instance that is in a `TERMINATED` state. SeeInstance Life
	// Cycle for more information on the possible instance states.
	// For more information about setting scheduling options for a VM, seeSet
	// VM host maintenance policy.
	SetScheduling(ctx context.Context, in *SetSchedulingInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the Google Cloud Armor security policy for the specified instance.
	// For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the service account on the instance. For more information,
	// readChanging
	// the service account and access scopes for an instance.
	SetServiceAccount(ctx context.Context, in *SetServiceAccountInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the Shielded Instance integrity policy for an instance. You can
	// only use this method on a running instance. This method
	// supports PATCH semantics and uses the JSON merge
	// patch format and processing rules.
	SetShieldedInstanceIntegrityPolicy(ctx context.Context, in *SetShieldedInstanceIntegrityPolicyInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets network tags
	// for the specified instance to the data included in the request.
	SetTags(ctx context.Context, in *SetTagsInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Simulates a host maintenance event on a VM. For more information, see
	// Simulate a host maintenance event.
	SimulateMaintenanceEvent(ctx context.Context, in *SimulateMaintenanceEventInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Starts an instance that was stopped using theinstances().stop
	// method. For more information, seeRestart an
	// instance.
	Start(ctx context.Context, in *StartInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Starts an instance that was stopped using theinstances().stop
	// method. For more information, seeRestart an
	// instance.
	StartWithEncryptionKey(ctx context.Context, in *StartWithEncryptionKeyInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Stops a running instance, shutting it down cleanly, and allows
	// you to restart the instance at a later time. Stopped instances do not incur
	// VM usage charges while they are stopped. However, resources that the VM is
	// using, such as persistent disks and static IP addresses, will continue to
	// be charged until they are deleted. For more information, seeStopping
	// an instance.
	Stop(ctx context.Context, in *StopInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// This method suspends a running instance, saving its state to persistent
	// storage, and allows you to resume the instance at a later time. Suspended
	// instances have no compute costs (cores or RAM), and incur only storage
	// charges for the saved VM memory and localSSD data. Any charged resources
	// the virtual machine was using, such as persistent disks and static IP
	// addresses, will continue to be charged while the instance is suspended.
	// For more information, see
	// Suspending and resuming an instance.
	Suspend(ctx context.Context, in *SuspendInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstanceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates an instance only if the necessary resources are available. This
	// method can update only a specific set of instance properties. See
	// Updating a running instance for a list of updatable instance
	// properties.
	Update(ctx context.Context, in *UpdateInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates the specified access config from an instance's network interface
	// with the data included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	UpdateAccessConfig(ctx context.Context, in *UpdateAccessConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates the Display config for a VM instance. You can
	// only use this method on a stopped VM instance. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	UpdateDisplayDevice(ctx context.Context, in *UpdateDisplayDeviceInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates an instance's network interface. This method can only update an
	// interface's alias IP range and attached network. See Modifying
	// alias IP ranges for an existing instance for instructions on
	// changing alias IP ranges. See Migrating
	// a VM between networks for instructions on migrating an interface.
	// This method follows PATCH semantics.
	UpdateNetworkInterface(ctx context.Context, in *UpdateNetworkInterfaceInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates the Shielded Instance config for an instance. You can
	// only use this method on a stopped instance. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	UpdateShieldedInstanceConfig(ctx context.Context, in *UpdateShieldedInstanceConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
}

type instancesClient struct {
	cc grpc.ClientConnInterface
}

func NewInstancesClient(cc grpc.ClientConnInterface) InstancesClient {
	return &instancesClient{cc}
}

func (c *instancesClient) AddAccessConfig(ctx context.Context, in *AddAccessConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_AddAccessConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) AddNetworkInterface(ctx context.Context, in *AddNetworkInterfaceInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_AddNetworkInterface_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) AddResourcePolicies(ctx context.Context, in *AddResourcePoliciesInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_AddResourcePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) AggregatedList(ctx context.Context, in *AggregatedListInstancesRequest, opts ...grpc.CallOption) (*InstanceAggregatedList, error) {
	out := new(InstanceAggregatedList)
	err := c.cc.Invoke(ctx, Instances_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) AttachDisk(ctx context.Context, in *AttachDiskInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_AttachDisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) BulkInsert(ctx context.Context, in *BulkInsertInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_BulkInsert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Delete(ctx context.Context, in *DeleteInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) DeleteAccessConfig(ctx context.Context, in *DeleteAccessConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_DeleteAccessConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) DeleteNetworkInterface(ctx context.Context, in *DeleteNetworkInterfaceInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_DeleteNetworkInterface_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) DetachDisk(ctx context.Context, in *DetachDiskInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_DetachDisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Get(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, Instances_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) GetEffectiveFirewalls(ctx context.Context, in *GetEffectiveFirewallsInstanceRequest, opts ...grpc.CallOption) (*InstancesGetEffectiveFirewallsResponse, error) {
	out := new(InstancesGetEffectiveFirewallsResponse)
	err := c.cc.Invoke(ctx, Instances_GetEffectiveFirewalls_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) GetGuestAttributes(ctx context.Context, in *GetGuestAttributesInstanceRequest, opts ...grpc.CallOption) (*GuestAttributes, error) {
	out := new(GuestAttributes)
	err := c.cc.Invoke(ctx, Instances_GetGuestAttributes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyInstanceRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Instances_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) GetScreenshot(ctx context.Context, in *GetScreenshotInstanceRequest, opts ...grpc.CallOption) (*Screenshot, error) {
	out := new(Screenshot)
	err := c.cc.Invoke(ctx, Instances_GetScreenshot_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) GetSerialPortOutput(ctx context.Context, in *GetSerialPortOutputInstanceRequest, opts ...grpc.CallOption) (*SerialPortOutput, error) {
	out := new(SerialPortOutput)
	err := c.cc.Invoke(ctx, Instances_GetSerialPortOutput_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) GetShieldedInstanceIdentity(ctx context.Context, in *GetShieldedInstanceIdentityInstanceRequest, opts ...grpc.CallOption) (*ShieldedInstanceIdentity, error) {
	out := new(ShieldedInstanceIdentity)
	err := c.cc.Invoke(ctx, Instances_GetShieldedInstanceIdentity_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Insert(ctx context.Context, in *InsertInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) List(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*InstanceList, error) {
	out := new(InstanceList)
	err := c.cc.Invoke(ctx, Instances_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) ListReferrers(ctx context.Context, in *ListReferrersInstancesRequest, opts ...grpc.CallOption) (*InstanceListReferrers, error) {
	out := new(InstanceListReferrers)
	err := c.cc.Invoke(ctx, Instances_ListReferrers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) PerformMaintenance(ctx context.Context, in *PerformMaintenanceInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_PerformMaintenance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) RemoveResourcePolicies(ctx context.Context, in *RemoveResourcePoliciesInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_RemoveResourcePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) ReportHostAsFaulty(ctx context.Context, in *ReportHostAsFaultyInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_ReportHostAsFaulty_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Reset(ctx context.Context, in *ResetInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Reset_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Resume(ctx context.Context, in *ResumeInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Resume_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SendDiagnosticInterrupt(ctx context.Context, in *SendDiagnosticInterruptInstanceRequest, opts ...grpc.CallOption) (*SendDiagnosticInterruptInstanceResponse, error) {
	out := new(SendDiagnosticInterruptInstanceResponse)
	err := c.cc.Invoke(ctx, Instances_SendDiagnosticInterrupt_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetDeletionProtection(ctx context.Context, in *SetDeletionProtectionInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetDeletionProtection_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetDiskAutoDelete(ctx context.Context, in *SetDiskAutoDeleteInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetDiskAutoDelete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyInstanceRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Instances_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetLabels(ctx context.Context, in *SetLabelsInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetMachineResources(ctx context.Context, in *SetMachineResourcesInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetMachineResources_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetMachineType(ctx context.Context, in *SetMachineTypeInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetMachineType_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetMetadata(ctx context.Context, in *SetMetadataInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetMetadata_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetMinCpuPlatform(ctx context.Context, in *SetMinCpuPlatformInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetMinCpuPlatform_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetName(ctx context.Context, in *SetNameInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetName_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetScheduling(ctx context.Context, in *SetSchedulingInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetScheduling_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetServiceAccount(ctx context.Context, in *SetServiceAccountInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetServiceAccount_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetShieldedInstanceIntegrityPolicy(ctx context.Context, in *SetShieldedInstanceIntegrityPolicyInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetShieldedInstanceIntegrityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SetTags(ctx context.Context, in *SetTagsInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SetTags_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) SimulateMaintenanceEvent(ctx context.Context, in *SimulateMaintenanceEventInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_SimulateMaintenanceEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Start(ctx context.Context, in *StartInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Start_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) StartWithEncryptionKey(ctx context.Context, in *StartWithEncryptionKeyInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_StartWithEncryptionKey_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Stop(ctx context.Context, in *StopInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Stop_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Suspend(ctx context.Context, in *SuspendInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Suspend_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstanceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Instances_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) Update(ctx context.Context, in *UpdateInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) UpdateAccessConfig(ctx context.Context, in *UpdateAccessConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_UpdateAccessConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) UpdateDisplayDevice(ctx context.Context, in *UpdateDisplayDeviceInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_UpdateDisplayDevice_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) UpdateNetworkInterface(ctx context.Context, in *UpdateNetworkInterfaceInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_UpdateNetworkInterface_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instancesClient) UpdateShieldedInstanceConfig(ctx context.Context, in *UpdateShieldedInstanceConfigInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Instances_UpdateShieldedInstanceConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstancesServer is the server API for Instances service.
// All implementations should embed UnimplementedInstancesServer
// for forward compatibility
type InstancesServer interface {
	// Adds an access config to an instance's network interface.
	AddAccessConfig(context.Context, *AddAccessConfigInstanceRequest) (*Operation, error)
	// Adds one dynamic network interface to an active instance.
	AddNetworkInterface(context.Context, *AddNetworkInterfaceInstanceRequest) (*Operation, error)
	// Adds existing resource policies to an instance. You can only add one
	// policy right now which will be applied to this instance for scheduling live
	// migrations.
	AddResourcePolicies(context.Context, *AddResourcePoliciesInstanceRequest) (*Operation, error)
	// Retrieves an aggregated list of all of the instances in your project
	// across all regions and zones.
	//
	// The performance of this method degrades when a filter is specified on a
	// project that has a very large number of instances.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListInstancesRequest) (*InstanceAggregatedList, error)
	// Attaches an existing Disk resource to an instance. You must first
	// create the disk before you can attach it. It is not possible to create
	// and attach a disk at the same time. For more information, readAdding a
	// persistent disk to your instance.
	AttachDisk(context.Context, *AttachDiskInstanceRequest) (*Operation, error)
	// Creates multiple instances. Count specifies the number of instances to
	// create. For more information, seeAbout bulk
	// creation of VMs.
	BulkInsert(context.Context, *BulkInsertInstanceRequest) (*Operation, error)
	// Deletes the specified Instance resource. For more information, seeDeleting
	// an instance.
	Delete(context.Context, *DeleteInstanceRequest) (*Operation, error)
	// Deletes an access config from an instance's network interface.
	DeleteAccessConfig(context.Context, *DeleteAccessConfigInstanceRequest) (*Operation, error)
	// Deletes one dynamic network interface from an active instance.
	// InstancesDeleteNetworkInterfaceRequest indicates:
	// - instance from which to delete, using project+zone+resource_id fields;
	// - dynamic network interface to be deleted, using network_interface_name
	// field;
	DeleteNetworkInterface(context.Context, *DeleteNetworkInterfaceInstanceRequest) (*Operation, error)
	// Detaches a disk from an instance.
	DetachDisk(context.Context, *DetachDiskInstanceRequest) (*Operation, error)
	// Returns the specified Instance resource.
	Get(context.Context, *GetInstanceRequest) (*Instance, error)
	// Returns effective firewalls applied to an interface of the instance.
	GetEffectiveFirewalls(context.Context, *GetEffectiveFirewallsInstanceRequest) (*InstancesGetEffectiveFirewallsResponse, error)
	// Returns the specified guest attributes entry.
	GetGuestAttributes(context.Context, *GetGuestAttributesInstanceRequest) (*GuestAttributes, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyInstanceRequest) (*Policy, error)
	// Returns the screenshot from the specified instance.
	GetScreenshot(context.Context, *GetScreenshotInstanceRequest) (*Screenshot, error)
	// Returns the last 1 MB of serial port output from the specified instance.
	GetSerialPortOutput(context.Context, *GetSerialPortOutputInstanceRequest) (*SerialPortOutput, error)
	// Returns the Shielded Instance Identity of an instance
	GetShieldedInstanceIdentity(context.Context, *GetShieldedInstanceIdentityInstanceRequest) (*ShieldedInstanceIdentity, error)
	// Creates an instance resource in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertInstanceRequest) (*Operation, error)
	// Retrieves the list of instances contained within
	// the specified zone.
	List(context.Context, *ListInstancesRequest) (*InstanceList, error)
	// Retrieves a list of resources that refer to the VM instance specified in
	// the request. For example, if the VM instance is part of a managed or
	// unmanaged instance group, the referrers list includes the instance group.
	// For more information, readViewing
	// referrers to VM instances.
	ListReferrers(context.Context, *ListReferrersInstancesRequest) (*InstanceListReferrers, error)
	// Perform a manual maintenance on the instance.
	PerformMaintenance(context.Context, *PerformMaintenanceInstanceRequest) (*Operation, error)
	// Removes resource policies from an instance.
	RemoveResourcePolicies(context.Context, *RemoveResourcePoliciesInstanceRequest) (*Operation, error)
	// Mark the host as faulty and try to restart the instance on a new host.
	ReportHostAsFaulty(context.Context, *ReportHostAsFaultyInstanceRequest) (*Operation, error)
	// Performs a reset on the instance. This is a hard reset. The VM
	// does not do a graceful shutdown. For more information, seeResetting
	// an instance.
	Reset(context.Context, *ResetInstanceRequest) (*Operation, error)
	// Resumes an instance that was suspended using theinstances().suspend
	// method.
	Resume(context.Context, *ResumeInstanceRequest) (*Operation, error)
	// Sends diagnostic interrupt to the instance.
	SendDiagnosticInterrupt(context.Context, *SendDiagnosticInterruptInstanceRequest) (*SendDiagnosticInterruptInstanceResponse, error)
	// Sets deletion protection on the instance.
	SetDeletionProtection(context.Context, *SetDeletionProtectionInstanceRequest) (*Operation, error)
	// Sets the auto-delete flag for a disk attached to an instance.
	SetDiskAutoDelete(context.Context, *SetDiskAutoDeleteInstanceRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyInstanceRequest) (*Policy, error)
	// Sets labels on an instance.  To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsInstanceRequest) (*Operation, error)
	// Changes the number and/or type of accelerator for a stopped instance to the
	// values specified in the request.
	SetMachineResources(context.Context, *SetMachineResourcesInstanceRequest) (*Operation, error)
	// Changes the machine type for a stopped instance to the machine
	// type specified in the request.
	SetMachineType(context.Context, *SetMachineTypeInstanceRequest) (*Operation, error)
	// Sets metadata for the specified instance to the data included
	// in the request.
	SetMetadata(context.Context, *SetMetadataInstanceRequest) (*Operation, error)
	// Changes the minimum CPU platform that this instance should use.
	// This method can only
	// be called on a stopped instance. For more information, readSpecifying a
	// Minimum CPU Platform.
	SetMinCpuPlatform(context.Context, *SetMinCpuPlatformInstanceRequest) (*Operation, error)
	// Sets name of an instance.
	SetName(context.Context, *SetNameInstanceRequest) (*Operation, error)
	// Sets an instance's scheduling options. You can only call this method on astopped instance,
	// that is, a VM instance that is in a `TERMINATED` state. SeeInstance Life
	// Cycle for more information on the possible instance states.
	// For more information about setting scheduling options for a VM, seeSet
	// VM host maintenance policy.
	SetScheduling(context.Context, *SetSchedulingInstanceRequest) (*Operation, error)
	// Sets the Google Cloud Armor security policy for the specified instance.
	// For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(context.Context, *SetSecurityPolicyInstanceRequest) (*Operation, error)
	// Sets the service account on the instance. For more information,
	// readChanging
	// the service account and access scopes for an instance.
	SetServiceAccount(context.Context, *SetServiceAccountInstanceRequest) (*Operation, error)
	// Sets the Shielded Instance integrity policy for an instance. You can
	// only use this method on a running instance. This method
	// supports PATCH semantics and uses the JSON merge
	// patch format and processing rules.
	SetShieldedInstanceIntegrityPolicy(context.Context, *SetShieldedInstanceIntegrityPolicyInstanceRequest) (*Operation, error)
	// Sets network tags
	// for the specified instance to the data included in the request.
	SetTags(context.Context, *SetTagsInstanceRequest) (*Operation, error)
	// Simulates a host maintenance event on a VM. For more information, see
	// Simulate a host maintenance event.
	SimulateMaintenanceEvent(context.Context, *SimulateMaintenanceEventInstanceRequest) (*Operation, error)
	// Starts an instance that was stopped using theinstances().stop
	// method. For more information, seeRestart an
	// instance.
	Start(context.Context, *StartInstanceRequest) (*Operation, error)
	// Starts an instance that was stopped using theinstances().stop
	// method. For more information, seeRestart an
	// instance.
	StartWithEncryptionKey(context.Context, *StartWithEncryptionKeyInstanceRequest) (*Operation, error)
	// Stops a running instance, shutting it down cleanly, and allows
	// you to restart the instance at a later time. Stopped instances do not incur
	// VM usage charges while they are stopped. However, resources that the VM is
	// using, such as persistent disks and static IP addresses, will continue to
	// be charged until they are deleted. For more information, seeStopping
	// an instance.
	Stop(context.Context, *StopInstanceRequest) (*Operation, error)
	// This method suspends a running instance, saving its state to persistent
	// storage, and allows you to resume the instance at a later time. Suspended
	// instances have no compute costs (cores or RAM), and incur only storage
	// charges for the saved VM memory and localSSD data. Any charged resources
	// the virtual machine was using, such as persistent disks and static IP
	// addresses, will continue to be charged while the instance is suspended.
	// For more information, see
	// Suspending and resuming an instance.
	Suspend(context.Context, *SuspendInstanceRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsInstanceRequest) (*TestPermissionsResponse, error)
	// Updates an instance only if the necessary resources are available. This
	// method can update only a specific set of instance properties. See
	// Updating a running instance for a list of updatable instance
	// properties.
	Update(context.Context, *UpdateInstanceRequest) (*Operation, error)
	// Updates the specified access config from an instance's network interface
	// with the data included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	UpdateAccessConfig(context.Context, *UpdateAccessConfigInstanceRequest) (*Operation, error)
	// Updates the Display config for a VM instance. You can
	// only use this method on a stopped VM instance. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	UpdateDisplayDevice(context.Context, *UpdateDisplayDeviceInstanceRequest) (*Operation, error)
	// Updates an instance's network interface. This method can only update an
	// interface's alias IP range and attached network. See Modifying
	// alias IP ranges for an existing instance for instructions on
	// changing alias IP ranges. See Migrating
	// a VM between networks for instructions on migrating an interface.
	// This method follows PATCH semantics.
	UpdateNetworkInterface(context.Context, *UpdateNetworkInterfaceInstanceRequest) (*Operation, error)
	// Updates the Shielded Instance config for an instance. You can
	// only use this method on a stopped instance. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	UpdateShieldedInstanceConfig(context.Context, *UpdateShieldedInstanceConfigInstanceRequest) (*Operation, error)
}

// UnimplementedInstancesServer should be embedded to have forward compatible implementations.
type UnimplementedInstancesServer struct {
}

func (UnimplementedInstancesServer) AddAccessConfig(context.Context, *AddAccessConfigInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAccessConfig not implemented")
}
func (UnimplementedInstancesServer) AddNetworkInterface(context.Context, *AddNetworkInterfaceInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNetworkInterface not implemented")
}
func (UnimplementedInstancesServer) AddResourcePolicies(context.Context, *AddResourcePoliciesInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddResourcePolicies not implemented")
}
func (UnimplementedInstancesServer) AggregatedList(context.Context, *AggregatedListInstancesRequest) (*InstanceAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedInstancesServer) AttachDisk(context.Context, *AttachDiskInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachDisk not implemented")
}
func (UnimplementedInstancesServer) BulkInsert(context.Context, *BulkInsertInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkInsert not implemented")
}
func (UnimplementedInstancesServer) Delete(context.Context, *DeleteInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstancesServer) DeleteAccessConfig(context.Context, *DeleteAccessConfigInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteAccessConfig not implemented")
}
func (UnimplementedInstancesServer) DeleteNetworkInterface(context.Context, *DeleteNetworkInterfaceInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNetworkInterface not implemented")
}
func (UnimplementedInstancesServer) DetachDisk(context.Context, *DetachDiskInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachDisk not implemented")
}
func (UnimplementedInstancesServer) Get(context.Context, *GetInstanceRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstancesServer) GetEffectiveFirewalls(context.Context, *GetEffectiveFirewallsInstanceRequest) (*InstancesGetEffectiveFirewallsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEffectiveFirewalls not implemented")
}
func (UnimplementedInstancesServer) GetGuestAttributes(context.Context, *GetGuestAttributesInstanceRequest) (*GuestAttributes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetGuestAttributes not implemented")
}
func (UnimplementedInstancesServer) GetIamPolicy(context.Context, *GetIamPolicyInstanceRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedInstancesServer) GetScreenshot(context.Context, *GetScreenshotInstanceRequest) (*Screenshot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetScreenshot not implemented")
}
func (UnimplementedInstancesServer) GetSerialPortOutput(context.Context, *GetSerialPortOutputInstanceRequest) (*SerialPortOutput, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSerialPortOutput not implemented")
}
func (UnimplementedInstancesServer) GetShieldedInstanceIdentity(context.Context, *GetShieldedInstanceIdentityInstanceRequest) (*ShieldedInstanceIdentity, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetShieldedInstanceIdentity not implemented")
}
func (UnimplementedInstancesServer) Insert(context.Context, *InsertInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInstancesServer) List(context.Context, *ListInstancesRequest) (*InstanceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInstancesServer) ListReferrers(context.Context, *ListReferrersInstancesRequest) (*InstanceListReferrers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListReferrers not implemented")
}
func (UnimplementedInstancesServer) PerformMaintenance(context.Context, *PerformMaintenanceInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerformMaintenance not implemented")
}
func (UnimplementedInstancesServer) RemoveResourcePolicies(context.Context, *RemoveResourcePoliciesInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveResourcePolicies not implemented")
}
func (UnimplementedInstancesServer) ReportHostAsFaulty(context.Context, *ReportHostAsFaultyInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportHostAsFaulty not implemented")
}
func (UnimplementedInstancesServer) Reset(context.Context, *ResetInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Reset not implemented")
}
func (UnimplementedInstancesServer) Resume(context.Context, *ResumeInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resume not implemented")
}
func (UnimplementedInstancesServer) SendDiagnosticInterrupt(context.Context, *SendDiagnosticInterruptInstanceRequest) (*SendDiagnosticInterruptInstanceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SendDiagnosticInterrupt not implemented")
}
func (UnimplementedInstancesServer) SetDeletionProtection(context.Context, *SetDeletionProtectionInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDeletionProtection not implemented")
}
func (UnimplementedInstancesServer) SetDiskAutoDelete(context.Context, *SetDiskAutoDeleteInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDiskAutoDelete not implemented")
}
func (UnimplementedInstancesServer) SetIamPolicy(context.Context, *SetIamPolicyInstanceRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedInstancesServer) SetLabels(context.Context, *SetLabelsInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedInstancesServer) SetMachineResources(context.Context, *SetMachineResourcesInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMachineResources not implemented")
}
func (UnimplementedInstancesServer) SetMachineType(context.Context, *SetMachineTypeInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMachineType not implemented")
}
func (UnimplementedInstancesServer) SetMetadata(context.Context, *SetMetadataInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMetadata not implemented")
}
func (UnimplementedInstancesServer) SetMinCpuPlatform(context.Context, *SetMinCpuPlatformInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetMinCpuPlatform not implemented")
}
func (UnimplementedInstancesServer) SetName(context.Context, *SetNameInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetName not implemented")
}
func (UnimplementedInstancesServer) SetScheduling(context.Context, *SetSchedulingInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetScheduling not implemented")
}
func (UnimplementedInstancesServer) SetSecurityPolicy(context.Context, *SetSecurityPolicyInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSecurityPolicy not implemented")
}
func (UnimplementedInstancesServer) SetServiceAccount(context.Context, *SetServiceAccountInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetServiceAccount not implemented")
}
func (UnimplementedInstancesServer) SetShieldedInstanceIntegrityPolicy(context.Context, *SetShieldedInstanceIntegrityPolicyInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetShieldedInstanceIntegrityPolicy not implemented")
}
func (UnimplementedInstancesServer) SetTags(context.Context, *SetTagsInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTags not implemented")
}
func (UnimplementedInstancesServer) SimulateMaintenanceEvent(context.Context, *SimulateMaintenanceEventInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateMaintenanceEvent not implemented")
}
func (UnimplementedInstancesServer) Start(context.Context, *StartInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Start not implemented")
}
func (UnimplementedInstancesServer) StartWithEncryptionKey(context.Context, *StartWithEncryptionKeyInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartWithEncryptionKey not implemented")
}
func (UnimplementedInstancesServer) Stop(context.Context, *StopInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Stop not implemented")
}
func (UnimplementedInstancesServer) Suspend(context.Context, *SuspendInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Suspend not implemented")
}
func (UnimplementedInstancesServer) TestIamPermissions(context.Context, *TestIamPermissionsInstanceRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedInstancesServer) Update(context.Context, *UpdateInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedInstancesServer) UpdateAccessConfig(context.Context, *UpdateAccessConfigInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateAccessConfig not implemented")
}
func (UnimplementedInstancesServer) UpdateDisplayDevice(context.Context, *UpdateDisplayDeviceInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDisplayDevice not implemented")
}
func (UnimplementedInstancesServer) UpdateNetworkInterface(context.Context, *UpdateNetworkInterfaceInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateNetworkInterface not implemented")
}
func (UnimplementedInstancesServer) UpdateShieldedInstanceConfig(context.Context, *UpdateShieldedInstanceConfigInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateShieldedInstanceConfig not implemented")
}

// UnsafeInstancesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstancesServer will
// result in compilation errors.
type UnsafeInstancesServer interface {
	mustEmbedUnimplementedInstancesServer()
}

func RegisterInstancesServer(s grpc.ServiceRegistrar, srv InstancesServer) {
	s.RegisterService(&Instances_ServiceDesc, srv)
}

func _Instances_AddAccessConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAccessConfigInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).AddAccessConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_AddAccessConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).AddAccessConfig(ctx, req.(*AddAccessConfigInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_AddNetworkInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNetworkInterfaceInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).AddNetworkInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_AddNetworkInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).AddNetworkInterface(ctx, req.(*AddNetworkInterfaceInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_AddResourcePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddResourcePoliciesInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).AddResourcePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_AddResourcePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).AddResourcePolicies(ctx, req.(*AddResourcePoliciesInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).AggregatedList(ctx, req.(*AggregatedListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_AttachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachDiskInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).AttachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_AttachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).AttachDisk(ctx, req.(*AttachDiskInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_BulkInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkInsertInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).BulkInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_BulkInsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).BulkInsert(ctx, req.(*BulkInsertInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Delete(ctx, req.(*DeleteInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_DeleteAccessConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteAccessConfigInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).DeleteAccessConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_DeleteAccessConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).DeleteAccessConfig(ctx, req.(*DeleteAccessConfigInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_DeleteNetworkInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkInterfaceInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).DeleteNetworkInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_DeleteNetworkInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).DeleteNetworkInterface(ctx, req.(*DeleteNetworkInterfaceInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_DetachDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachDiskInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).DetachDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_DetachDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).DetachDisk(ctx, req.(*DetachDiskInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Get(ctx, req.(*GetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_GetEffectiveFirewalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEffectiveFirewallsInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).GetEffectiveFirewalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_GetEffectiveFirewalls_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).GetEffectiveFirewalls(ctx, req.(*GetEffectiveFirewallsInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_GetGuestAttributes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetGuestAttributesInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).GetGuestAttributes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_GetGuestAttributes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).GetGuestAttributes(ctx, req.(*GetGuestAttributesInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).GetIamPolicy(ctx, req.(*GetIamPolicyInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_GetScreenshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetScreenshotInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).GetScreenshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_GetScreenshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).GetScreenshot(ctx, req.(*GetScreenshotInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_GetSerialPortOutput_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSerialPortOutputInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).GetSerialPortOutput(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_GetSerialPortOutput_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).GetSerialPortOutput(ctx, req.(*GetSerialPortOutputInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_GetShieldedInstanceIdentity_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetShieldedInstanceIdentityInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).GetShieldedInstanceIdentity(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_GetShieldedInstanceIdentity_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).GetShieldedInstanceIdentity(ctx, req.(*GetShieldedInstanceIdentityInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Insert(ctx, req.(*InsertInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).List(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_ListReferrers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReferrersInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).ListReferrers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_ListReferrers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).ListReferrers(ctx, req.(*ListReferrersInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_PerformMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PerformMaintenanceInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).PerformMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_PerformMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).PerformMaintenance(ctx, req.(*PerformMaintenanceInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_RemoveResourcePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveResourcePoliciesInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).RemoveResourcePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_RemoveResourcePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).RemoveResourcePolicies(ctx, req.(*RemoveResourcePoliciesInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_ReportHostAsFaulty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportHostAsFaultyInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).ReportHostAsFaulty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_ReportHostAsFaulty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).ReportHostAsFaulty(ctx, req.(*ReportHostAsFaultyInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Reset_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Reset(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Reset_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Reset(ctx, req.(*ResetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Resume_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Resume(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Resume_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Resume(ctx, req.(*ResumeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SendDiagnosticInterrupt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendDiagnosticInterruptInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SendDiagnosticInterrupt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SendDiagnosticInterrupt_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SendDiagnosticInterrupt(ctx, req.(*SendDiagnosticInterruptInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetDeletionProtection_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDeletionProtectionInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetDeletionProtection(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetDeletionProtection_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetDeletionProtection(ctx, req.(*SetDeletionProtectionInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetDiskAutoDelete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDiskAutoDeleteInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetDiskAutoDelete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetDiskAutoDelete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetDiskAutoDelete(ctx, req.(*SetDiskAutoDeleteInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetIamPolicy(ctx, req.(*SetIamPolicyInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetLabels(ctx, req.(*SetLabelsInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetMachineResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMachineResourcesInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetMachineResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetMachineResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetMachineResources(ctx, req.(*SetMachineResourcesInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetMachineType_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMachineTypeInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetMachineType(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetMachineType_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetMachineType(ctx, req.(*SetMachineTypeInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMetadataInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetMetadata(ctx, req.(*SetMetadataInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetMinCpuPlatform_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetMinCpuPlatformInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetMinCpuPlatform(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetMinCpuPlatform_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetMinCpuPlatform(ctx, req.(*SetMinCpuPlatformInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetName_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNameInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetName(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetName_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetName(ctx, req.(*SetNameInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetScheduling_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSchedulingInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetScheduling(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetScheduling_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetScheduling(ctx, req.(*SetSchedulingInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSecurityPolicyInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetSecurityPolicy(ctx, req.(*SetSecurityPolicyInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetServiceAccount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetServiceAccountInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetServiceAccount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetServiceAccount_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetServiceAccount(ctx, req.(*SetServiceAccountInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetShieldedInstanceIntegrityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetShieldedInstanceIntegrityPolicyInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetShieldedInstanceIntegrityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetShieldedInstanceIntegrityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetShieldedInstanceIntegrityPolicy(ctx, req.(*SetShieldedInstanceIntegrityPolicyInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SetTags_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTagsInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SetTags(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SetTags_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SetTags(ctx, req.(*SetTagsInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_SimulateMaintenanceEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateMaintenanceEventInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).SimulateMaintenanceEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_SimulateMaintenanceEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).SimulateMaintenanceEvent(ctx, req.(*SimulateMaintenanceEventInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Start_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Start(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Start_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Start(ctx, req.(*StartInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_StartWithEncryptionKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartWithEncryptionKeyInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).StartWithEncryptionKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_StartWithEncryptionKey_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).StartWithEncryptionKey(ctx, req.(*StartWithEncryptionKeyInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Stop_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Stop(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Stop_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Stop(ctx, req.(*StopInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Suspend_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Suspend(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Suspend_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Suspend(ctx, req.(*SuspendInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).Update(ctx, req.(*UpdateInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_UpdateAccessConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateAccessConfigInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).UpdateAccessConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_UpdateAccessConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).UpdateAccessConfig(ctx, req.(*UpdateAccessConfigInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_UpdateDisplayDevice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDisplayDeviceInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).UpdateDisplayDevice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_UpdateDisplayDevice_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).UpdateDisplayDevice(ctx, req.(*UpdateDisplayDeviceInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_UpdateNetworkInterface_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateNetworkInterfaceInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).UpdateNetworkInterface(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_UpdateNetworkInterface_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).UpdateNetworkInterface(ctx, req.(*UpdateNetworkInterfaceInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Instances_UpdateShieldedInstanceConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateShieldedInstanceConfigInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstancesServer).UpdateShieldedInstanceConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Instances_UpdateShieldedInstanceConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstancesServer).UpdateShieldedInstanceConfig(ctx, req.(*UpdateShieldedInstanceConfigInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Instances_ServiceDesc is the grpc.ServiceDesc for Instances service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Instances_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Instances",
	HandlerType: (*InstancesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddAccessConfig",
			Handler:    _Instances_AddAccessConfig_Handler,
		},
		{
			MethodName: "AddNetworkInterface",
			Handler:    _Instances_AddNetworkInterface_Handler,
		},
		{
			MethodName: "AddResourcePolicies",
			Handler:    _Instances_AddResourcePolicies_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _Instances_AggregatedList_Handler,
		},
		{
			MethodName: "AttachDisk",
			Handler:    _Instances_AttachDisk_Handler,
		},
		{
			MethodName: "BulkInsert",
			Handler:    _Instances_BulkInsert_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Instances_Delete_Handler,
		},
		{
			MethodName: "DeleteAccessConfig",
			Handler:    _Instances_DeleteAccessConfig_Handler,
		},
		{
			MethodName: "DeleteNetworkInterface",
			Handler:    _Instances_DeleteNetworkInterface_Handler,
		},
		{
			MethodName: "DetachDisk",
			Handler:    _Instances_DetachDisk_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Instances_Get_Handler,
		},
		{
			MethodName: "GetEffectiveFirewalls",
			Handler:    _Instances_GetEffectiveFirewalls_Handler,
		},
		{
			MethodName: "GetGuestAttributes",
			Handler:    _Instances_GetGuestAttributes_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Instances_GetIamPolicy_Handler,
		},
		{
			MethodName: "GetScreenshot",
			Handler:    _Instances_GetScreenshot_Handler,
		},
		{
			MethodName: "GetSerialPortOutput",
			Handler:    _Instances_GetSerialPortOutput_Handler,
		},
		{
			MethodName: "GetShieldedInstanceIdentity",
			Handler:    _Instances_GetShieldedInstanceIdentity_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Instances_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Instances_List_Handler,
		},
		{
			MethodName: "ListReferrers",
			Handler:    _Instances_ListReferrers_Handler,
		},
		{
			MethodName: "PerformMaintenance",
			Handler:    _Instances_PerformMaintenance_Handler,
		},
		{
			MethodName: "RemoveResourcePolicies",
			Handler:    _Instances_RemoveResourcePolicies_Handler,
		},
		{
			MethodName: "ReportHostAsFaulty",
			Handler:    _Instances_ReportHostAsFaulty_Handler,
		},
		{
			MethodName: "Reset",
			Handler:    _Instances_Reset_Handler,
		},
		{
			MethodName: "Resume",
			Handler:    _Instances_Resume_Handler,
		},
		{
			MethodName: "SendDiagnosticInterrupt",
			Handler:    _Instances_SendDiagnosticInterrupt_Handler,
		},
		{
			MethodName: "SetDeletionProtection",
			Handler:    _Instances_SetDeletionProtection_Handler,
		},
		{
			MethodName: "SetDiskAutoDelete",
			Handler:    _Instances_SetDiskAutoDelete_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Instances_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _Instances_SetLabels_Handler,
		},
		{
			MethodName: "SetMachineResources",
			Handler:    _Instances_SetMachineResources_Handler,
		},
		{
			MethodName: "SetMachineType",
			Handler:    _Instances_SetMachineType_Handler,
		},
		{
			MethodName: "SetMetadata",
			Handler:    _Instances_SetMetadata_Handler,
		},
		{
			MethodName: "SetMinCpuPlatform",
			Handler:    _Instances_SetMinCpuPlatform_Handler,
		},
		{
			MethodName: "SetName",
			Handler:    _Instances_SetName_Handler,
		},
		{
			MethodName: "SetScheduling",
			Handler:    _Instances_SetScheduling_Handler,
		},
		{
			MethodName: "SetSecurityPolicy",
			Handler:    _Instances_SetSecurityPolicy_Handler,
		},
		{
			MethodName: "SetServiceAccount",
			Handler:    _Instances_SetServiceAccount_Handler,
		},
		{
			MethodName: "SetShieldedInstanceIntegrityPolicy",
			Handler:    _Instances_SetShieldedInstanceIntegrityPolicy_Handler,
		},
		{
			MethodName: "SetTags",
			Handler:    _Instances_SetTags_Handler,
		},
		{
			MethodName: "SimulateMaintenanceEvent",
			Handler:    _Instances_SimulateMaintenanceEvent_Handler,
		},
		{
			MethodName: "Start",
			Handler:    _Instances_Start_Handler,
		},
		{
			MethodName: "StartWithEncryptionKey",
			Handler:    _Instances_StartWithEncryptionKey_Handler,
		},
		{
			MethodName: "Stop",
			Handler:    _Instances_Stop_Handler,
		},
		{
			MethodName: "Suspend",
			Handler:    _Instances_Suspend_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Instances_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Instances_Update_Handler,
		},
		{
			MethodName: "UpdateAccessConfig",
			Handler:    _Instances_UpdateAccessConfig_Handler,
		},
		{
			MethodName: "UpdateDisplayDevice",
			Handler:    _Instances_UpdateDisplayDevice_Handler,
		},
		{
			MethodName: "UpdateNetworkInterface",
			Handler:    _Instances_UpdateNetworkInterface_Handler,
		},
		{
			MethodName: "UpdateShieldedInstanceConfig",
			Handler:    _Instances_UpdateShieldedInstanceConfig_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InstantSnapshots_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.InstantSnapshots/AggregatedList"
	InstantSnapshots_Delete_FullMethodName             = "/google.cloud.compute.v1.InstantSnapshots/Delete"
	InstantSnapshots_Get_FullMethodName                = "/google.cloud.compute.v1.InstantSnapshots/Get"
	InstantSnapshots_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.InstantSnapshots/GetIamPolicy"
	InstantSnapshots_Insert_FullMethodName             = "/google.cloud.compute.v1.InstantSnapshots/Insert"
	InstantSnapshots_List_FullMethodName               = "/google.cloud.compute.v1.InstantSnapshots/List"
	InstantSnapshots_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.InstantSnapshots/SetIamPolicy"
	InstantSnapshots_SetLabels_FullMethodName          = "/google.cloud.compute.v1.InstantSnapshots/SetLabels"
	InstantSnapshots_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.InstantSnapshots/TestIamPermissions"
)

// InstantSnapshotsClient is the client API for InstantSnapshots service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InstantSnapshotsClient interface {
	// Retrieves an aggregated list of instantSnapshots.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListInstantSnapshotsRequest, opts ...grpc.CallOption) (*InstantSnapshotAggregatedList, error)
	// Deletes the specified InstantSnapshot resource. Keep in mind that deleting
	// a single instantSnapshot might not necessarily delete all the data on that
	// instantSnapshot. If any data on the instantSnapshot that is marked for
	// deletion is needed for subsequent instantSnapshots, the data will be moved
	// to the next corresponding instantSnapshot.
	//
	// For more information, seeDeleting
	// instantSnapshots.
	Delete(ctx context.Context, in *DeleteInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified InstantSnapshot resource in the specified zone.
	Get(ctx context.Context, in *GetInstantSnapshotRequest, opts ...grpc.CallOption) (*InstantSnapshot, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates an instant snapshot in the specified zone.
	Insert(ctx context.Context, in *InsertInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of InstantSnapshot resources contained within
	// the specified zone.
	List(ctx context.Context, in *ListInstantSnapshotsRequest, opts ...grpc.CallOption) (*InstantSnapshotList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on a instantSnapshot in the given zone. To learn more about
	// labels, read the Labeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstantSnapshotRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type instantSnapshotsClient struct {
	cc grpc.ClientConnInterface
}

func NewInstantSnapshotsClient(cc grpc.ClientConnInterface) InstantSnapshotsClient {
	return &instantSnapshotsClient{cc}
}

func (c *instantSnapshotsClient) AggregatedList(ctx context.Context, in *AggregatedListInstantSnapshotsRequest, opts ...grpc.CallOption) (*InstantSnapshotAggregatedList, error) {
	out := new(InstantSnapshotAggregatedList)
	err := c.cc.Invoke(ctx, InstantSnapshots_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) Delete(ctx context.Context, in *DeleteInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstantSnapshots_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) Get(ctx context.Context, in *GetInstantSnapshotRequest, opts ...grpc.CallOption) (*InstantSnapshot, error) {
	out := new(InstantSnapshot)
	err := c.cc.Invoke(ctx, InstantSnapshots_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InstantSnapshots_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) Insert(ctx context.Context, in *InsertInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstantSnapshots_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) List(ctx context.Context, in *ListInstantSnapshotsRequest, opts ...grpc.CallOption) (*InstantSnapshotList, error) {
	out := new(InstantSnapshotList)
	err := c.cc.Invoke(ctx, InstantSnapshots_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InstantSnapshots_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) SetLabels(ctx context.Context, in *SetLabelsInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InstantSnapshots_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *instantSnapshotsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsInstantSnapshotRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, InstantSnapshots_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstantSnapshotsServer is the server API for InstantSnapshots service.
// All implementations should embed UnimplementedInstantSnapshotsServer
// for forward compatibility
type InstantSnapshotsServer interface {
	// Retrieves an aggregated list of instantSnapshots.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListInstantSnapshotsRequest) (*InstantSnapshotAggregatedList, error)
	// Deletes the specified InstantSnapshot resource. Keep in mind that deleting
	// a single instantSnapshot might not necessarily delete all the data on that
	// instantSnapshot. If any data on the instantSnapshot that is marked for
	// deletion is needed for subsequent instantSnapshots, the data will be moved
	// to the next corresponding instantSnapshot.
	//
	// For more information, seeDeleting
	// instantSnapshots.
	Delete(context.Context, *DeleteInstantSnapshotRequest) (*Operation, error)
	// Returns the specified InstantSnapshot resource in the specified zone.
	Get(context.Context, *GetInstantSnapshotRequest) (*InstantSnapshot, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyInstantSnapshotRequest) (*Policy, error)
	// Creates an instant snapshot in the specified zone.
	Insert(context.Context, *InsertInstantSnapshotRequest) (*Operation, error)
	// Retrieves the list of InstantSnapshot resources contained within
	// the specified zone.
	List(context.Context, *ListInstantSnapshotsRequest) (*InstantSnapshotList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyInstantSnapshotRequest) (*Policy, error)
	// Sets the labels on a instantSnapshot in the given zone. To learn more about
	// labels, read the Labeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsInstantSnapshotRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsInstantSnapshotRequest) (*TestPermissionsResponse, error)
}

// UnimplementedInstantSnapshotsServer should be embedded to have forward compatible implementations.
type UnimplementedInstantSnapshotsServer struct {
}

func (UnimplementedInstantSnapshotsServer) AggregatedList(context.Context, *AggregatedListInstantSnapshotsRequest) (*InstantSnapshotAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedInstantSnapshotsServer) Delete(context.Context, *DeleteInstantSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInstantSnapshotsServer) Get(context.Context, *GetInstantSnapshotRequest) (*InstantSnapshot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInstantSnapshotsServer) GetIamPolicy(context.Context, *GetIamPolicyInstantSnapshotRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedInstantSnapshotsServer) Insert(context.Context, *InsertInstantSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInstantSnapshotsServer) List(context.Context, *ListInstantSnapshotsRequest) (*InstantSnapshotList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInstantSnapshotsServer) SetIamPolicy(context.Context, *SetIamPolicyInstantSnapshotRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedInstantSnapshotsServer) SetLabels(context.Context, *SetLabelsInstantSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedInstantSnapshotsServer) TestIamPermissions(context.Context, *TestIamPermissionsInstantSnapshotRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeInstantSnapshotsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InstantSnapshotsServer will
// result in compilation errors.
type UnsafeInstantSnapshotsServer interface {
	mustEmbedUnimplementedInstantSnapshotsServer()
}

func RegisterInstantSnapshotsServer(s grpc.ServiceRegistrar, srv InstantSnapshotsServer) {
	s.RegisterService(&InstantSnapshots_ServiceDesc, srv)
}

func _InstantSnapshots_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListInstantSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).AggregatedList(ctx, req.(*AggregatedListInstantSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).Delete(ctx, req.(*DeleteInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).Get(ctx, req.(*GetInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).GetIamPolicy(ctx, req.(*GetIamPolicyInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).Insert(ctx, req.(*InsertInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstantSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).List(ctx, req.(*ListInstantSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).SetIamPolicy(ctx, req.(*SetIamPolicyInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).SetLabels(ctx, req.(*SetLabelsInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InstantSnapshots_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstantSnapshotsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InstantSnapshots_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstantSnapshotsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InstantSnapshots_ServiceDesc is the grpc.ServiceDesc for InstantSnapshots service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InstantSnapshots_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InstantSnapshots",
	HandlerType: (*InstantSnapshotsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _InstantSnapshots_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InstantSnapshots_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InstantSnapshots_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _InstantSnapshots_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InstantSnapshots_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InstantSnapshots_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _InstantSnapshots_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _InstantSnapshots_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _InstantSnapshots_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InterconnectAttachmentGroups_Delete_FullMethodName               = "/google.cloud.compute.v1.InterconnectAttachmentGroups/Delete"
	InterconnectAttachmentGroups_Get_FullMethodName                  = "/google.cloud.compute.v1.InterconnectAttachmentGroups/Get"
	InterconnectAttachmentGroups_GetIamPolicy_FullMethodName         = "/google.cloud.compute.v1.InterconnectAttachmentGroups/GetIamPolicy"
	InterconnectAttachmentGroups_GetOperationalStatus_FullMethodName = "/google.cloud.compute.v1.InterconnectAttachmentGroups/GetOperationalStatus"
	InterconnectAttachmentGroups_Insert_FullMethodName               = "/google.cloud.compute.v1.InterconnectAttachmentGroups/Insert"
	InterconnectAttachmentGroups_List_FullMethodName                 = "/google.cloud.compute.v1.InterconnectAttachmentGroups/List"
	InterconnectAttachmentGroups_Patch_FullMethodName                = "/google.cloud.compute.v1.InterconnectAttachmentGroups/Patch"
	InterconnectAttachmentGroups_SetIamPolicy_FullMethodName         = "/google.cloud.compute.v1.InterconnectAttachmentGroups/SetIamPolicy"
	InterconnectAttachmentGroups_TestIamPermissions_FullMethodName   = "/google.cloud.compute.v1.InterconnectAttachmentGroups/TestIamPermissions"
)

// InterconnectAttachmentGroupsClient is the client API for InterconnectAttachmentGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterconnectAttachmentGroupsClient interface {
	// Deletes the specified InterconnectAttachmentGroup in the given scope
	Delete(ctx context.Context, in *DeleteInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified InterconnectAttachmentGroup resource in the given
	// scope.
	Get(ctx context.Context, in *GetInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*InterconnectAttachmentGroup, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns the InterconnectAttachmentStatuses for the specified
	// InterconnectAttachmentGroup resource.
	GetOperationalStatus(ctx context.Context, in *GetOperationalStatusInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*InterconnectAttachmentGroupsGetOperationalStatusResponse, error)
	// Creates a InterconnectAttachmentGroup in the specified project in the given
	// scope using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the InterconnectAttachmentGroups for a project in the given scope.
	List(ctx context.Context, in *ListInterconnectAttachmentGroupsRequest, opts ...grpc.CallOption) (*InterconnectAttachmentGroupsListResponse, error)
	// Patches the specified InterconnectAttachmentGroup resource with the data
	// included in the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type interconnectAttachmentGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewInterconnectAttachmentGroupsClient(cc grpc.ClientConnInterface) InterconnectAttachmentGroupsClient {
	return &interconnectAttachmentGroupsClient{cc}
}

func (c *interconnectAttachmentGroupsClient) Delete(ctx context.Context, in *DeleteInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) Get(ctx context.Context, in *GetInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*InterconnectAttachmentGroup, error) {
	out := new(InterconnectAttachmentGroup)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) GetOperationalStatus(ctx context.Context, in *GetOperationalStatusInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*InterconnectAttachmentGroupsGetOperationalStatusResponse, error) {
	out := new(InterconnectAttachmentGroupsGetOperationalStatusResponse)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_GetOperationalStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) Insert(ctx context.Context, in *InsertInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) List(ctx context.Context, in *ListInterconnectAttachmentGroupsRequest, opts ...grpc.CallOption) (*InterconnectAttachmentGroupsListResponse, error) {
	out := new(InterconnectAttachmentGroupsListResponse)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) Patch(ctx context.Context, in *PatchInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentGroupsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsInterconnectAttachmentGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, InterconnectAttachmentGroups_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterconnectAttachmentGroupsServer is the server API for InterconnectAttachmentGroups service.
// All implementations should embed UnimplementedInterconnectAttachmentGroupsServer
// for forward compatibility
type InterconnectAttachmentGroupsServer interface {
	// Deletes the specified InterconnectAttachmentGroup in the given scope
	Delete(context.Context, *DeleteInterconnectAttachmentGroupRequest) (*Operation, error)
	// Returns the specified InterconnectAttachmentGroup resource in the given
	// scope.
	Get(context.Context, *GetInterconnectAttachmentGroupRequest) (*InterconnectAttachmentGroup, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyInterconnectAttachmentGroupRequest) (*Policy, error)
	// Returns the InterconnectAttachmentStatuses for the specified
	// InterconnectAttachmentGroup resource.
	GetOperationalStatus(context.Context, *GetOperationalStatusInterconnectAttachmentGroupRequest) (*InterconnectAttachmentGroupsGetOperationalStatusResponse, error)
	// Creates a InterconnectAttachmentGroup in the specified project in the given
	// scope using the parameters that are included in the request.
	Insert(context.Context, *InsertInterconnectAttachmentGroupRequest) (*Operation, error)
	// Lists the InterconnectAttachmentGroups for a project in the given scope.
	List(context.Context, *ListInterconnectAttachmentGroupsRequest) (*InterconnectAttachmentGroupsListResponse, error)
	// Patches the specified InterconnectAttachmentGroup resource with the data
	// included in the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchInterconnectAttachmentGroupRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyInterconnectAttachmentGroupRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsInterconnectAttachmentGroupRequest) (*TestPermissionsResponse, error)
}

// UnimplementedInterconnectAttachmentGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedInterconnectAttachmentGroupsServer struct {
}

func (UnimplementedInterconnectAttachmentGroupsServer) Delete(context.Context, *DeleteInterconnectAttachmentGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) Get(context.Context, *GetInterconnectAttachmentGroupRequest) (*InterconnectAttachmentGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) GetIamPolicy(context.Context, *GetIamPolicyInterconnectAttachmentGroupRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) GetOperationalStatus(context.Context, *GetOperationalStatusInterconnectAttachmentGroupRequest) (*InterconnectAttachmentGroupsGetOperationalStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOperationalStatus not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) Insert(context.Context, *InsertInterconnectAttachmentGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) List(context.Context, *ListInterconnectAttachmentGroupsRequest) (*InterconnectAttachmentGroupsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) Patch(context.Context, *PatchInterconnectAttachmentGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) SetIamPolicy(context.Context, *SetIamPolicyInterconnectAttachmentGroupRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedInterconnectAttachmentGroupsServer) TestIamPermissions(context.Context, *TestIamPermissionsInterconnectAttachmentGroupRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeInterconnectAttachmentGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterconnectAttachmentGroupsServer will
// result in compilation errors.
type UnsafeInterconnectAttachmentGroupsServer interface {
	mustEmbedUnimplementedInterconnectAttachmentGroupsServer()
}

func RegisterInterconnectAttachmentGroupsServer(s grpc.ServiceRegistrar, srv InterconnectAttachmentGroupsServer) {
	s.RegisterService(&InterconnectAttachmentGroups_ServiceDesc, srv)
}

func _InterconnectAttachmentGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).Delete(ctx, req.(*DeleteInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).Get(ctx, req.(*GetInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).GetIamPolicy(ctx, req.(*GetIamPolicyInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_GetOperationalStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationalStatusInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).GetOperationalStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_GetOperationalStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).GetOperationalStatus(ctx, req.(*GetOperationalStatusInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).Insert(ctx, req.(*InsertInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterconnectAttachmentGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).List(ctx, req.(*ListInterconnectAttachmentGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).Patch(ctx, req.(*PatchInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).SetIamPolicy(ctx, req.(*SetIamPolicyInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachmentGroups_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsInterconnectAttachmentGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentGroupsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachmentGroups_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentGroupsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsInterconnectAttachmentGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InterconnectAttachmentGroups_ServiceDesc is the grpc.ServiceDesc for InterconnectAttachmentGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InterconnectAttachmentGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InterconnectAttachmentGroups",
	HandlerType: (*InterconnectAttachmentGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _InterconnectAttachmentGroups_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InterconnectAttachmentGroups_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _InterconnectAttachmentGroups_GetIamPolicy_Handler,
		},
		{
			MethodName: "GetOperationalStatus",
			Handler:    _InterconnectAttachmentGroups_GetOperationalStatus_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InterconnectAttachmentGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InterconnectAttachmentGroups_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _InterconnectAttachmentGroups_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _InterconnectAttachmentGroups_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _InterconnectAttachmentGroups_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InterconnectAttachments_AggregatedList_FullMethodName = "/google.cloud.compute.v1.InterconnectAttachments/AggregatedList"
	InterconnectAttachments_Delete_FullMethodName         = "/google.cloud.compute.v1.InterconnectAttachments/Delete"
	InterconnectAttachments_Get_FullMethodName            = "/google.cloud.compute.v1.InterconnectAttachments/Get"
	InterconnectAttachments_Insert_FullMethodName         = "/google.cloud.compute.v1.InterconnectAttachments/Insert"
	InterconnectAttachments_List_FullMethodName           = "/google.cloud.compute.v1.InterconnectAttachments/List"
	InterconnectAttachments_Patch_FullMethodName          = "/google.cloud.compute.v1.InterconnectAttachments/Patch"
	InterconnectAttachments_SetLabels_FullMethodName      = "/google.cloud.compute.v1.InterconnectAttachments/SetLabels"
)

// InterconnectAttachmentsClient is the client API for InterconnectAttachments service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterconnectAttachmentsClient interface {
	// Retrieves an aggregated list of interconnect attachments.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListInterconnectAttachmentsRequest, opts ...grpc.CallOption) (*InterconnectAttachmentAggregatedList, error)
	// Deletes the specified interconnect attachment.
	Delete(ctx context.Context, in *DeleteInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified interconnect attachment.
	Get(ctx context.Context, in *GetInterconnectAttachmentRequest, opts ...grpc.CallOption) (*InterconnectAttachment, error)
	// Creates an InterconnectAttachment in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of interconnect attachments contained within
	// the specified region.
	List(ctx context.Context, in *ListInterconnectAttachmentsRequest, opts ...grpc.CallOption) (*InterconnectAttachmentList, error)
	// Updates the specified interconnect attachment with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on an InterconnectAttachment. To learn more about labels,
	// read the Labeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
}

type interconnectAttachmentsClient struct {
	cc grpc.ClientConnInterface
}

func NewInterconnectAttachmentsClient(cc grpc.ClientConnInterface) InterconnectAttachmentsClient {
	return &interconnectAttachmentsClient{cc}
}

func (c *interconnectAttachmentsClient) AggregatedList(ctx context.Context, in *AggregatedListInterconnectAttachmentsRequest, opts ...grpc.CallOption) (*InterconnectAttachmentAggregatedList, error) {
	out := new(InterconnectAttachmentAggregatedList)
	err := c.cc.Invoke(ctx, InterconnectAttachments_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentsClient) Delete(ctx context.Context, in *DeleteInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachments_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentsClient) Get(ctx context.Context, in *GetInterconnectAttachmentRequest, opts ...grpc.CallOption) (*InterconnectAttachment, error) {
	out := new(InterconnectAttachment)
	err := c.cc.Invoke(ctx, InterconnectAttachments_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentsClient) Insert(ctx context.Context, in *InsertInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachments_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentsClient) List(ctx context.Context, in *ListInterconnectAttachmentsRequest, opts ...grpc.CallOption) (*InterconnectAttachmentList, error) {
	out := new(InterconnectAttachmentList)
	err := c.cc.Invoke(ctx, InterconnectAttachments_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentsClient) Patch(ctx context.Context, in *PatchInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachments_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectAttachmentsClient) SetLabels(ctx context.Context, in *SetLabelsInterconnectAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectAttachments_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterconnectAttachmentsServer is the server API for InterconnectAttachments service.
// All implementations should embed UnimplementedInterconnectAttachmentsServer
// for forward compatibility
type InterconnectAttachmentsServer interface {
	// Retrieves an aggregated list of interconnect attachments.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListInterconnectAttachmentsRequest) (*InterconnectAttachmentAggregatedList, error)
	// Deletes the specified interconnect attachment.
	Delete(context.Context, *DeleteInterconnectAttachmentRequest) (*Operation, error)
	// Returns the specified interconnect attachment.
	Get(context.Context, *GetInterconnectAttachmentRequest) (*InterconnectAttachment, error)
	// Creates an InterconnectAttachment in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertInterconnectAttachmentRequest) (*Operation, error)
	// Retrieves the list of interconnect attachments contained within
	// the specified region.
	List(context.Context, *ListInterconnectAttachmentsRequest) (*InterconnectAttachmentList, error)
	// Updates the specified interconnect attachment with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchInterconnectAttachmentRequest) (*Operation, error)
	// Sets the labels on an InterconnectAttachment. To learn more about labels,
	// read the Labeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsInterconnectAttachmentRequest) (*Operation, error)
}

// UnimplementedInterconnectAttachmentsServer should be embedded to have forward compatible implementations.
type UnimplementedInterconnectAttachmentsServer struct {
}

func (UnimplementedInterconnectAttachmentsServer) AggregatedList(context.Context, *AggregatedListInterconnectAttachmentsRequest) (*InterconnectAttachmentAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedInterconnectAttachmentsServer) Delete(context.Context, *DeleteInterconnectAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInterconnectAttachmentsServer) Get(context.Context, *GetInterconnectAttachmentRequest) (*InterconnectAttachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInterconnectAttachmentsServer) Insert(context.Context, *InsertInterconnectAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInterconnectAttachmentsServer) List(context.Context, *ListInterconnectAttachmentsRequest) (*InterconnectAttachmentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInterconnectAttachmentsServer) Patch(context.Context, *PatchInterconnectAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedInterconnectAttachmentsServer) SetLabels(context.Context, *SetLabelsInterconnectAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}

// UnsafeInterconnectAttachmentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterconnectAttachmentsServer will
// result in compilation errors.
type UnsafeInterconnectAttachmentsServer interface {
	mustEmbedUnimplementedInterconnectAttachmentsServer()
}

func RegisterInterconnectAttachmentsServer(s grpc.ServiceRegistrar, srv InterconnectAttachmentsServer) {
	s.RegisterService(&InterconnectAttachments_ServiceDesc, srv)
}

func _InterconnectAttachments_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListInterconnectAttachmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).AggregatedList(ctx, req.(*AggregatedListInterconnectAttachmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachments_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInterconnectAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).Delete(ctx, req.(*DeleteInterconnectAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachments_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterconnectAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).Get(ctx, req.(*GetInterconnectAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachments_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInterconnectAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).Insert(ctx, req.(*InsertInterconnectAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachments_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterconnectAttachmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).List(ctx, req.(*ListInterconnectAttachmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachments_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchInterconnectAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).Patch(ctx, req.(*PatchInterconnectAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectAttachments_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsInterconnectAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectAttachmentsServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectAttachments_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectAttachmentsServer).SetLabels(ctx, req.(*SetLabelsInterconnectAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InterconnectAttachments_ServiceDesc is the grpc.ServiceDesc for InterconnectAttachments service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InterconnectAttachments_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InterconnectAttachments",
	HandlerType: (*InterconnectAttachmentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _InterconnectAttachments_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InterconnectAttachments_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InterconnectAttachments_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InterconnectAttachments_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InterconnectAttachments_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _InterconnectAttachments_Patch_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _InterconnectAttachments_SetLabels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InterconnectGroups_CreateMembers_FullMethodName        = "/google.cloud.compute.v1.InterconnectGroups/CreateMembers"
	InterconnectGroups_Delete_FullMethodName               = "/google.cloud.compute.v1.InterconnectGroups/Delete"
	InterconnectGroups_Get_FullMethodName                  = "/google.cloud.compute.v1.InterconnectGroups/Get"
	InterconnectGroups_GetIamPolicy_FullMethodName         = "/google.cloud.compute.v1.InterconnectGroups/GetIamPolicy"
	InterconnectGroups_GetOperationalStatus_FullMethodName = "/google.cloud.compute.v1.InterconnectGroups/GetOperationalStatus"
	InterconnectGroups_Insert_FullMethodName               = "/google.cloud.compute.v1.InterconnectGroups/Insert"
	InterconnectGroups_List_FullMethodName                 = "/google.cloud.compute.v1.InterconnectGroups/List"
	InterconnectGroups_Patch_FullMethodName                = "/google.cloud.compute.v1.InterconnectGroups/Patch"
	InterconnectGroups_SetIamPolicy_FullMethodName         = "/google.cloud.compute.v1.InterconnectGroups/SetIamPolicy"
	InterconnectGroups_TestIamPermissions_FullMethodName   = "/google.cloud.compute.v1.InterconnectGroups/TestIamPermissions"
)

// InterconnectGroupsClient is the client API for InterconnectGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterconnectGroupsClient interface {
	// Create Interconnects with redundancy by creating them in a specified
	// interconnect group.
	CreateMembers(ctx context.Context, in *CreateMembersInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified InterconnectGroup in the given scope
	Delete(ctx context.Context, in *DeleteInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified InterconnectGroup resource in the given scope.
	Get(ctx context.Context, in *GetInterconnectGroupRequest, opts ...grpc.CallOption) (*InterconnectGroup, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyInterconnectGroupRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns the interconnectStatuses for the specified
	// InterconnectGroup.
	GetOperationalStatus(ctx context.Context, in *GetOperationalStatusInterconnectGroupRequest, opts ...grpc.CallOption) (*InterconnectGroupsGetOperationalStatusResponse, error)
	// Creates a InterconnectGroup in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the InterconnectGroups for a project in the given scope.
	List(ctx context.Context, in *ListInterconnectGroupsRequest, opts ...grpc.CallOption) (*InterconnectGroupsListResponse, error)
	// Patches the specified InterconnectGroup resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyInterconnectGroupRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsInterconnectGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type interconnectGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewInterconnectGroupsClient(cc grpc.ClientConnInterface) InterconnectGroupsClient {
	return &interconnectGroupsClient{cc}
}

func (c *interconnectGroupsClient) CreateMembers(ctx context.Context, in *CreateMembersInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectGroups_CreateMembers_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) Delete(ctx context.Context, in *DeleteInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) Get(ctx context.Context, in *GetInterconnectGroupRequest, opts ...grpc.CallOption) (*InterconnectGroup, error) {
	out := new(InterconnectGroup)
	err := c.cc.Invoke(ctx, InterconnectGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyInterconnectGroupRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InterconnectGroups_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) GetOperationalStatus(ctx context.Context, in *GetOperationalStatusInterconnectGroupRequest, opts ...grpc.CallOption) (*InterconnectGroupsGetOperationalStatusResponse, error) {
	out := new(InterconnectGroupsGetOperationalStatusResponse)
	err := c.cc.Invoke(ctx, InterconnectGroups_GetOperationalStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) Insert(ctx context.Context, in *InsertInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) List(ctx context.Context, in *ListInterconnectGroupsRequest, opts ...grpc.CallOption) (*InterconnectGroupsListResponse, error) {
	out := new(InterconnectGroupsListResponse)
	err := c.cc.Invoke(ctx, InterconnectGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) Patch(ctx context.Context, in *PatchInterconnectGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, InterconnectGroups_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyInterconnectGroupRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, InterconnectGroups_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectGroupsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsInterconnectGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, InterconnectGroups_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterconnectGroupsServer is the server API for InterconnectGroups service.
// All implementations should embed UnimplementedInterconnectGroupsServer
// for forward compatibility
type InterconnectGroupsServer interface {
	// Create Interconnects with redundancy by creating them in a specified
	// interconnect group.
	CreateMembers(context.Context, *CreateMembersInterconnectGroupRequest) (*Operation, error)
	// Deletes the specified InterconnectGroup in the given scope
	Delete(context.Context, *DeleteInterconnectGroupRequest) (*Operation, error)
	// Returns the specified InterconnectGroup resource in the given scope.
	Get(context.Context, *GetInterconnectGroupRequest) (*InterconnectGroup, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyInterconnectGroupRequest) (*Policy, error)
	// Returns the interconnectStatuses for the specified
	// InterconnectGroup.
	GetOperationalStatus(context.Context, *GetOperationalStatusInterconnectGroupRequest) (*InterconnectGroupsGetOperationalStatusResponse, error)
	// Creates a InterconnectGroup in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertInterconnectGroupRequest) (*Operation, error)
	// Lists the InterconnectGroups for a project in the given scope.
	List(context.Context, *ListInterconnectGroupsRequest) (*InterconnectGroupsListResponse, error)
	// Patches the specified InterconnectGroup resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchInterconnectGroupRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyInterconnectGroupRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsInterconnectGroupRequest) (*TestPermissionsResponse, error)
}

// UnimplementedInterconnectGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedInterconnectGroupsServer struct {
}

func (UnimplementedInterconnectGroupsServer) CreateMembers(context.Context, *CreateMembersInterconnectGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateMembers not implemented")
}
func (UnimplementedInterconnectGroupsServer) Delete(context.Context, *DeleteInterconnectGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInterconnectGroupsServer) Get(context.Context, *GetInterconnectGroupRequest) (*InterconnectGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInterconnectGroupsServer) GetIamPolicy(context.Context, *GetIamPolicyInterconnectGroupRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedInterconnectGroupsServer) GetOperationalStatus(context.Context, *GetOperationalStatusInterconnectGroupRequest) (*InterconnectGroupsGetOperationalStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOperationalStatus not implemented")
}
func (UnimplementedInterconnectGroupsServer) Insert(context.Context, *InsertInterconnectGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInterconnectGroupsServer) List(context.Context, *ListInterconnectGroupsRequest) (*InterconnectGroupsListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInterconnectGroupsServer) Patch(context.Context, *PatchInterconnectGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedInterconnectGroupsServer) SetIamPolicy(context.Context, *SetIamPolicyInterconnectGroupRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedInterconnectGroupsServer) TestIamPermissions(context.Context, *TestIamPermissionsInterconnectGroupRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeInterconnectGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterconnectGroupsServer will
// result in compilation errors.
type UnsafeInterconnectGroupsServer interface {
	mustEmbedUnimplementedInterconnectGroupsServer()
}

func RegisterInterconnectGroupsServer(s grpc.ServiceRegistrar, srv InterconnectGroupsServer) {
	s.RegisterService(&InterconnectGroups_ServiceDesc, srv)
}

func _InterconnectGroups_CreateMembers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateMembersInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).CreateMembers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_CreateMembers_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).CreateMembers(ctx, req.(*CreateMembersInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).Delete(ctx, req.(*DeleteInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).Get(ctx, req.(*GetInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).GetIamPolicy(ctx, req.(*GetIamPolicyInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_GetOperationalStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOperationalStatusInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).GetOperationalStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_GetOperationalStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).GetOperationalStatus(ctx, req.(*GetOperationalStatusInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).Insert(ctx, req.(*InsertInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterconnectGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).List(ctx, req.(*ListInterconnectGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).Patch(ctx, req.(*PatchInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).SetIamPolicy(ctx, req.(*SetIamPolicyInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectGroups_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsInterconnectGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectGroupsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectGroups_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectGroupsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsInterconnectGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InterconnectGroups_ServiceDesc is the grpc.ServiceDesc for InterconnectGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InterconnectGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InterconnectGroups",
	HandlerType: (*InterconnectGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateMembers",
			Handler:    _InterconnectGroups_CreateMembers_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _InterconnectGroups_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _InterconnectGroups_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _InterconnectGroups_GetIamPolicy_Handler,
		},
		{
			MethodName: "GetOperationalStatus",
			Handler:    _InterconnectGroups_GetOperationalStatus_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _InterconnectGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InterconnectGroups_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _InterconnectGroups_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _InterconnectGroups_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _InterconnectGroups_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InterconnectLocations_Get_FullMethodName  = "/google.cloud.compute.v1.InterconnectLocations/Get"
	InterconnectLocations_List_FullMethodName = "/google.cloud.compute.v1.InterconnectLocations/List"
)

// InterconnectLocationsClient is the client API for InterconnectLocations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterconnectLocationsClient interface {
	// Returns the details for the specified interconnect location. Gets a list of
	// available interconnect locations by making a list() request.
	Get(ctx context.Context, in *GetInterconnectLocationRequest, opts ...grpc.CallOption) (*InterconnectLocation, error)
	// Retrieves the list of interconnect locations available to the specified
	// project.
	List(ctx context.Context, in *ListInterconnectLocationsRequest, opts ...grpc.CallOption) (*InterconnectLocationList, error)
}

type interconnectLocationsClient struct {
	cc grpc.ClientConnInterface
}

func NewInterconnectLocationsClient(cc grpc.ClientConnInterface) InterconnectLocationsClient {
	return &interconnectLocationsClient{cc}
}

func (c *interconnectLocationsClient) Get(ctx context.Context, in *GetInterconnectLocationRequest, opts ...grpc.CallOption) (*InterconnectLocation, error) {
	out := new(InterconnectLocation)
	err := c.cc.Invoke(ctx, InterconnectLocations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectLocationsClient) List(ctx context.Context, in *ListInterconnectLocationsRequest, opts ...grpc.CallOption) (*InterconnectLocationList, error) {
	out := new(InterconnectLocationList)
	err := c.cc.Invoke(ctx, InterconnectLocations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterconnectLocationsServer is the server API for InterconnectLocations service.
// All implementations should embed UnimplementedInterconnectLocationsServer
// for forward compatibility
type InterconnectLocationsServer interface {
	// Returns the details for the specified interconnect location. Gets a list of
	// available interconnect locations by making a list() request.
	Get(context.Context, *GetInterconnectLocationRequest) (*InterconnectLocation, error)
	// Retrieves the list of interconnect locations available to the specified
	// project.
	List(context.Context, *ListInterconnectLocationsRequest) (*InterconnectLocationList, error)
}

// UnimplementedInterconnectLocationsServer should be embedded to have forward compatible implementations.
type UnimplementedInterconnectLocationsServer struct {
}

func (UnimplementedInterconnectLocationsServer) Get(context.Context, *GetInterconnectLocationRequest) (*InterconnectLocation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInterconnectLocationsServer) List(context.Context, *ListInterconnectLocationsRequest) (*InterconnectLocationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeInterconnectLocationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterconnectLocationsServer will
// result in compilation errors.
type UnsafeInterconnectLocationsServer interface {
	mustEmbedUnimplementedInterconnectLocationsServer()
}

func RegisterInterconnectLocationsServer(s grpc.ServiceRegistrar, srv InterconnectLocationsServer) {
	s.RegisterService(&InterconnectLocations_ServiceDesc, srv)
}

func _InterconnectLocations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterconnectLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectLocationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectLocations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectLocationsServer).Get(ctx, req.(*GetInterconnectLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectLocations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterconnectLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectLocationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectLocations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectLocationsServer).List(ctx, req.(*ListInterconnectLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InterconnectLocations_ServiceDesc is the grpc.ServiceDesc for InterconnectLocations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InterconnectLocations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InterconnectLocations",
	HandlerType: (*InterconnectLocationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _InterconnectLocations_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InterconnectLocations_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	InterconnectRemoteLocations_Get_FullMethodName  = "/google.cloud.compute.v1.InterconnectRemoteLocations/Get"
	InterconnectRemoteLocations_List_FullMethodName = "/google.cloud.compute.v1.InterconnectRemoteLocations/List"
)

// InterconnectRemoteLocationsClient is the client API for InterconnectRemoteLocations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterconnectRemoteLocationsClient interface {
	// Returns the details for the specified interconnect remote location. Gets a
	// list of available interconnect remote locations by making alist() request.
	Get(ctx context.Context, in *GetInterconnectRemoteLocationRequest, opts ...grpc.CallOption) (*InterconnectRemoteLocation, error)
	// Retrieves the list of interconnect remote locations available to the
	// specified project.
	List(ctx context.Context, in *ListInterconnectRemoteLocationsRequest, opts ...grpc.CallOption) (*InterconnectRemoteLocationList, error)
}

type interconnectRemoteLocationsClient struct {
	cc grpc.ClientConnInterface
}

func NewInterconnectRemoteLocationsClient(cc grpc.ClientConnInterface) InterconnectRemoteLocationsClient {
	return &interconnectRemoteLocationsClient{cc}
}

func (c *interconnectRemoteLocationsClient) Get(ctx context.Context, in *GetInterconnectRemoteLocationRequest, opts ...grpc.CallOption) (*InterconnectRemoteLocation, error) {
	out := new(InterconnectRemoteLocation)
	err := c.cc.Invoke(ctx, InterconnectRemoteLocations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectRemoteLocationsClient) List(ctx context.Context, in *ListInterconnectRemoteLocationsRequest, opts ...grpc.CallOption) (*InterconnectRemoteLocationList, error) {
	out := new(InterconnectRemoteLocationList)
	err := c.cc.Invoke(ctx, InterconnectRemoteLocations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterconnectRemoteLocationsServer is the server API for InterconnectRemoteLocations service.
// All implementations should embed UnimplementedInterconnectRemoteLocationsServer
// for forward compatibility
type InterconnectRemoteLocationsServer interface {
	// Returns the details for the specified interconnect remote location. Gets a
	// list of available interconnect remote locations by making alist() request.
	Get(context.Context, *GetInterconnectRemoteLocationRequest) (*InterconnectRemoteLocation, error)
	// Retrieves the list of interconnect remote locations available to the
	// specified project.
	List(context.Context, *ListInterconnectRemoteLocationsRequest) (*InterconnectRemoteLocationList, error)
}

// UnimplementedInterconnectRemoteLocationsServer should be embedded to have forward compatible implementations.
type UnimplementedInterconnectRemoteLocationsServer struct {
}

func (UnimplementedInterconnectRemoteLocationsServer) Get(context.Context, *GetInterconnectRemoteLocationRequest) (*InterconnectRemoteLocation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInterconnectRemoteLocationsServer) List(context.Context, *ListInterconnectRemoteLocationsRequest) (*InterconnectRemoteLocationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeInterconnectRemoteLocationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterconnectRemoteLocationsServer will
// result in compilation errors.
type UnsafeInterconnectRemoteLocationsServer interface {
	mustEmbedUnimplementedInterconnectRemoteLocationsServer()
}

func RegisterInterconnectRemoteLocationsServer(s grpc.ServiceRegistrar, srv InterconnectRemoteLocationsServer) {
	s.RegisterService(&InterconnectRemoteLocations_ServiceDesc, srv)
}

func _InterconnectRemoteLocations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterconnectRemoteLocationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectRemoteLocationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectRemoteLocations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectRemoteLocationsServer).Get(ctx, req.(*GetInterconnectRemoteLocationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _InterconnectRemoteLocations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterconnectRemoteLocationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectRemoteLocationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: InterconnectRemoteLocations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectRemoteLocationsServer).List(ctx, req.(*ListInterconnectRemoteLocationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// InterconnectRemoteLocations_ServiceDesc is the grpc.ServiceDesc for InterconnectRemoteLocations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var InterconnectRemoteLocations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.InterconnectRemoteLocations",
	HandlerType: (*InterconnectRemoteLocationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _InterconnectRemoteLocations_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _InterconnectRemoteLocations_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Interconnects_Delete_FullMethodName          = "/google.cloud.compute.v1.Interconnects/Delete"
	Interconnects_Get_FullMethodName             = "/google.cloud.compute.v1.Interconnects/Get"
	Interconnects_GetDiagnostics_FullMethodName  = "/google.cloud.compute.v1.Interconnects/GetDiagnostics"
	Interconnects_GetMacsecConfig_FullMethodName = "/google.cloud.compute.v1.Interconnects/GetMacsecConfig"
	Interconnects_Insert_FullMethodName          = "/google.cloud.compute.v1.Interconnects/Insert"
	Interconnects_List_FullMethodName            = "/google.cloud.compute.v1.Interconnects/List"
	Interconnects_Patch_FullMethodName           = "/google.cloud.compute.v1.Interconnects/Patch"
	Interconnects_SetLabels_FullMethodName       = "/google.cloud.compute.v1.Interconnects/SetLabels"
)

// InterconnectsClient is the client API for Interconnects service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type InterconnectsClient interface {
	// Deletes the specified Interconnect.
	Delete(ctx context.Context, in *DeleteInterconnectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified Interconnect. Get a list of available Interconnects
	// by making a list() request.
	Get(ctx context.Context, in *GetInterconnectRequest, opts ...grpc.CallOption) (*Interconnect, error)
	// Returns the interconnectDiagnostics for the specified
	// Interconnect.
	//
	// In the event of a
	// global outage, do not use this API to make decisions about where to
	// redirect your network traffic.
	//
	// Unlike a VLAN attachment, which is regional, a Cloud Interconnect
	// connection is a global resource. A global outage can prevent this
	// API from functioning properly.
	GetDiagnostics(ctx context.Context, in *GetDiagnosticsInterconnectRequest, opts ...grpc.CallOption) (*InterconnectsGetDiagnosticsResponse, error)
	// Returns the interconnectMacsecConfig for the specified
	// Interconnect.
	GetMacsecConfig(ctx context.Context, in *GetMacsecConfigInterconnectRequest, opts ...grpc.CallOption) (*InterconnectsGetMacsecConfigResponse, error)
	// Creates an Interconnect in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertInterconnectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of Interconnects available to the specified project.
	List(ctx context.Context, in *ListInterconnectsRequest, opts ...grpc.CallOption) (*InterconnectList, error)
	// Updates the specified Interconnect with the data included in the request.
	// This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchInterconnectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on an Interconnect. To learn more about labels,
	// read the Labeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsInterconnectRequest, opts ...grpc.CallOption) (*Operation, error)
}

type interconnectsClient struct {
	cc grpc.ClientConnInterface
}

func NewInterconnectsClient(cc grpc.ClientConnInterface) InterconnectsClient {
	return &interconnectsClient{cc}
}

func (c *interconnectsClient) Delete(ctx context.Context, in *DeleteInterconnectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Interconnects_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) Get(ctx context.Context, in *GetInterconnectRequest, opts ...grpc.CallOption) (*Interconnect, error) {
	out := new(Interconnect)
	err := c.cc.Invoke(ctx, Interconnects_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) GetDiagnostics(ctx context.Context, in *GetDiagnosticsInterconnectRequest, opts ...grpc.CallOption) (*InterconnectsGetDiagnosticsResponse, error) {
	out := new(InterconnectsGetDiagnosticsResponse)
	err := c.cc.Invoke(ctx, Interconnects_GetDiagnostics_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) GetMacsecConfig(ctx context.Context, in *GetMacsecConfigInterconnectRequest, opts ...grpc.CallOption) (*InterconnectsGetMacsecConfigResponse, error) {
	out := new(InterconnectsGetMacsecConfigResponse)
	err := c.cc.Invoke(ctx, Interconnects_GetMacsecConfig_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) Insert(ctx context.Context, in *InsertInterconnectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Interconnects_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) List(ctx context.Context, in *ListInterconnectsRequest, opts ...grpc.CallOption) (*InterconnectList, error) {
	out := new(InterconnectList)
	err := c.cc.Invoke(ctx, Interconnects_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) Patch(ctx context.Context, in *PatchInterconnectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Interconnects_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *interconnectsClient) SetLabels(ctx context.Context, in *SetLabelsInterconnectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Interconnects_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InterconnectsServer is the server API for Interconnects service.
// All implementations should embed UnimplementedInterconnectsServer
// for forward compatibility
type InterconnectsServer interface {
	// Deletes the specified Interconnect.
	Delete(context.Context, *DeleteInterconnectRequest) (*Operation, error)
	// Returns the specified Interconnect. Get a list of available Interconnects
	// by making a list() request.
	Get(context.Context, *GetInterconnectRequest) (*Interconnect, error)
	// Returns the interconnectDiagnostics for the specified
	// Interconnect.
	//
	// In the event of a
	// global outage, do not use this API to make decisions about where to
	// redirect your network traffic.
	//
	// Unlike a VLAN attachment, which is regional, a Cloud Interconnect
	// connection is a global resource. A global outage can prevent this
	// API from functioning properly.
	GetDiagnostics(context.Context, *GetDiagnosticsInterconnectRequest) (*InterconnectsGetDiagnosticsResponse, error)
	// Returns the interconnectMacsecConfig for the specified
	// Interconnect.
	GetMacsecConfig(context.Context, *GetMacsecConfigInterconnectRequest) (*InterconnectsGetMacsecConfigResponse, error)
	// Creates an Interconnect in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertInterconnectRequest) (*Operation, error)
	// Retrieves the list of Interconnects available to the specified project.
	List(context.Context, *ListInterconnectsRequest) (*InterconnectList, error)
	// Updates the specified Interconnect with the data included in the request.
	// This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchInterconnectRequest) (*Operation, error)
	// Sets the labels on an Interconnect. To learn more about labels,
	// read the Labeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsInterconnectRequest) (*Operation, error)
}

// UnimplementedInterconnectsServer should be embedded to have forward compatible implementations.
type UnimplementedInterconnectsServer struct {
}

func (UnimplementedInterconnectsServer) Delete(context.Context, *DeleteInterconnectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedInterconnectsServer) Get(context.Context, *GetInterconnectRequest) (*Interconnect, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedInterconnectsServer) GetDiagnostics(context.Context, *GetDiagnosticsInterconnectRequest) (*InterconnectsGetDiagnosticsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDiagnostics not implemented")
}
func (UnimplementedInterconnectsServer) GetMacsecConfig(context.Context, *GetMacsecConfigInterconnectRequest) (*InterconnectsGetMacsecConfigResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMacsecConfig not implemented")
}
func (UnimplementedInterconnectsServer) Insert(context.Context, *InsertInterconnectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedInterconnectsServer) List(context.Context, *ListInterconnectsRequest) (*InterconnectList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedInterconnectsServer) Patch(context.Context, *PatchInterconnectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedInterconnectsServer) SetLabels(context.Context, *SetLabelsInterconnectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}

// UnsafeInterconnectsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to InterconnectsServer will
// result in compilation errors.
type UnsafeInterconnectsServer interface {
	mustEmbedUnimplementedInterconnectsServer()
}

func RegisterInterconnectsServer(s grpc.ServiceRegistrar, srv InterconnectsServer) {
	s.RegisterService(&Interconnects_ServiceDesc, srv)
}

func _Interconnects_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).Delete(ctx, req.(*DeleteInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).Get(ctx, req.(*GetInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_GetDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDiagnosticsInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).GetDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_GetDiagnostics_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).GetDiagnostics(ctx, req.(*GetDiagnosticsInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_GetMacsecConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMacsecConfigInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).GetMacsecConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_GetMacsecConfig_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).GetMacsecConfig(ctx, req.(*GetMacsecConfigInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).Insert(ctx, req.(*InsertInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInterconnectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).List(ctx, req.(*ListInterconnectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).Patch(ctx, req.(*PatchInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Interconnects_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsInterconnectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InterconnectsServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Interconnects_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InterconnectsServer).SetLabels(ctx, req.(*SetLabelsInterconnectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Interconnects_ServiceDesc is the grpc.ServiceDesc for Interconnects service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Interconnects_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Interconnects",
	HandlerType: (*InterconnectsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Interconnects_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Interconnects_Get_Handler,
		},
		{
			MethodName: "GetDiagnostics",
			Handler:    _Interconnects_GetDiagnostics_Handler,
		},
		{
			MethodName: "GetMacsecConfig",
			Handler:    _Interconnects_GetMacsecConfig_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Interconnects_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Interconnects_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Interconnects_Patch_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _Interconnects_SetLabels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	LicenseCodes_Get_FullMethodName                = "/google.cloud.compute.v1.LicenseCodes/Get"
	LicenseCodes_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.LicenseCodes/TestIamPermissions"
)

// LicenseCodesClient is the client API for LicenseCodes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LicenseCodesClient interface {
	// Return a specified license code. License codes are mirrored across
	// all projects that have permissions to read the License Code.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Get(ctx context.Context, in *GetLicenseCodeRequest, opts ...grpc.CallOption) (*LicenseCode, error)
	// Returns permissions that a caller has on the specified resource.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsLicenseCodeRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type licenseCodesClient struct {
	cc grpc.ClientConnInterface
}

func NewLicenseCodesClient(cc grpc.ClientConnInterface) LicenseCodesClient {
	return &licenseCodesClient{cc}
}

func (c *licenseCodesClient) Get(ctx context.Context, in *GetLicenseCodeRequest, opts ...grpc.CallOption) (*LicenseCode, error) {
	out := new(LicenseCode)
	err := c.cc.Invoke(ctx, LicenseCodes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseCodesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsLicenseCodeRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, LicenseCodes_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LicenseCodesServer is the server API for LicenseCodes service.
// All implementations should embed UnimplementedLicenseCodesServer
// for forward compatibility
type LicenseCodesServer interface {
	// Return a specified license code. License codes are mirrored across
	// all projects that have permissions to read the License Code.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Get(context.Context, *GetLicenseCodeRequest) (*LicenseCode, error)
	// Returns permissions that a caller has on the specified resource.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	TestIamPermissions(context.Context, *TestIamPermissionsLicenseCodeRequest) (*TestPermissionsResponse, error)
}

// UnimplementedLicenseCodesServer should be embedded to have forward compatible implementations.
type UnimplementedLicenseCodesServer struct {
}

func (UnimplementedLicenseCodesServer) Get(context.Context, *GetLicenseCodeRequest) (*LicenseCode, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLicenseCodesServer) TestIamPermissions(context.Context, *TestIamPermissionsLicenseCodeRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeLicenseCodesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LicenseCodesServer will
// result in compilation errors.
type UnsafeLicenseCodesServer interface {
	mustEmbedUnimplementedLicenseCodesServer()
}

func RegisterLicenseCodesServer(s grpc.ServiceRegistrar, srv LicenseCodesServer) {
	s.RegisterService(&LicenseCodes_ServiceDesc, srv)
}

func _LicenseCodes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLicenseCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseCodesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseCodes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseCodesServer).Get(ctx, req.(*GetLicenseCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseCodes_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsLicenseCodeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseCodesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseCodes_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseCodesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsLicenseCodeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LicenseCodes_ServiceDesc is the grpc.ServiceDesc for LicenseCodes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LicenseCodes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.LicenseCodes",
	HandlerType: (*LicenseCodesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _LicenseCodes_Get_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _LicenseCodes_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Licenses_Delete_FullMethodName             = "/google.cloud.compute.v1.Licenses/Delete"
	Licenses_Get_FullMethodName                = "/google.cloud.compute.v1.Licenses/Get"
	Licenses_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Licenses/GetIamPolicy"
	Licenses_Insert_FullMethodName             = "/google.cloud.compute.v1.Licenses/Insert"
	Licenses_List_FullMethodName               = "/google.cloud.compute.v1.Licenses/List"
	Licenses_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Licenses/SetIamPolicy"
	Licenses_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Licenses/TestIamPermissions"
	Licenses_Update_FullMethodName             = "/google.cloud.compute.v1.Licenses/Update"
)

// LicensesClient is the client API for Licenses service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LicensesClient interface {
	// Deletes the specified license.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Delete(ctx context.Context, in *DeleteLicenseRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified License resource.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Get(ctx context.Context, in *GetLicenseRequest, opts ...grpc.CallOption) (*License, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyLicenseRequest, opts ...grpc.CallOption) (*Policy, error)
	// Create a License resource in the specified project.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Insert(ctx context.Context, in *InsertLicenseRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of licenses
	// available in the specified project. This method does not
	// get any licenses that belong to other projects, including licenses attached
	// to publicly-available images, like Debian 9. If you want to get a list of
	// publicly-available licenses, use this method to make a request to the
	// respective image project, such as debian-cloud orwindows-cloud.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	List(ctx context.Context, in *ListLicensesRequest, opts ...grpc.CallOption) (*LicensesListResponse, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyLicenseRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsLicenseRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates a License resource in the specified project.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Update(ctx context.Context, in *UpdateLicenseRequest, opts ...grpc.CallOption) (*Operation, error)
}

type licensesClient struct {
	cc grpc.ClientConnInterface
}

func NewLicensesClient(cc grpc.ClientConnInterface) LicensesClient {
	return &licensesClient{cc}
}

func (c *licensesClient) Delete(ctx context.Context, in *DeleteLicenseRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Licenses_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) Get(ctx context.Context, in *GetLicenseRequest, opts ...grpc.CallOption) (*License, error) {
	out := new(License)
	err := c.cc.Invoke(ctx, Licenses_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyLicenseRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Licenses_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) Insert(ctx context.Context, in *InsertLicenseRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Licenses_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) List(ctx context.Context, in *ListLicensesRequest, opts ...grpc.CallOption) (*LicensesListResponse, error) {
	out := new(LicensesListResponse)
	err := c.cc.Invoke(ctx, Licenses_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyLicenseRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Licenses_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsLicenseRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Licenses_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licensesClient) Update(ctx context.Context, in *UpdateLicenseRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Licenses_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LicensesServer is the server API for Licenses service.
// All implementations should embed UnimplementedLicensesServer
// for forward compatibility
type LicensesServer interface {
	// Deletes the specified license.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Delete(context.Context, *DeleteLicenseRequest) (*Operation, error)
	// Returns the specified License resource.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Get(context.Context, *GetLicenseRequest) (*License, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	GetIamPolicy(context.Context, *GetIamPolicyLicenseRequest) (*Policy, error)
	// Create a License resource in the specified project.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Insert(context.Context, *InsertLicenseRequest) (*Operation, error)
	// Retrieves the list of licenses
	// available in the specified project. This method does not
	// get any licenses that belong to other projects, including licenses attached
	// to publicly-available images, like Debian 9. If you want to get a list of
	// publicly-available licenses, use this method to make a request to the
	// respective image project, such as debian-cloud orwindows-cloud.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	List(context.Context, *ListLicensesRequest) (*LicensesListResponse, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	SetIamPolicy(context.Context, *SetIamPolicyLicenseRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	TestIamPermissions(context.Context, *TestIamPermissionsLicenseRequest) (*TestPermissionsResponse, error)
	// Updates a License resource in the specified project.
	//
	//	*Caution* This resource is intended
	//
	// for use only by third-party partners who are creatingCloud Marketplace
	// images.
	Update(context.Context, *UpdateLicenseRequest) (*Operation, error)
}

// UnimplementedLicensesServer should be embedded to have forward compatible implementations.
type UnimplementedLicensesServer struct {
}

func (UnimplementedLicensesServer) Delete(context.Context, *DeleteLicenseRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedLicensesServer) Get(context.Context, *GetLicenseRequest) (*License, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedLicensesServer) GetIamPolicy(context.Context, *GetIamPolicyLicenseRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedLicensesServer) Insert(context.Context, *InsertLicenseRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedLicensesServer) List(context.Context, *ListLicensesRequest) (*LicensesListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedLicensesServer) SetIamPolicy(context.Context, *SetIamPolicyLicenseRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedLicensesServer) TestIamPermissions(context.Context, *TestIamPermissionsLicenseRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedLicensesServer) Update(context.Context, *UpdateLicenseRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeLicensesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LicensesServer will
// result in compilation errors.
type UnsafeLicensesServer interface {
	mustEmbedUnimplementedLicensesServer()
}

func RegisterLicensesServer(s grpc.ServiceRegistrar, srv LicensesServer) {
	s.RegisterService(&Licenses_ServiceDesc, srv)
}

func _Licenses_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).Delete(ctx, req.(*DeleteLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).Get(ctx, req.(*GetLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).GetIamPolicy(ctx, req.(*GetIamPolicyLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).Insert(ctx, req.(*InsertLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListLicensesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).List(ctx, req.(*ListLicensesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).SetIamPolicy(ctx, req.(*SetIamPolicyLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Licenses_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateLicenseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicensesServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Licenses_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicensesServer).Update(ctx, req.(*UpdateLicenseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Licenses_ServiceDesc is the grpc.ServiceDesc for Licenses service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Licenses_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Licenses",
	HandlerType: (*LicensesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Licenses_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Licenses_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Licenses_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Licenses_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Licenses_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Licenses_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Licenses_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Licenses_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	MachineImages_Delete_FullMethodName             = "/google.cloud.compute.v1.MachineImages/Delete"
	MachineImages_Get_FullMethodName                = "/google.cloud.compute.v1.MachineImages/Get"
	MachineImages_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.MachineImages/GetIamPolicy"
	MachineImages_Insert_FullMethodName             = "/google.cloud.compute.v1.MachineImages/Insert"
	MachineImages_List_FullMethodName               = "/google.cloud.compute.v1.MachineImages/List"
	MachineImages_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.MachineImages/SetIamPolicy"
	MachineImages_SetLabels_FullMethodName          = "/google.cloud.compute.v1.MachineImages/SetLabels"
	MachineImages_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.MachineImages/TestIamPermissions"
)

// MachineImagesClient is the client API for MachineImages service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MachineImagesClient interface {
	// Deletes the specified machine image. Deleting a machine image is permanent
	// and cannot be undone.
	Delete(ctx context.Context, in *DeleteMachineImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified machine image.
	Get(ctx context.Context, in *GetMachineImageRequest, opts ...grpc.CallOption) (*MachineImage, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyMachineImageRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a machine image in the specified project using the
	// data that is included in the request. If you are creating a new machine
	// image to update an existing instance, your new machine image should use the
	// same network or, if applicable, the same subnetwork as the original
	// instance.
	Insert(ctx context.Context, in *InsertMachineImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of machine images that are contained within
	// the specified project.
	List(ctx context.Context, in *ListMachineImagesRequest, opts ...grpc.CallOption) (*MachineImageList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyMachineImageRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on a machine image. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsMachineImageRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsMachineImageRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type machineImagesClient struct {
	cc grpc.ClientConnInterface
}

func NewMachineImagesClient(cc grpc.ClientConnInterface) MachineImagesClient {
	return &machineImagesClient{cc}
}

func (c *machineImagesClient) Delete(ctx context.Context, in *DeleteMachineImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineImages_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) Get(ctx context.Context, in *GetMachineImageRequest, opts ...grpc.CallOption) (*MachineImage, error) {
	out := new(MachineImage)
	err := c.cc.Invoke(ctx, MachineImages_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyMachineImageRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, MachineImages_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) Insert(ctx context.Context, in *InsertMachineImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineImages_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) List(ctx context.Context, in *ListMachineImagesRequest, opts ...grpc.CallOption) (*MachineImageList, error) {
	out := new(MachineImageList)
	err := c.cc.Invoke(ctx, MachineImages_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyMachineImageRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, MachineImages_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) SetLabels(ctx context.Context, in *SetLabelsMachineImageRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, MachineImages_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineImagesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsMachineImageRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, MachineImages_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MachineImagesServer is the server API for MachineImages service.
// All implementations should embed UnimplementedMachineImagesServer
// for forward compatibility
type MachineImagesServer interface {
	// Deletes the specified machine image. Deleting a machine image is permanent
	// and cannot be undone.
	Delete(context.Context, *DeleteMachineImageRequest) (*Operation, error)
	// Returns the specified machine image.
	Get(context.Context, *GetMachineImageRequest) (*MachineImage, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyMachineImageRequest) (*Policy, error)
	// Creates a machine image in the specified project using the
	// data that is included in the request. If you are creating a new machine
	// image to update an existing instance, your new machine image should use the
	// same network or, if applicable, the same subnetwork as the original
	// instance.
	Insert(context.Context, *InsertMachineImageRequest) (*Operation, error)
	// Retrieves a list of machine images that are contained within
	// the specified project.
	List(context.Context, *ListMachineImagesRequest) (*MachineImageList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyMachineImageRequest) (*Policy, error)
	// Sets the labels on a machine image. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsMachineImageRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsMachineImageRequest) (*TestPermissionsResponse, error)
}

// UnimplementedMachineImagesServer should be embedded to have forward compatible implementations.
type UnimplementedMachineImagesServer struct {
}

func (UnimplementedMachineImagesServer) Delete(context.Context, *DeleteMachineImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedMachineImagesServer) Get(context.Context, *GetMachineImageRequest) (*MachineImage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMachineImagesServer) GetIamPolicy(context.Context, *GetIamPolicyMachineImageRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedMachineImagesServer) Insert(context.Context, *InsertMachineImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedMachineImagesServer) List(context.Context, *ListMachineImagesRequest) (*MachineImageList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedMachineImagesServer) SetIamPolicy(context.Context, *SetIamPolicyMachineImageRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedMachineImagesServer) SetLabels(context.Context, *SetLabelsMachineImageRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedMachineImagesServer) TestIamPermissions(context.Context, *TestIamPermissionsMachineImageRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeMachineImagesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MachineImagesServer will
// result in compilation errors.
type UnsafeMachineImagesServer interface {
	mustEmbedUnimplementedMachineImagesServer()
}

func RegisterMachineImagesServer(s grpc.ServiceRegistrar, srv MachineImagesServer) {
	s.RegisterService(&MachineImages_ServiceDesc, srv)
}

func _MachineImages_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).Delete(ctx, req.(*DeleteMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).Get(ctx, req.(*GetMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).GetIamPolicy(ctx, req.(*GetIamPolicyMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).Insert(ctx, req.(*InsertMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMachineImagesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).List(ctx, req.(*ListMachineImagesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).SetIamPolicy(ctx, req.(*SetIamPolicyMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).SetLabels(ctx, req.(*SetLabelsMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineImages_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsMachineImageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineImagesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineImages_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineImagesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsMachineImageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MachineImages_ServiceDesc is the grpc.ServiceDesc for MachineImages service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MachineImages_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.MachineImages",
	HandlerType: (*MachineImagesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _MachineImages_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MachineImages_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _MachineImages_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _MachineImages_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MachineImages_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _MachineImages_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _MachineImages_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _MachineImages_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	MachineTypes_AggregatedList_FullMethodName = "/google.cloud.compute.v1.MachineTypes/AggregatedList"
	MachineTypes_Get_FullMethodName            = "/google.cloud.compute.v1.MachineTypes/Get"
	MachineTypes_List_FullMethodName           = "/google.cloud.compute.v1.MachineTypes/List"
)

// MachineTypesClient is the client API for MachineTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type MachineTypesClient interface {
	// Retrieves an aggregated list of machine types.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListMachineTypesRequest, opts ...grpc.CallOption) (*MachineTypeAggregatedList, error)
	// Returns the specified machine type.
	Get(ctx context.Context, in *GetMachineTypeRequest, opts ...grpc.CallOption) (*MachineType, error)
	// Retrieves a list of machine types available to the specified
	// project.
	List(ctx context.Context, in *ListMachineTypesRequest, opts ...grpc.CallOption) (*MachineTypeList, error)
}

type machineTypesClient struct {
	cc grpc.ClientConnInterface
}

func NewMachineTypesClient(cc grpc.ClientConnInterface) MachineTypesClient {
	return &machineTypesClient{cc}
}

func (c *machineTypesClient) AggregatedList(ctx context.Context, in *AggregatedListMachineTypesRequest, opts ...grpc.CallOption) (*MachineTypeAggregatedList, error) {
	out := new(MachineTypeAggregatedList)
	err := c.cc.Invoke(ctx, MachineTypes_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineTypesClient) Get(ctx context.Context, in *GetMachineTypeRequest, opts ...grpc.CallOption) (*MachineType, error) {
	out := new(MachineType)
	err := c.cc.Invoke(ctx, MachineTypes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *machineTypesClient) List(ctx context.Context, in *ListMachineTypesRequest, opts ...grpc.CallOption) (*MachineTypeList, error) {
	out := new(MachineTypeList)
	err := c.cc.Invoke(ctx, MachineTypes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// MachineTypesServer is the server API for MachineTypes service.
// All implementations should embed UnimplementedMachineTypesServer
// for forward compatibility
type MachineTypesServer interface {
	// Retrieves an aggregated list of machine types.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListMachineTypesRequest) (*MachineTypeAggregatedList, error)
	// Returns the specified machine type.
	Get(context.Context, *GetMachineTypeRequest) (*MachineType, error)
	// Retrieves a list of machine types available to the specified
	// project.
	List(context.Context, *ListMachineTypesRequest) (*MachineTypeList, error)
}

// UnimplementedMachineTypesServer should be embedded to have forward compatible implementations.
type UnimplementedMachineTypesServer struct {
}

func (UnimplementedMachineTypesServer) AggregatedList(context.Context, *AggregatedListMachineTypesRequest) (*MachineTypeAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedMachineTypesServer) Get(context.Context, *GetMachineTypeRequest) (*MachineType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedMachineTypesServer) List(context.Context, *ListMachineTypesRequest) (*MachineTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeMachineTypesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to MachineTypesServer will
// result in compilation errors.
type UnsafeMachineTypesServer interface {
	mustEmbedUnimplementedMachineTypesServer()
}

func RegisterMachineTypesServer(s grpc.ServiceRegistrar, srv MachineTypesServer) {
	s.RegisterService(&MachineTypes_ServiceDesc, srv)
}

func _MachineTypes_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListMachineTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineTypesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineTypes_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineTypesServer).AggregatedList(ctx, req.(*AggregatedListMachineTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineTypes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMachineTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineTypesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineTypes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineTypesServer).Get(ctx, req.(*GetMachineTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _MachineTypes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListMachineTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(MachineTypesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: MachineTypes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(MachineTypesServer).List(ctx, req.(*ListMachineTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// MachineTypes_ServiceDesc is the grpc.ServiceDesc for MachineTypes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var MachineTypes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.MachineTypes",
	HandlerType: (*MachineTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _MachineTypes_AggregatedList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _MachineTypes_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _MachineTypes_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NetworkAttachments_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.NetworkAttachments/AggregatedList"
	NetworkAttachments_Delete_FullMethodName             = "/google.cloud.compute.v1.NetworkAttachments/Delete"
	NetworkAttachments_Get_FullMethodName                = "/google.cloud.compute.v1.NetworkAttachments/Get"
	NetworkAttachments_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.NetworkAttachments/GetIamPolicy"
	NetworkAttachments_Insert_FullMethodName             = "/google.cloud.compute.v1.NetworkAttachments/Insert"
	NetworkAttachments_List_FullMethodName               = "/google.cloud.compute.v1.NetworkAttachments/List"
	NetworkAttachments_Patch_FullMethodName              = "/google.cloud.compute.v1.NetworkAttachments/Patch"
	NetworkAttachments_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.NetworkAttachments/SetIamPolicy"
	NetworkAttachments_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.NetworkAttachments/TestIamPermissions"
)

// NetworkAttachmentsClient is the client API for NetworkAttachments service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkAttachmentsClient interface {
	// Retrieves the list of all NetworkAttachment resources,
	// regional and global, available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNetworkAttachmentsRequest, opts ...grpc.CallOption) (*NetworkAttachmentAggregatedList, error)
	// Deletes the specified NetworkAttachment in the given scope
	Delete(ctx context.Context, in *DeleteNetworkAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified NetworkAttachment resource in the given scope.
	Get(ctx context.Context, in *GetNetworkAttachmentRequest, opts ...grpc.CallOption) (*NetworkAttachment, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyNetworkAttachmentRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a NetworkAttachment in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertNetworkAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the NetworkAttachments for a project in the given scope.
	List(ctx context.Context, in *ListNetworkAttachmentsRequest, opts ...grpc.CallOption) (*NetworkAttachmentList, error)
	// Patches the specified NetworkAttachment resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchNetworkAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyNetworkAttachmentRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsNetworkAttachmentRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type networkAttachmentsClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkAttachmentsClient(cc grpc.ClientConnInterface) NetworkAttachmentsClient {
	return &networkAttachmentsClient{cc}
}

func (c *networkAttachmentsClient) AggregatedList(ctx context.Context, in *AggregatedListNetworkAttachmentsRequest, opts ...grpc.CallOption) (*NetworkAttachmentAggregatedList, error) {
	out := new(NetworkAttachmentAggregatedList)
	err := c.cc.Invoke(ctx, NetworkAttachments_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) Delete(ctx context.Context, in *DeleteNetworkAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkAttachments_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) Get(ctx context.Context, in *GetNetworkAttachmentRequest, opts ...grpc.CallOption) (*NetworkAttachment, error) {
	out := new(NetworkAttachment)
	err := c.cc.Invoke(ctx, NetworkAttachments_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyNetworkAttachmentRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NetworkAttachments_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) Insert(ctx context.Context, in *InsertNetworkAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkAttachments_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) List(ctx context.Context, in *ListNetworkAttachmentsRequest, opts ...grpc.CallOption) (*NetworkAttachmentList, error) {
	out := new(NetworkAttachmentList)
	err := c.cc.Invoke(ctx, NetworkAttachments_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) Patch(ctx context.Context, in *PatchNetworkAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkAttachments_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyNetworkAttachmentRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NetworkAttachments_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkAttachmentsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsNetworkAttachmentRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, NetworkAttachments_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkAttachmentsServer is the server API for NetworkAttachments service.
// All implementations should embed UnimplementedNetworkAttachmentsServer
// for forward compatibility
type NetworkAttachmentsServer interface {
	// Retrieves the list of all NetworkAttachment resources,
	// regional and global, available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNetworkAttachmentsRequest) (*NetworkAttachmentAggregatedList, error)
	// Deletes the specified NetworkAttachment in the given scope
	Delete(context.Context, *DeleteNetworkAttachmentRequest) (*Operation, error)
	// Returns the specified NetworkAttachment resource in the given scope.
	Get(context.Context, *GetNetworkAttachmentRequest) (*NetworkAttachment, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyNetworkAttachmentRequest) (*Policy, error)
	// Creates a NetworkAttachment in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertNetworkAttachmentRequest) (*Operation, error)
	// Lists the NetworkAttachments for a project in the given scope.
	List(context.Context, *ListNetworkAttachmentsRequest) (*NetworkAttachmentList, error)
	// Patches the specified NetworkAttachment resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchNetworkAttachmentRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyNetworkAttachmentRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsNetworkAttachmentRequest) (*TestPermissionsResponse, error)
}

// UnimplementedNetworkAttachmentsServer should be embedded to have forward compatible implementations.
type UnimplementedNetworkAttachmentsServer struct {
}

func (UnimplementedNetworkAttachmentsServer) AggregatedList(context.Context, *AggregatedListNetworkAttachmentsRequest) (*NetworkAttachmentAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNetworkAttachmentsServer) Delete(context.Context, *DeleteNetworkAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNetworkAttachmentsServer) Get(context.Context, *GetNetworkAttachmentRequest) (*NetworkAttachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNetworkAttachmentsServer) GetIamPolicy(context.Context, *GetIamPolicyNetworkAttachmentRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedNetworkAttachmentsServer) Insert(context.Context, *InsertNetworkAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNetworkAttachmentsServer) List(context.Context, *ListNetworkAttachmentsRequest) (*NetworkAttachmentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedNetworkAttachmentsServer) Patch(context.Context, *PatchNetworkAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedNetworkAttachmentsServer) SetIamPolicy(context.Context, *SetIamPolicyNetworkAttachmentRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedNetworkAttachmentsServer) TestIamPermissions(context.Context, *TestIamPermissionsNetworkAttachmentRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeNetworkAttachmentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkAttachmentsServer will
// result in compilation errors.
type UnsafeNetworkAttachmentsServer interface {
	mustEmbedUnimplementedNetworkAttachmentsServer()
}

func RegisterNetworkAttachmentsServer(s grpc.ServiceRegistrar, srv NetworkAttachmentsServer) {
	s.RegisterService(&NetworkAttachments_ServiceDesc, srv)
}

func _NetworkAttachments_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNetworkAttachmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).AggregatedList(ctx, req.(*AggregatedListNetworkAttachmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).Delete(ctx, req.(*DeleteNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).Get(ctx, req.(*GetNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).GetIamPolicy(ctx, req.(*GetIamPolicyNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).Insert(ctx, req.(*InsertNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkAttachmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).List(ctx, req.(*ListNetworkAttachmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).Patch(ctx, req.(*PatchNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).SetIamPolicy(ctx, req.(*SetIamPolicyNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkAttachments_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsNetworkAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkAttachmentsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkAttachments_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkAttachmentsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsNetworkAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkAttachments_ServiceDesc is the grpc.ServiceDesc for NetworkAttachments service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkAttachments_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NetworkAttachments",
	HandlerType: (*NetworkAttachmentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _NetworkAttachments_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NetworkAttachments_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NetworkAttachments_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _NetworkAttachments_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NetworkAttachments_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NetworkAttachments_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _NetworkAttachments_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _NetworkAttachments_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _NetworkAttachments_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NetworkEdgeSecurityServices_AggregatedList_FullMethodName = "/google.cloud.compute.v1.NetworkEdgeSecurityServices/AggregatedList"
	NetworkEdgeSecurityServices_Delete_FullMethodName         = "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Delete"
	NetworkEdgeSecurityServices_Get_FullMethodName            = "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Get"
	NetworkEdgeSecurityServices_Insert_FullMethodName         = "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Insert"
	NetworkEdgeSecurityServices_Patch_FullMethodName          = "/google.cloud.compute.v1.NetworkEdgeSecurityServices/Patch"
)

// NetworkEdgeSecurityServicesClient is the client API for NetworkEdgeSecurityServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkEdgeSecurityServicesClient interface {
	// Retrieves the list of all NetworkEdgeSecurityService resources available to
	// the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNetworkEdgeSecurityServicesRequest, opts ...grpc.CallOption) (*NetworkEdgeSecurityServiceAggregatedList, error)
	// Deletes the specified service.
	Delete(ctx context.Context, in *DeleteNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Gets a specified NetworkEdgeSecurityService.
	Get(ctx context.Context, in *GetNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*NetworkEdgeSecurityService, error)
	// Creates a new service in the specified project using the data included in
	// the request.
	Insert(ctx context.Context, in *InsertNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches the specified policy with the data included in the request.
	Patch(ctx context.Context, in *PatchNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*Operation, error)
}

type networkEdgeSecurityServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkEdgeSecurityServicesClient(cc grpc.ClientConnInterface) NetworkEdgeSecurityServicesClient {
	return &networkEdgeSecurityServicesClient{cc}
}

func (c *networkEdgeSecurityServicesClient) AggregatedList(ctx context.Context, in *AggregatedListNetworkEdgeSecurityServicesRequest, opts ...grpc.CallOption) (*NetworkEdgeSecurityServiceAggregatedList, error) {
	out := new(NetworkEdgeSecurityServiceAggregatedList)
	err := c.cc.Invoke(ctx, NetworkEdgeSecurityServices_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEdgeSecurityServicesClient) Delete(ctx context.Context, in *DeleteNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEdgeSecurityServices_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEdgeSecurityServicesClient) Get(ctx context.Context, in *GetNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*NetworkEdgeSecurityService, error) {
	out := new(NetworkEdgeSecurityService)
	err := c.cc.Invoke(ctx, NetworkEdgeSecurityServices_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEdgeSecurityServicesClient) Insert(ctx context.Context, in *InsertNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEdgeSecurityServices_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEdgeSecurityServicesClient) Patch(ctx context.Context, in *PatchNetworkEdgeSecurityServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEdgeSecurityServices_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkEdgeSecurityServicesServer is the server API for NetworkEdgeSecurityServices service.
// All implementations should embed UnimplementedNetworkEdgeSecurityServicesServer
// for forward compatibility
type NetworkEdgeSecurityServicesServer interface {
	// Retrieves the list of all NetworkEdgeSecurityService resources available to
	// the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNetworkEdgeSecurityServicesRequest) (*NetworkEdgeSecurityServiceAggregatedList, error)
	// Deletes the specified service.
	Delete(context.Context, *DeleteNetworkEdgeSecurityServiceRequest) (*Operation, error)
	// Gets a specified NetworkEdgeSecurityService.
	Get(context.Context, *GetNetworkEdgeSecurityServiceRequest) (*NetworkEdgeSecurityService, error)
	// Creates a new service in the specified project using the data included in
	// the request.
	Insert(context.Context, *InsertNetworkEdgeSecurityServiceRequest) (*Operation, error)
	// Patches the specified policy with the data included in the request.
	Patch(context.Context, *PatchNetworkEdgeSecurityServiceRequest) (*Operation, error)
}

// UnimplementedNetworkEdgeSecurityServicesServer should be embedded to have forward compatible implementations.
type UnimplementedNetworkEdgeSecurityServicesServer struct {
}

func (UnimplementedNetworkEdgeSecurityServicesServer) AggregatedList(context.Context, *AggregatedListNetworkEdgeSecurityServicesRequest) (*NetworkEdgeSecurityServiceAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNetworkEdgeSecurityServicesServer) Delete(context.Context, *DeleteNetworkEdgeSecurityServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNetworkEdgeSecurityServicesServer) Get(context.Context, *GetNetworkEdgeSecurityServiceRequest) (*NetworkEdgeSecurityService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNetworkEdgeSecurityServicesServer) Insert(context.Context, *InsertNetworkEdgeSecurityServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNetworkEdgeSecurityServicesServer) Patch(context.Context, *PatchNetworkEdgeSecurityServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeNetworkEdgeSecurityServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkEdgeSecurityServicesServer will
// result in compilation errors.
type UnsafeNetworkEdgeSecurityServicesServer interface {
	mustEmbedUnimplementedNetworkEdgeSecurityServicesServer()
}

func RegisterNetworkEdgeSecurityServicesServer(s grpc.ServiceRegistrar, srv NetworkEdgeSecurityServicesServer) {
	s.RegisterService(&NetworkEdgeSecurityServices_ServiceDesc, srv)
}

func _NetworkEdgeSecurityServices_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNetworkEdgeSecurityServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEdgeSecurityServicesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEdgeSecurityServices_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEdgeSecurityServicesServer).AggregatedList(ctx, req.(*AggregatedListNetworkEdgeSecurityServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEdgeSecurityServices_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkEdgeSecurityServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEdgeSecurityServicesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEdgeSecurityServices_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEdgeSecurityServicesServer).Delete(ctx, req.(*DeleteNetworkEdgeSecurityServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEdgeSecurityServices_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkEdgeSecurityServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEdgeSecurityServicesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEdgeSecurityServices_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEdgeSecurityServicesServer).Get(ctx, req.(*GetNetworkEdgeSecurityServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEdgeSecurityServices_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNetworkEdgeSecurityServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEdgeSecurityServicesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEdgeSecurityServices_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEdgeSecurityServicesServer).Insert(ctx, req.(*InsertNetworkEdgeSecurityServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEdgeSecurityServices_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchNetworkEdgeSecurityServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEdgeSecurityServicesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEdgeSecurityServices_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEdgeSecurityServicesServer).Patch(ctx, req.(*PatchNetworkEdgeSecurityServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkEdgeSecurityServices_ServiceDesc is the grpc.ServiceDesc for NetworkEdgeSecurityServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkEdgeSecurityServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NetworkEdgeSecurityServices",
	HandlerType: (*NetworkEdgeSecurityServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _NetworkEdgeSecurityServices_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NetworkEdgeSecurityServices_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NetworkEdgeSecurityServices_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NetworkEdgeSecurityServices_Insert_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _NetworkEdgeSecurityServices_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NetworkEndpointGroups_AggregatedList_FullMethodName         = "/google.cloud.compute.v1.NetworkEndpointGroups/AggregatedList"
	NetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName = "/google.cloud.compute.v1.NetworkEndpointGroups/AttachNetworkEndpoints"
	NetworkEndpointGroups_Delete_FullMethodName                 = "/google.cloud.compute.v1.NetworkEndpointGroups/Delete"
	NetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName = "/google.cloud.compute.v1.NetworkEndpointGroups/DetachNetworkEndpoints"
	NetworkEndpointGroups_Get_FullMethodName                    = "/google.cloud.compute.v1.NetworkEndpointGroups/Get"
	NetworkEndpointGroups_Insert_FullMethodName                 = "/google.cloud.compute.v1.NetworkEndpointGroups/Insert"
	NetworkEndpointGroups_List_FullMethodName                   = "/google.cloud.compute.v1.NetworkEndpointGroups/List"
	NetworkEndpointGroups_ListNetworkEndpoints_FullMethodName   = "/google.cloud.compute.v1.NetworkEndpointGroups/ListNetworkEndpoints"
	NetworkEndpointGroups_TestIamPermissions_FullMethodName     = "/google.cloud.compute.v1.NetworkEndpointGroups/TestIamPermissions"
)

// NetworkEndpointGroupsClient is the client API for NetworkEndpointGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkEndpointGroupsClient interface {
	// Retrieves the list of network endpoint groups and sorts them by zone.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupAggregatedList, error)
	// Attach a list of network endpoints to the specified network endpoint group.
	AttachNetworkEndpoints(ctx context.Context, in *AttachNetworkEndpointsNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified network endpoint group. The network endpoints in the
	// NEG and the VM instances they belong to are not terminated when the NEG is
	// deleted. Note that the NEG cannot be deleted if there are backend services
	// referencing it.
	Delete(ctx context.Context, in *DeleteNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Detach a list of network endpoints from the specified network endpoint
	// group.
	DetachNetworkEndpoints(ctx context.Context, in *DetachNetworkEndpointsNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified network endpoint group.
	Get(ctx context.Context, in *GetNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*NetworkEndpointGroup, error)
	// Creates a network endpoint group in the specified project using the
	// parameters that are included in the request.
	Insert(ctx context.Context, in *InsertNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of network endpoint groups that are located in the
	// specified project and zone.
	List(ctx context.Context, in *ListNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupList, error)
	// Lists the network endpoints in the specified network endpoint group.
	ListNetworkEndpoints(ctx context.Context, in *ListNetworkEndpointsNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupsListNetworkEndpoints, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type networkEndpointGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkEndpointGroupsClient(cc grpc.ClientConnInterface) NetworkEndpointGroupsClient {
	return &networkEndpointGroupsClient{cc}
}

func (c *networkEndpointGroupsClient) AggregatedList(ctx context.Context, in *AggregatedListNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupAggregatedList, error) {
	out := new(NetworkEndpointGroupAggregatedList)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) AttachNetworkEndpoints(ctx context.Context, in *AttachNetworkEndpointsNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) Delete(ctx context.Context, in *DeleteNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) DetachNetworkEndpoints(ctx context.Context, in *DetachNetworkEndpointsNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) Get(ctx context.Context, in *GetNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*NetworkEndpointGroup, error) {
	out := new(NetworkEndpointGroup)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) Insert(ctx context.Context, in *InsertNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) List(ctx context.Context, in *ListNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupList, error) {
	out := new(NetworkEndpointGroupList)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) ListNetworkEndpoints(ctx context.Context, in *ListNetworkEndpointsNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupsListNetworkEndpoints, error) {
	out := new(NetworkEndpointGroupsListNetworkEndpoints)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_ListNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkEndpointGroupsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, NetworkEndpointGroups_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkEndpointGroupsServer is the server API for NetworkEndpointGroups service.
// All implementations should embed UnimplementedNetworkEndpointGroupsServer
// for forward compatibility
type NetworkEndpointGroupsServer interface {
	// Retrieves the list of network endpoint groups and sorts them by zone.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNetworkEndpointGroupsRequest) (*NetworkEndpointGroupAggregatedList, error)
	// Attach a list of network endpoints to the specified network endpoint group.
	AttachNetworkEndpoints(context.Context, *AttachNetworkEndpointsNetworkEndpointGroupRequest) (*Operation, error)
	// Deletes the specified network endpoint group. The network endpoints in the
	// NEG and the VM instances they belong to are not terminated when the NEG is
	// deleted. Note that the NEG cannot be deleted if there are backend services
	// referencing it.
	Delete(context.Context, *DeleteNetworkEndpointGroupRequest) (*Operation, error)
	// Detach a list of network endpoints from the specified network endpoint
	// group.
	DetachNetworkEndpoints(context.Context, *DetachNetworkEndpointsNetworkEndpointGroupRequest) (*Operation, error)
	// Returns the specified network endpoint group.
	Get(context.Context, *GetNetworkEndpointGroupRequest) (*NetworkEndpointGroup, error)
	// Creates a network endpoint group in the specified project using the
	// parameters that are included in the request.
	Insert(context.Context, *InsertNetworkEndpointGroupRequest) (*Operation, error)
	// Retrieves the list of network endpoint groups that are located in the
	// specified project and zone.
	List(context.Context, *ListNetworkEndpointGroupsRequest) (*NetworkEndpointGroupList, error)
	// Lists the network endpoints in the specified network endpoint group.
	ListNetworkEndpoints(context.Context, *ListNetworkEndpointsNetworkEndpointGroupsRequest) (*NetworkEndpointGroupsListNetworkEndpoints, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsNetworkEndpointGroupRequest) (*TestPermissionsResponse, error)
}

// UnimplementedNetworkEndpointGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedNetworkEndpointGroupsServer struct {
}

func (UnimplementedNetworkEndpointGroupsServer) AggregatedList(context.Context, *AggregatedListNetworkEndpointGroupsRequest) (*NetworkEndpointGroupAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) AttachNetworkEndpoints(context.Context, *AttachNetworkEndpointsNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachNetworkEndpoints not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) Delete(context.Context, *DeleteNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) DetachNetworkEndpoints(context.Context, *DetachNetworkEndpointsNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachNetworkEndpoints not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) Get(context.Context, *GetNetworkEndpointGroupRequest) (*NetworkEndpointGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) Insert(context.Context, *InsertNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) List(context.Context, *ListNetworkEndpointGroupsRequest) (*NetworkEndpointGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) ListNetworkEndpoints(context.Context, *ListNetworkEndpointsNetworkEndpointGroupsRequest) (*NetworkEndpointGroupsListNetworkEndpoints, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworkEndpoints not implemented")
}
func (UnimplementedNetworkEndpointGroupsServer) TestIamPermissions(context.Context, *TestIamPermissionsNetworkEndpointGroupRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeNetworkEndpointGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkEndpointGroupsServer will
// result in compilation errors.
type UnsafeNetworkEndpointGroupsServer interface {
	mustEmbedUnimplementedNetworkEndpointGroupsServer()
}

func RegisterNetworkEndpointGroupsServer(s grpc.ServiceRegistrar, srv NetworkEndpointGroupsServer) {
	s.RegisterService(&NetworkEndpointGroups_ServiceDesc, srv)
}

func _NetworkEndpointGroups_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).AggregatedList(ctx, req.(*AggregatedListNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_AttachNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNetworkEndpointsNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).AttachNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).AttachNetworkEndpoints(ctx, req.(*AttachNetworkEndpointsNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).Delete(ctx, req.(*DeleteNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_DetachNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNetworkEndpointsNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).DetachNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).DetachNetworkEndpoints(ctx, req.(*DetachNetworkEndpointsNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).Get(ctx, req.(*GetNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).Insert(ctx, req.(*InsertNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).List(ctx, req.(*ListNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_ListNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkEndpointsNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).ListNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_ListNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).ListNetworkEndpoints(ctx, req.(*ListNetworkEndpointsNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkEndpointGroups_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkEndpointGroupsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkEndpointGroups_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkEndpointGroupsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkEndpointGroups_ServiceDesc is the grpc.ServiceDesc for NetworkEndpointGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkEndpointGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NetworkEndpointGroups",
	HandlerType: (*NetworkEndpointGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _NetworkEndpointGroups_AggregatedList_Handler,
		},
		{
			MethodName: "AttachNetworkEndpoints",
			Handler:    _NetworkEndpointGroups_AttachNetworkEndpoints_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NetworkEndpointGroups_Delete_Handler,
		},
		{
			MethodName: "DetachNetworkEndpoints",
			Handler:    _NetworkEndpointGroups_DetachNetworkEndpoints_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NetworkEndpointGroups_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NetworkEndpointGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NetworkEndpointGroups_List_Handler,
		},
		{
			MethodName: "ListNetworkEndpoints",
			Handler:    _NetworkEndpointGroups_ListNetworkEndpoints_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _NetworkEndpointGroups_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NetworkFirewallPolicies_AddAssociation_FullMethodName            = "/google.cloud.compute.v1.NetworkFirewallPolicies/AddAssociation"
	NetworkFirewallPolicies_AddPacketMirroringRule_FullMethodName    = "/google.cloud.compute.v1.NetworkFirewallPolicies/AddPacketMirroringRule"
	NetworkFirewallPolicies_AddRule_FullMethodName                   = "/google.cloud.compute.v1.NetworkFirewallPolicies/AddRule"
	NetworkFirewallPolicies_AggregatedList_FullMethodName            = "/google.cloud.compute.v1.NetworkFirewallPolicies/AggregatedList"
	NetworkFirewallPolicies_CloneRules_FullMethodName                = "/google.cloud.compute.v1.NetworkFirewallPolicies/CloneRules"
	NetworkFirewallPolicies_Delete_FullMethodName                    = "/google.cloud.compute.v1.NetworkFirewallPolicies/Delete"
	NetworkFirewallPolicies_Get_FullMethodName                       = "/google.cloud.compute.v1.NetworkFirewallPolicies/Get"
	NetworkFirewallPolicies_GetAssociation_FullMethodName            = "/google.cloud.compute.v1.NetworkFirewallPolicies/GetAssociation"
	NetworkFirewallPolicies_GetIamPolicy_FullMethodName              = "/google.cloud.compute.v1.NetworkFirewallPolicies/GetIamPolicy"
	NetworkFirewallPolicies_GetPacketMirroringRule_FullMethodName    = "/google.cloud.compute.v1.NetworkFirewallPolicies/GetPacketMirroringRule"
	NetworkFirewallPolicies_GetRule_FullMethodName                   = "/google.cloud.compute.v1.NetworkFirewallPolicies/GetRule"
	NetworkFirewallPolicies_Insert_FullMethodName                    = "/google.cloud.compute.v1.NetworkFirewallPolicies/Insert"
	NetworkFirewallPolicies_List_FullMethodName                      = "/google.cloud.compute.v1.NetworkFirewallPolicies/List"
	NetworkFirewallPolicies_Patch_FullMethodName                     = "/google.cloud.compute.v1.NetworkFirewallPolicies/Patch"
	NetworkFirewallPolicies_PatchPacketMirroringRule_FullMethodName  = "/google.cloud.compute.v1.NetworkFirewallPolicies/PatchPacketMirroringRule"
	NetworkFirewallPolicies_PatchRule_FullMethodName                 = "/google.cloud.compute.v1.NetworkFirewallPolicies/PatchRule"
	NetworkFirewallPolicies_RemoveAssociation_FullMethodName         = "/google.cloud.compute.v1.NetworkFirewallPolicies/RemoveAssociation"
	NetworkFirewallPolicies_RemovePacketMirroringRule_FullMethodName = "/google.cloud.compute.v1.NetworkFirewallPolicies/RemovePacketMirroringRule"
	NetworkFirewallPolicies_RemoveRule_FullMethodName                = "/google.cloud.compute.v1.NetworkFirewallPolicies/RemoveRule"
	NetworkFirewallPolicies_SetIamPolicy_FullMethodName              = "/google.cloud.compute.v1.NetworkFirewallPolicies/SetIamPolicy"
	NetworkFirewallPolicies_TestIamPermissions_FullMethodName        = "/google.cloud.compute.v1.NetworkFirewallPolicies/TestIamPermissions"
)

// NetworkFirewallPoliciesClient is the client API for NetworkFirewallPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkFirewallPoliciesClient interface {
	// Inserts an association for the specified firewall policy.
	AddAssociation(ctx context.Context, in *AddAssociationNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts a packet mirroring rule into a firewall policy.
	AddPacketMirroringRule(ctx context.Context, in *AddPacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts a rule into a firewall policy.
	AddRule(ctx context.Context, in *AddRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves an aggregated list of network firewall policies, listing network
	// firewall policies from all applicable scopes (global and regional) and
	// grouping the results per scope.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNetworkFirewallPoliciesRequest, opts ...grpc.CallOption) (*NetworkFirewallPolicyAggregatedList, error)
	// Copies rules to the specified firewall policy.
	CloneRules(ctx context.Context, in *CloneRulesNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified policy.
	Delete(ctx context.Context, in *DeleteNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified network firewall policy.
	Get(ctx context.Context, in *GetNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicy, error)
	// Gets an association with the specified name.
	GetAssociation(ctx context.Context, in *GetAssociationNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyAssociation, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Gets a packet mirroring rule of the specified priority.
	GetPacketMirroringRule(ctx context.Context, in *GetPacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error)
	// Gets a rule of the specified priority.
	GetRule(ctx context.Context, in *GetRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(ctx context.Context, in *InsertNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all the policies that have been configured for the specified project.
	List(ctx context.Context, in *ListNetworkFirewallPoliciesRequest, opts ...grpc.CallOption) (*FirewallPolicyList, error)
	// Patches the specified policy with the data included in the request.
	Patch(ctx context.Context, in *PatchNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a packet mirroring rule of the specified priority.
	PatchPacketMirroringRule(ctx context.Context, in *PatchPacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a rule of the specified priority.
	PatchRule(ctx context.Context, in *PatchRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes an association for the specified firewall policy.
	RemoveAssociation(ctx context.Context, in *RemoveAssociationNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a packet mirroring rule of the specified priority.
	RemovePacketMirroringRule(ctx context.Context, in *RemovePacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a rule of the specified priority.
	RemoveRule(ctx context.Context, in *RemoveRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type networkFirewallPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkFirewallPoliciesClient(cc grpc.ClientConnInterface) NetworkFirewallPoliciesClient {
	return &networkFirewallPoliciesClient{cc}
}

func (c *networkFirewallPoliciesClient) AddAssociation(ctx context.Context, in *AddAssociationNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_AddAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) AddPacketMirroringRule(ctx context.Context, in *AddPacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_AddPacketMirroringRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) AddRule(ctx context.Context, in *AddRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_AddRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) AggregatedList(ctx context.Context, in *AggregatedListNetworkFirewallPoliciesRequest, opts ...grpc.CallOption) (*NetworkFirewallPolicyAggregatedList, error) {
	out := new(NetworkFirewallPolicyAggregatedList)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) CloneRules(ctx context.Context, in *CloneRulesNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_CloneRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) Delete(ctx context.Context, in *DeleteNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) Get(ctx context.Context, in *GetNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicy, error) {
	out := new(FirewallPolicy)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) GetAssociation(ctx context.Context, in *GetAssociationNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyAssociation, error) {
	out := new(FirewallPolicyAssociation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_GetAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) GetPacketMirroringRule(ctx context.Context, in *GetPacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error) {
	out := new(FirewallPolicyRule)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_GetPacketMirroringRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) GetRule(ctx context.Context, in *GetRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error) {
	out := new(FirewallPolicyRule)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_GetRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) Insert(ctx context.Context, in *InsertNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) List(ctx context.Context, in *ListNetworkFirewallPoliciesRequest, opts ...grpc.CallOption) (*FirewallPolicyList, error) {
	out := new(FirewallPolicyList)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) Patch(ctx context.Context, in *PatchNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) PatchPacketMirroringRule(ctx context.Context, in *PatchPacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_PatchPacketMirroringRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) PatchRule(ctx context.Context, in *PatchRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_PatchRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) RemoveAssociation(ctx context.Context, in *RemoveAssociationNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_RemoveAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) RemovePacketMirroringRule(ctx context.Context, in *RemovePacketMirroringRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_RemovePacketMirroringRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) RemoveRule(ctx context.Context, in *RemoveRuleNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_RemoveRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkFirewallPoliciesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, NetworkFirewallPolicies_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkFirewallPoliciesServer is the server API for NetworkFirewallPolicies service.
// All implementations should embed UnimplementedNetworkFirewallPoliciesServer
// for forward compatibility
type NetworkFirewallPoliciesServer interface {
	// Inserts an association for the specified firewall policy.
	AddAssociation(context.Context, *AddAssociationNetworkFirewallPolicyRequest) (*Operation, error)
	// Inserts a packet mirroring rule into a firewall policy.
	AddPacketMirroringRule(context.Context, *AddPacketMirroringRuleNetworkFirewallPolicyRequest) (*Operation, error)
	// Inserts a rule into a firewall policy.
	AddRule(context.Context, *AddRuleNetworkFirewallPolicyRequest) (*Operation, error)
	// Retrieves an aggregated list of network firewall policies, listing network
	// firewall policies from all applicable scopes (global and regional) and
	// grouping the results per scope.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNetworkFirewallPoliciesRequest) (*NetworkFirewallPolicyAggregatedList, error)
	// Copies rules to the specified firewall policy.
	CloneRules(context.Context, *CloneRulesNetworkFirewallPolicyRequest) (*Operation, error)
	// Deletes the specified policy.
	Delete(context.Context, *DeleteNetworkFirewallPolicyRequest) (*Operation, error)
	// Returns the specified network firewall policy.
	Get(context.Context, *GetNetworkFirewallPolicyRequest) (*FirewallPolicy, error)
	// Gets an association with the specified name.
	GetAssociation(context.Context, *GetAssociationNetworkFirewallPolicyRequest) (*FirewallPolicyAssociation, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyNetworkFirewallPolicyRequest) (*Policy, error)
	// Gets a packet mirroring rule of the specified priority.
	GetPacketMirroringRule(context.Context, *GetPacketMirroringRuleNetworkFirewallPolicyRequest) (*FirewallPolicyRule, error)
	// Gets a rule of the specified priority.
	GetRule(context.Context, *GetRuleNetworkFirewallPolicyRequest) (*FirewallPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(context.Context, *InsertNetworkFirewallPolicyRequest) (*Operation, error)
	// Lists all the policies that have been configured for the specified project.
	List(context.Context, *ListNetworkFirewallPoliciesRequest) (*FirewallPolicyList, error)
	// Patches the specified policy with the data included in the request.
	Patch(context.Context, *PatchNetworkFirewallPolicyRequest) (*Operation, error)
	// Patches a packet mirroring rule of the specified priority.
	PatchPacketMirroringRule(context.Context, *PatchPacketMirroringRuleNetworkFirewallPolicyRequest) (*Operation, error)
	// Patches a rule of the specified priority.
	PatchRule(context.Context, *PatchRuleNetworkFirewallPolicyRequest) (*Operation, error)
	// Removes an association for the specified firewall policy.
	RemoveAssociation(context.Context, *RemoveAssociationNetworkFirewallPolicyRequest) (*Operation, error)
	// Deletes a packet mirroring rule of the specified priority.
	RemovePacketMirroringRule(context.Context, *RemovePacketMirroringRuleNetworkFirewallPolicyRequest) (*Operation, error)
	// Deletes a rule of the specified priority.
	RemoveRule(context.Context, *RemoveRuleNetworkFirewallPolicyRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyNetworkFirewallPolicyRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsNetworkFirewallPolicyRequest) (*TestPermissionsResponse, error)
}

// UnimplementedNetworkFirewallPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedNetworkFirewallPoliciesServer struct {
}

func (UnimplementedNetworkFirewallPoliciesServer) AddAssociation(context.Context, *AddAssociationNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAssociation not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) AddPacketMirroringRule(context.Context, *AddPacketMirroringRuleNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPacketMirroringRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) AddRule(context.Context, *AddRuleNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) AggregatedList(context.Context, *AggregatedListNetworkFirewallPoliciesRequest) (*NetworkFirewallPolicyAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) CloneRules(context.Context, *CloneRulesNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloneRules not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) Delete(context.Context, *DeleteNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) Get(context.Context, *GetNetworkFirewallPolicyRequest) (*FirewallPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) GetAssociation(context.Context, *GetAssociationNetworkFirewallPolicyRequest) (*FirewallPolicyAssociation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssociation not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) GetIamPolicy(context.Context, *GetIamPolicyNetworkFirewallPolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) GetPacketMirroringRule(context.Context, *GetPacketMirroringRuleNetworkFirewallPolicyRequest) (*FirewallPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPacketMirroringRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) GetRule(context.Context, *GetRuleNetworkFirewallPolicyRequest) (*FirewallPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) Insert(context.Context, *InsertNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) List(context.Context, *ListNetworkFirewallPoliciesRequest) (*FirewallPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) Patch(context.Context, *PatchNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) PatchPacketMirroringRule(context.Context, *PatchPacketMirroringRuleNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchPacketMirroringRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) PatchRule(context.Context, *PatchRuleNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) RemoveAssociation(context.Context, *RemoveAssociationNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAssociation not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) RemovePacketMirroringRule(context.Context, *RemovePacketMirroringRuleNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePacketMirroringRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) RemoveRule(context.Context, *RemoveRuleNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) SetIamPolicy(context.Context, *SetIamPolicyNetworkFirewallPolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedNetworkFirewallPoliciesServer) TestIamPermissions(context.Context, *TestIamPermissionsNetworkFirewallPolicyRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeNetworkFirewallPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkFirewallPoliciesServer will
// result in compilation errors.
type UnsafeNetworkFirewallPoliciesServer interface {
	mustEmbedUnimplementedNetworkFirewallPoliciesServer()
}

func RegisterNetworkFirewallPoliciesServer(s grpc.ServiceRegistrar, srv NetworkFirewallPoliciesServer) {
	s.RegisterService(&NetworkFirewallPolicies_ServiceDesc, srv)
}

func _NetworkFirewallPolicies_AddAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAssociationNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).AddAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_AddAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).AddAssociation(ctx, req.(*AddAssociationNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_AddPacketMirroringRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPacketMirroringRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).AddPacketMirroringRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_AddPacketMirroringRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).AddPacketMirroringRule(ctx, req.(*AddPacketMirroringRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).AddRule(ctx, req.(*AddRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNetworkFirewallPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).AggregatedList(ctx, req.(*AggregatedListNetworkFirewallPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_CloneRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneRulesNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).CloneRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_CloneRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).CloneRules(ctx, req.(*CloneRulesNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).Delete(ctx, req.(*DeleteNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).Get(ctx, req.(*GetNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_GetAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssociationNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).GetAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_GetAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).GetAssociation(ctx, req.(*GetAssociationNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).GetIamPolicy(ctx, req.(*GetIamPolicyNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_GetPacketMirroringRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPacketMirroringRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).GetPacketMirroringRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_GetPacketMirroringRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).GetPacketMirroringRule(ctx, req.(*GetPacketMirroringRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).GetRule(ctx, req.(*GetRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).Insert(ctx, req.(*InsertNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkFirewallPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).List(ctx, req.(*ListNetworkFirewallPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).Patch(ctx, req.(*PatchNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_PatchPacketMirroringRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPacketMirroringRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).PatchPacketMirroringRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_PatchPacketMirroringRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).PatchPacketMirroringRule(ctx, req.(*PatchPacketMirroringRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_PatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).PatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_PatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).PatchRule(ctx, req.(*PatchRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_RemoveAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveAssociationNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).RemoveAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_RemoveAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).RemoveAssociation(ctx, req.(*RemoveAssociationNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_RemovePacketMirroringRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePacketMirroringRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).RemovePacketMirroringRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_RemovePacketMirroringRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).RemovePacketMirroringRule(ctx, req.(*RemovePacketMirroringRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).RemoveRule(ctx, req.(*RemoveRuleNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).SetIamPolicy(ctx, req.(*SetIamPolicyNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkFirewallPolicies_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkFirewallPoliciesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkFirewallPolicies_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkFirewallPoliciesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkFirewallPolicies_ServiceDesc is the grpc.ServiceDesc for NetworkFirewallPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkFirewallPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NetworkFirewallPolicies",
	HandlerType: (*NetworkFirewallPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddAssociation",
			Handler:    _NetworkFirewallPolicies_AddAssociation_Handler,
		},
		{
			MethodName: "AddPacketMirroringRule",
			Handler:    _NetworkFirewallPolicies_AddPacketMirroringRule_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _NetworkFirewallPolicies_AddRule_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _NetworkFirewallPolicies_AggregatedList_Handler,
		},
		{
			MethodName: "CloneRules",
			Handler:    _NetworkFirewallPolicies_CloneRules_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NetworkFirewallPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NetworkFirewallPolicies_Get_Handler,
		},
		{
			MethodName: "GetAssociation",
			Handler:    _NetworkFirewallPolicies_GetAssociation_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _NetworkFirewallPolicies_GetIamPolicy_Handler,
		},
		{
			MethodName: "GetPacketMirroringRule",
			Handler:    _NetworkFirewallPolicies_GetPacketMirroringRule_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _NetworkFirewallPolicies_GetRule_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NetworkFirewallPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NetworkFirewallPolicies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _NetworkFirewallPolicies_Patch_Handler,
		},
		{
			MethodName: "PatchPacketMirroringRule",
			Handler:    _NetworkFirewallPolicies_PatchPacketMirroringRule_Handler,
		},
		{
			MethodName: "PatchRule",
			Handler:    _NetworkFirewallPolicies_PatchRule_Handler,
		},
		{
			MethodName: "RemoveAssociation",
			Handler:    _NetworkFirewallPolicies_RemoveAssociation_Handler,
		},
		{
			MethodName: "RemovePacketMirroringRule",
			Handler:    _NetworkFirewallPolicies_RemovePacketMirroringRule_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _NetworkFirewallPolicies_RemoveRule_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _NetworkFirewallPolicies_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _NetworkFirewallPolicies_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NetworkProfiles_Get_FullMethodName  = "/google.cloud.compute.v1.NetworkProfiles/Get"
	NetworkProfiles_List_FullMethodName = "/google.cloud.compute.v1.NetworkProfiles/List"
)

// NetworkProfilesClient is the client API for NetworkProfiles service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworkProfilesClient interface {
	// Returns the specified network profile.
	Get(ctx context.Context, in *GetNetworkProfileRequest, opts ...grpc.CallOption) (*NetworkProfile, error)
	// Retrieves a list of network profiles available to the specified
	// project.
	List(ctx context.Context, in *ListNetworkProfilesRequest, opts ...grpc.CallOption) (*NetworkProfilesListResponse, error)
}

type networkProfilesClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworkProfilesClient(cc grpc.ClientConnInterface) NetworkProfilesClient {
	return &networkProfilesClient{cc}
}

func (c *networkProfilesClient) Get(ctx context.Context, in *GetNetworkProfileRequest, opts ...grpc.CallOption) (*NetworkProfile, error) {
	out := new(NetworkProfile)
	err := c.cc.Invoke(ctx, NetworkProfiles_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networkProfilesClient) List(ctx context.Context, in *ListNetworkProfilesRequest, opts ...grpc.CallOption) (*NetworkProfilesListResponse, error) {
	out := new(NetworkProfilesListResponse)
	err := c.cc.Invoke(ctx, NetworkProfiles_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworkProfilesServer is the server API for NetworkProfiles service.
// All implementations should embed UnimplementedNetworkProfilesServer
// for forward compatibility
type NetworkProfilesServer interface {
	// Returns the specified network profile.
	Get(context.Context, *GetNetworkProfileRequest) (*NetworkProfile, error)
	// Retrieves a list of network profiles available to the specified
	// project.
	List(context.Context, *ListNetworkProfilesRequest) (*NetworkProfilesListResponse, error)
}

// UnimplementedNetworkProfilesServer should be embedded to have forward compatible implementations.
type UnimplementedNetworkProfilesServer struct {
}

func (UnimplementedNetworkProfilesServer) Get(context.Context, *GetNetworkProfileRequest) (*NetworkProfile, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNetworkProfilesServer) List(context.Context, *ListNetworkProfilesRequest) (*NetworkProfilesListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeNetworkProfilesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworkProfilesServer will
// result in compilation errors.
type UnsafeNetworkProfilesServer interface {
	mustEmbedUnimplementedNetworkProfilesServer()
}

func RegisterNetworkProfilesServer(s grpc.ServiceRegistrar, srv NetworkProfilesServer) {
	s.RegisterService(&NetworkProfiles_ServiceDesc, srv)
}

func _NetworkProfiles_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkProfileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkProfilesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkProfiles_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkProfilesServer).Get(ctx, req.(*GetNetworkProfileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NetworkProfiles_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkProfilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworkProfilesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NetworkProfiles_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworkProfilesServer).List(ctx, req.(*ListNetworkProfilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NetworkProfiles_ServiceDesc is the grpc.ServiceDesc for NetworkProfiles service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NetworkProfiles_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NetworkProfiles",
	HandlerType: (*NetworkProfilesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _NetworkProfiles_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NetworkProfiles_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Networks_AddPeering_FullMethodName            = "/google.cloud.compute.v1.Networks/AddPeering"
	Networks_Delete_FullMethodName                = "/google.cloud.compute.v1.Networks/Delete"
	Networks_Get_FullMethodName                   = "/google.cloud.compute.v1.Networks/Get"
	Networks_GetEffectiveFirewalls_FullMethodName = "/google.cloud.compute.v1.Networks/GetEffectiveFirewalls"
	Networks_Insert_FullMethodName                = "/google.cloud.compute.v1.Networks/Insert"
	Networks_List_FullMethodName                  = "/google.cloud.compute.v1.Networks/List"
	Networks_ListPeeringRoutes_FullMethodName     = "/google.cloud.compute.v1.Networks/ListPeeringRoutes"
	Networks_Patch_FullMethodName                 = "/google.cloud.compute.v1.Networks/Patch"
	Networks_RemovePeering_FullMethodName         = "/google.cloud.compute.v1.Networks/RemovePeering"
	Networks_RequestRemovePeering_FullMethodName  = "/google.cloud.compute.v1.Networks/RequestRemovePeering"
	Networks_SwitchToCustomMode_FullMethodName    = "/google.cloud.compute.v1.Networks/SwitchToCustomMode"
	Networks_UpdatePeering_FullMethodName         = "/google.cloud.compute.v1.Networks/UpdatePeering"
)

// NetworksClient is the client API for Networks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NetworksClient interface {
	// Adds a peering to the specified network.
	AddPeering(ctx context.Context, in *AddPeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified network.
	Delete(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified network.
	Get(ctx context.Context, in *GetNetworkRequest, opts ...grpc.CallOption) (*Network, error)
	// Returns the effective firewalls on a given network.
	GetEffectiveFirewalls(ctx context.Context, in *GetEffectiveFirewallsNetworkRequest, opts ...grpc.CallOption) (*NetworksGetEffectiveFirewallsResponse, error)
	// Creates a network in the specified project using the data included
	// in the request.
	Insert(ctx context.Context, in *InsertNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of networks available to the specified project.
	List(ctx context.Context, in *ListNetworksRequest, opts ...grpc.CallOption) (*NetworkList, error)
	// Lists the peering routes exchanged over peering connection.
	ListPeeringRoutes(ctx context.Context, in *ListPeeringRoutesNetworksRequest, opts ...grpc.CallOption) (*ExchangedPeeringRoutesList, error)
	// Patches the specified network with the data included in the request.
	// Only routingConfig can be modified.
	Patch(ctx context.Context, in *PatchNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes a peering from the specified network.
	RemovePeering(ctx context.Context, in *RemovePeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Requests to remove a peering from the specified network. Applicable only
	// for PeeringConnection with update_strategy=CONSENSUS.
	RequestRemovePeering(ctx context.Context, in *RequestRemovePeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Switches the network mode from auto subnet mode to custom subnet mode.
	SwitchToCustomMode(ctx context.Context, in *SwitchToCustomModeNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates the specified network peering with the data included in the
	// request. You can only modify the NetworkPeering.export_custom_routes field
	// and the NetworkPeering.import_custom_routes field.
	UpdatePeering(ctx context.Context, in *UpdatePeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error)
}

type networksClient struct {
	cc grpc.ClientConnInterface
}

func NewNetworksClient(cc grpc.ClientConnInterface) NetworksClient {
	return &networksClient{cc}
}

func (c *networksClient) AddPeering(ctx context.Context, in *AddPeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_AddPeering_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) Delete(ctx context.Context, in *DeleteNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) Get(ctx context.Context, in *GetNetworkRequest, opts ...grpc.CallOption) (*Network, error) {
	out := new(Network)
	err := c.cc.Invoke(ctx, Networks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) GetEffectiveFirewalls(ctx context.Context, in *GetEffectiveFirewallsNetworkRequest, opts ...grpc.CallOption) (*NetworksGetEffectiveFirewallsResponse, error) {
	out := new(NetworksGetEffectiveFirewallsResponse)
	err := c.cc.Invoke(ctx, Networks_GetEffectiveFirewalls_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) Insert(ctx context.Context, in *InsertNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) List(ctx context.Context, in *ListNetworksRequest, opts ...grpc.CallOption) (*NetworkList, error) {
	out := new(NetworkList)
	err := c.cc.Invoke(ctx, Networks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) ListPeeringRoutes(ctx context.Context, in *ListPeeringRoutesNetworksRequest, opts ...grpc.CallOption) (*ExchangedPeeringRoutesList, error) {
	out := new(ExchangedPeeringRoutesList)
	err := c.cc.Invoke(ctx, Networks_ListPeeringRoutes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) Patch(ctx context.Context, in *PatchNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) RemovePeering(ctx context.Context, in *RemovePeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_RemovePeering_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) RequestRemovePeering(ctx context.Context, in *RequestRemovePeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_RequestRemovePeering_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) SwitchToCustomMode(ctx context.Context, in *SwitchToCustomModeNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_SwitchToCustomMode_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *networksClient) UpdatePeering(ctx context.Context, in *UpdatePeeringNetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Networks_UpdatePeering_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NetworksServer is the server API for Networks service.
// All implementations should embed UnimplementedNetworksServer
// for forward compatibility
type NetworksServer interface {
	// Adds a peering to the specified network.
	AddPeering(context.Context, *AddPeeringNetworkRequest) (*Operation, error)
	// Deletes the specified network.
	Delete(context.Context, *DeleteNetworkRequest) (*Operation, error)
	// Returns the specified network.
	Get(context.Context, *GetNetworkRequest) (*Network, error)
	// Returns the effective firewalls on a given network.
	GetEffectiveFirewalls(context.Context, *GetEffectiveFirewallsNetworkRequest) (*NetworksGetEffectiveFirewallsResponse, error)
	// Creates a network in the specified project using the data included
	// in the request.
	Insert(context.Context, *InsertNetworkRequest) (*Operation, error)
	// Retrieves the list of networks available to the specified project.
	List(context.Context, *ListNetworksRequest) (*NetworkList, error)
	// Lists the peering routes exchanged over peering connection.
	ListPeeringRoutes(context.Context, *ListPeeringRoutesNetworksRequest) (*ExchangedPeeringRoutesList, error)
	// Patches the specified network with the data included in the request.
	// Only routingConfig can be modified.
	Patch(context.Context, *PatchNetworkRequest) (*Operation, error)
	// Removes a peering from the specified network.
	RemovePeering(context.Context, *RemovePeeringNetworkRequest) (*Operation, error)
	// Requests to remove a peering from the specified network. Applicable only
	// for PeeringConnection with update_strategy=CONSENSUS.
	RequestRemovePeering(context.Context, *RequestRemovePeeringNetworkRequest) (*Operation, error)
	// Switches the network mode from auto subnet mode to custom subnet mode.
	SwitchToCustomMode(context.Context, *SwitchToCustomModeNetworkRequest) (*Operation, error)
	// Updates the specified network peering with the data included in the
	// request. You can only modify the NetworkPeering.export_custom_routes field
	// and the NetworkPeering.import_custom_routes field.
	UpdatePeering(context.Context, *UpdatePeeringNetworkRequest) (*Operation, error)
}

// UnimplementedNetworksServer should be embedded to have forward compatible implementations.
type UnimplementedNetworksServer struct {
}

func (UnimplementedNetworksServer) AddPeering(context.Context, *AddPeeringNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddPeering not implemented")
}
func (UnimplementedNetworksServer) Delete(context.Context, *DeleteNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNetworksServer) Get(context.Context, *GetNetworkRequest) (*Network, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNetworksServer) GetEffectiveFirewalls(context.Context, *GetEffectiveFirewallsNetworkRequest) (*NetworksGetEffectiveFirewallsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEffectiveFirewalls not implemented")
}
func (UnimplementedNetworksServer) Insert(context.Context, *InsertNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNetworksServer) List(context.Context, *ListNetworksRequest) (*NetworkList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedNetworksServer) ListPeeringRoutes(context.Context, *ListPeeringRoutesNetworksRequest) (*ExchangedPeeringRoutesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPeeringRoutes not implemented")
}
func (UnimplementedNetworksServer) Patch(context.Context, *PatchNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedNetworksServer) RemovePeering(context.Context, *RemovePeeringNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemovePeering not implemented")
}
func (UnimplementedNetworksServer) RequestRemovePeering(context.Context, *RequestRemovePeeringNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RequestRemovePeering not implemented")
}
func (UnimplementedNetworksServer) SwitchToCustomMode(context.Context, *SwitchToCustomModeNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SwitchToCustomMode not implemented")
}
func (UnimplementedNetworksServer) UpdatePeering(context.Context, *UpdatePeeringNetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePeering not implemented")
}

// UnsafeNetworksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NetworksServer will
// result in compilation errors.
type UnsafeNetworksServer interface {
	mustEmbedUnimplementedNetworksServer()
}

func RegisterNetworksServer(s grpc.ServiceRegistrar, srv NetworksServer) {
	s.RegisterService(&Networks_ServiceDesc, srv)
}

func _Networks_AddPeering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddPeeringNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).AddPeering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_AddPeering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).AddPeering(ctx, req.(*AddPeeringNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).Delete(ctx, req.(*DeleteNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).Get(ctx, req.(*GetNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_GetEffectiveFirewalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEffectiveFirewallsNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).GetEffectiveFirewalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_GetEffectiveFirewalls_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).GetEffectiveFirewalls(ctx, req.(*GetEffectiveFirewallsNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).Insert(ctx, req.(*InsertNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).List(ctx, req.(*ListNetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_ListPeeringRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPeeringRoutesNetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).ListPeeringRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_ListPeeringRoutes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).ListPeeringRoutes(ctx, req.(*ListPeeringRoutesNetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).Patch(ctx, req.(*PatchNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_RemovePeering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemovePeeringNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).RemovePeering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_RemovePeering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).RemovePeering(ctx, req.(*RemovePeeringNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_RequestRemovePeering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RequestRemovePeeringNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).RequestRemovePeering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_RequestRemovePeering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).RequestRemovePeering(ctx, req.(*RequestRemovePeeringNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_SwitchToCustomMode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SwitchToCustomModeNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).SwitchToCustomMode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_SwitchToCustomMode_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).SwitchToCustomMode(ctx, req.(*SwitchToCustomModeNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Networks_UpdatePeering_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePeeringNetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NetworksServer).UpdatePeering(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Networks_UpdatePeering_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NetworksServer).UpdatePeering(ctx, req.(*UpdatePeeringNetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Networks_ServiceDesc is the grpc.ServiceDesc for Networks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Networks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Networks",
	HandlerType: (*NetworksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddPeering",
			Handler:    _Networks_AddPeering_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Networks_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Networks_Get_Handler,
		},
		{
			MethodName: "GetEffectiveFirewalls",
			Handler:    _Networks_GetEffectiveFirewalls_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Networks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Networks_List_Handler,
		},
		{
			MethodName: "ListPeeringRoutes",
			Handler:    _Networks_ListPeeringRoutes_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Networks_Patch_Handler,
		},
		{
			MethodName: "RemovePeering",
			Handler:    _Networks_RemovePeering_Handler,
		},
		{
			MethodName: "RequestRemovePeering",
			Handler:    _Networks_RequestRemovePeering_Handler,
		},
		{
			MethodName: "SwitchToCustomMode",
			Handler:    _Networks_SwitchToCustomMode_Handler,
		},
		{
			MethodName: "UpdatePeering",
			Handler:    _Networks_UpdatePeering_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NodeGroups_AddNodes_FullMethodName                 = "/google.cloud.compute.v1.NodeGroups/AddNodes"
	NodeGroups_AggregatedList_FullMethodName           = "/google.cloud.compute.v1.NodeGroups/AggregatedList"
	NodeGroups_Delete_FullMethodName                   = "/google.cloud.compute.v1.NodeGroups/Delete"
	NodeGroups_DeleteNodes_FullMethodName              = "/google.cloud.compute.v1.NodeGroups/DeleteNodes"
	NodeGroups_Get_FullMethodName                      = "/google.cloud.compute.v1.NodeGroups/Get"
	NodeGroups_GetIamPolicy_FullMethodName             = "/google.cloud.compute.v1.NodeGroups/GetIamPolicy"
	NodeGroups_Insert_FullMethodName                   = "/google.cloud.compute.v1.NodeGroups/Insert"
	NodeGroups_List_FullMethodName                     = "/google.cloud.compute.v1.NodeGroups/List"
	NodeGroups_ListNodes_FullMethodName                = "/google.cloud.compute.v1.NodeGroups/ListNodes"
	NodeGroups_Patch_FullMethodName                    = "/google.cloud.compute.v1.NodeGroups/Patch"
	NodeGroups_PerformMaintenance_FullMethodName       = "/google.cloud.compute.v1.NodeGroups/PerformMaintenance"
	NodeGroups_SetIamPolicy_FullMethodName             = "/google.cloud.compute.v1.NodeGroups/SetIamPolicy"
	NodeGroups_SetNodeTemplate_FullMethodName          = "/google.cloud.compute.v1.NodeGroups/SetNodeTemplate"
	NodeGroups_SimulateMaintenanceEvent_FullMethodName = "/google.cloud.compute.v1.NodeGroups/SimulateMaintenanceEvent"
	NodeGroups_TestIamPermissions_FullMethodName       = "/google.cloud.compute.v1.NodeGroups/TestIamPermissions"
)

// NodeGroupsClient is the client API for NodeGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeGroupsClient interface {
	// Adds specified number of nodes to the node group.
	AddNodes(ctx context.Context, in *AddNodesNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves an aggregated list of node groups.
	// Note: use nodeGroups.listNodes for more details about each group.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNodeGroupsRequest, opts ...grpc.CallOption) (*NodeGroupAggregatedList, error)
	// Deletes the specified NodeGroup resource.
	Delete(ctx context.Context, in *DeleteNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes specified nodes from the node group.
	DeleteNodes(ctx context.Context, in *DeleteNodesNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified NodeGroup. Get a list of available NodeGroups
	// by making a list() request.
	// Note: the "nodes" field should not be used. Use nodeGroups.listNodes
	// instead.
	Get(ctx context.Context, in *GetNodeGroupRequest, opts ...grpc.CallOption) (*NodeGroup, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyNodeGroupRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a NodeGroup resource in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of node groups available to the specified project.
	// Note: use nodeGroups.listNodes for more details about each group.
	List(ctx context.Context, in *ListNodeGroupsRequest, opts ...grpc.CallOption) (*NodeGroupList, error)
	// Lists nodes in the node group.
	ListNodes(ctx context.Context, in *ListNodesNodeGroupsRequest, opts ...grpc.CallOption) (*NodeGroupsListNodes, error)
	// Updates the specified node group.
	Patch(ctx context.Context, in *PatchNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Perform maintenance on a subset of nodes in the node group.
	PerformMaintenance(ctx context.Context, in *PerformMaintenanceNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyNodeGroupRequest, opts ...grpc.CallOption) (*Policy, error)
	// Updates the node template of the node group.
	SetNodeTemplate(ctx context.Context, in *SetNodeTemplateNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Simulates maintenance event on specified nodes from the node group.
	SimulateMaintenanceEvent(ctx context.Context, in *SimulateMaintenanceEventNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsNodeGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type nodeGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeGroupsClient(cc grpc.ClientConnInterface) NodeGroupsClient {
	return &nodeGroupsClient{cc}
}

func (c *nodeGroupsClient) AddNodes(ctx context.Context, in *AddNodesNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_AddNodes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) AggregatedList(ctx context.Context, in *AggregatedListNodeGroupsRequest, opts ...grpc.CallOption) (*NodeGroupAggregatedList, error) {
	out := new(NodeGroupAggregatedList)
	err := c.cc.Invoke(ctx, NodeGroups_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) Delete(ctx context.Context, in *DeleteNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) DeleteNodes(ctx context.Context, in *DeleteNodesNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_DeleteNodes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) Get(ctx context.Context, in *GetNodeGroupRequest, opts ...grpc.CallOption) (*NodeGroup, error) {
	out := new(NodeGroup)
	err := c.cc.Invoke(ctx, NodeGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyNodeGroupRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NodeGroups_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) Insert(ctx context.Context, in *InsertNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) List(ctx context.Context, in *ListNodeGroupsRequest, opts ...grpc.CallOption) (*NodeGroupList, error) {
	out := new(NodeGroupList)
	err := c.cc.Invoke(ctx, NodeGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) ListNodes(ctx context.Context, in *ListNodesNodeGroupsRequest, opts ...grpc.CallOption) (*NodeGroupsListNodes, error) {
	out := new(NodeGroupsListNodes)
	err := c.cc.Invoke(ctx, NodeGroups_ListNodes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) Patch(ctx context.Context, in *PatchNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) PerformMaintenance(ctx context.Context, in *PerformMaintenanceNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_PerformMaintenance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyNodeGroupRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NodeGroups_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) SetNodeTemplate(ctx context.Context, in *SetNodeTemplateNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_SetNodeTemplate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) SimulateMaintenanceEvent(ctx context.Context, in *SimulateMaintenanceEventNodeGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeGroups_SimulateMaintenanceEvent_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeGroupsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsNodeGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, NodeGroups_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeGroupsServer is the server API for NodeGroups service.
// All implementations should embed UnimplementedNodeGroupsServer
// for forward compatibility
type NodeGroupsServer interface {
	// Adds specified number of nodes to the node group.
	AddNodes(context.Context, *AddNodesNodeGroupRequest) (*Operation, error)
	// Retrieves an aggregated list of node groups.
	// Note: use nodeGroups.listNodes for more details about each group.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNodeGroupsRequest) (*NodeGroupAggregatedList, error)
	// Deletes the specified NodeGroup resource.
	Delete(context.Context, *DeleteNodeGroupRequest) (*Operation, error)
	// Deletes specified nodes from the node group.
	DeleteNodes(context.Context, *DeleteNodesNodeGroupRequest) (*Operation, error)
	// Returns the specified NodeGroup. Get a list of available NodeGroups
	// by making a list() request.
	// Note: the "nodes" field should not be used. Use nodeGroups.listNodes
	// instead.
	Get(context.Context, *GetNodeGroupRequest) (*NodeGroup, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyNodeGroupRequest) (*Policy, error)
	// Creates a NodeGroup resource in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertNodeGroupRequest) (*Operation, error)
	// Retrieves a list of node groups available to the specified project.
	// Note: use nodeGroups.listNodes for more details about each group.
	List(context.Context, *ListNodeGroupsRequest) (*NodeGroupList, error)
	// Lists nodes in the node group.
	ListNodes(context.Context, *ListNodesNodeGroupsRequest) (*NodeGroupsListNodes, error)
	// Updates the specified node group.
	Patch(context.Context, *PatchNodeGroupRequest) (*Operation, error)
	// Perform maintenance on a subset of nodes in the node group.
	PerformMaintenance(context.Context, *PerformMaintenanceNodeGroupRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyNodeGroupRequest) (*Policy, error)
	// Updates the node template of the node group.
	SetNodeTemplate(context.Context, *SetNodeTemplateNodeGroupRequest) (*Operation, error)
	// Simulates maintenance event on specified nodes from the node group.
	SimulateMaintenanceEvent(context.Context, *SimulateMaintenanceEventNodeGroupRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsNodeGroupRequest) (*TestPermissionsResponse, error)
}

// UnimplementedNodeGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedNodeGroupsServer struct {
}

func (UnimplementedNodeGroupsServer) AddNodes(context.Context, *AddNodesNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddNodes not implemented")
}
func (UnimplementedNodeGroupsServer) AggregatedList(context.Context, *AggregatedListNodeGroupsRequest) (*NodeGroupAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNodeGroupsServer) Delete(context.Context, *DeleteNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNodeGroupsServer) DeleteNodes(context.Context, *DeleteNodesNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteNodes not implemented")
}
func (UnimplementedNodeGroupsServer) Get(context.Context, *GetNodeGroupRequest) (*NodeGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNodeGroupsServer) GetIamPolicy(context.Context, *GetIamPolicyNodeGroupRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedNodeGroupsServer) Insert(context.Context, *InsertNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNodeGroupsServer) List(context.Context, *ListNodeGroupsRequest) (*NodeGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedNodeGroupsServer) ListNodes(context.Context, *ListNodesNodeGroupsRequest) (*NodeGroupsListNodes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNodes not implemented")
}
func (UnimplementedNodeGroupsServer) Patch(context.Context, *PatchNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedNodeGroupsServer) PerformMaintenance(context.Context, *PerformMaintenanceNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerformMaintenance not implemented")
}
func (UnimplementedNodeGroupsServer) SetIamPolicy(context.Context, *SetIamPolicyNodeGroupRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedNodeGroupsServer) SetNodeTemplate(context.Context, *SetNodeTemplateNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNodeTemplate not implemented")
}
func (UnimplementedNodeGroupsServer) SimulateMaintenanceEvent(context.Context, *SimulateMaintenanceEventNodeGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SimulateMaintenanceEvent not implemented")
}
func (UnimplementedNodeGroupsServer) TestIamPermissions(context.Context, *TestIamPermissionsNodeGroupRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeNodeGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeGroupsServer will
// result in compilation errors.
type UnsafeNodeGroupsServer interface {
	mustEmbedUnimplementedNodeGroupsServer()
}

func RegisterNodeGroupsServer(s grpc.ServiceRegistrar, srv NodeGroupsServer) {
	s.RegisterService(&NodeGroups_ServiceDesc, srv)
}

func _NodeGroups_AddNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddNodesNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).AddNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_AddNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).AddNodes(ctx, req.(*AddNodesNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNodeGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).AggregatedList(ctx, req.(*AggregatedListNodeGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).Delete(ctx, req.(*DeleteNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_DeleteNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodesNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).DeleteNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_DeleteNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).DeleteNodes(ctx, req.(*DeleteNodesNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).Get(ctx, req.(*GetNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).GetIamPolicy(ctx, req.(*GetIamPolicyNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).Insert(ctx, req.(*InsertNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).List(ctx, req.(*ListNodeGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_ListNodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodesNodeGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).ListNodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_ListNodes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).ListNodes(ctx, req.(*ListNodesNodeGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).Patch(ctx, req.(*PatchNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_PerformMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PerformMaintenanceNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).PerformMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_PerformMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).PerformMaintenance(ctx, req.(*PerformMaintenanceNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).SetIamPolicy(ctx, req.(*SetIamPolicyNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_SetNodeTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNodeTemplateNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).SetNodeTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_SetNodeTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).SetNodeTemplate(ctx, req.(*SetNodeTemplateNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_SimulateMaintenanceEvent_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SimulateMaintenanceEventNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).SimulateMaintenanceEvent(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_SimulateMaintenanceEvent_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).SimulateMaintenanceEvent(ctx, req.(*SimulateMaintenanceEventNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeGroups_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsNodeGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeGroupsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeGroups_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeGroupsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsNodeGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeGroups_ServiceDesc is the grpc.ServiceDesc for NodeGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NodeGroups",
	HandlerType: (*NodeGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddNodes",
			Handler:    _NodeGroups_AddNodes_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _NodeGroups_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NodeGroups_Delete_Handler,
		},
		{
			MethodName: "DeleteNodes",
			Handler:    _NodeGroups_DeleteNodes_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NodeGroups_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _NodeGroups_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NodeGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NodeGroups_List_Handler,
		},
		{
			MethodName: "ListNodes",
			Handler:    _NodeGroups_ListNodes_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _NodeGroups_Patch_Handler,
		},
		{
			MethodName: "PerformMaintenance",
			Handler:    _NodeGroups_PerformMaintenance_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _NodeGroups_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetNodeTemplate",
			Handler:    _NodeGroups_SetNodeTemplate_Handler,
		},
		{
			MethodName: "SimulateMaintenanceEvent",
			Handler:    _NodeGroups_SimulateMaintenanceEvent_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _NodeGroups_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NodeTemplates_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.NodeTemplates/AggregatedList"
	NodeTemplates_Delete_FullMethodName             = "/google.cloud.compute.v1.NodeTemplates/Delete"
	NodeTemplates_Get_FullMethodName                = "/google.cloud.compute.v1.NodeTemplates/Get"
	NodeTemplates_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.NodeTemplates/GetIamPolicy"
	NodeTemplates_Insert_FullMethodName             = "/google.cloud.compute.v1.NodeTemplates/Insert"
	NodeTemplates_List_FullMethodName               = "/google.cloud.compute.v1.NodeTemplates/List"
	NodeTemplates_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.NodeTemplates/SetIamPolicy"
	NodeTemplates_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.NodeTemplates/TestIamPermissions"
)

// NodeTemplatesClient is the client API for NodeTemplates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeTemplatesClient interface {
	// Retrieves an aggregated list of node templates.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNodeTemplatesRequest, opts ...grpc.CallOption) (*NodeTemplateAggregatedList, error)
	// Deletes the specified NodeTemplate resource.
	Delete(ctx context.Context, in *DeleteNodeTemplateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified node template.
	Get(ctx context.Context, in *GetNodeTemplateRequest, opts ...grpc.CallOption) (*NodeTemplate, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyNodeTemplateRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a NodeTemplate resource in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertNodeTemplateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of node templates available to the specified
	// project.
	List(ctx context.Context, in *ListNodeTemplatesRequest, opts ...grpc.CallOption) (*NodeTemplateList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyNodeTemplateRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsNodeTemplateRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type nodeTemplatesClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeTemplatesClient(cc grpc.ClientConnInterface) NodeTemplatesClient {
	return &nodeTemplatesClient{cc}
}

func (c *nodeTemplatesClient) AggregatedList(ctx context.Context, in *AggregatedListNodeTemplatesRequest, opts ...grpc.CallOption) (*NodeTemplateAggregatedList, error) {
	out := new(NodeTemplateAggregatedList)
	err := c.cc.Invoke(ctx, NodeTemplates_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) Delete(ctx context.Context, in *DeleteNodeTemplateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeTemplates_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) Get(ctx context.Context, in *GetNodeTemplateRequest, opts ...grpc.CallOption) (*NodeTemplate, error) {
	out := new(NodeTemplate)
	err := c.cc.Invoke(ctx, NodeTemplates_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyNodeTemplateRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NodeTemplates_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) Insert(ctx context.Context, in *InsertNodeTemplateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, NodeTemplates_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) List(ctx context.Context, in *ListNodeTemplatesRequest, opts ...grpc.CallOption) (*NodeTemplateList, error) {
	out := new(NodeTemplateList)
	err := c.cc.Invoke(ctx, NodeTemplates_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyNodeTemplateRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, NodeTemplates_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTemplatesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsNodeTemplateRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, NodeTemplates_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeTemplatesServer is the server API for NodeTemplates service.
// All implementations should embed UnimplementedNodeTemplatesServer
// for forward compatibility
type NodeTemplatesServer interface {
	// Retrieves an aggregated list of node templates.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNodeTemplatesRequest) (*NodeTemplateAggregatedList, error)
	// Deletes the specified NodeTemplate resource.
	Delete(context.Context, *DeleteNodeTemplateRequest) (*Operation, error)
	// Returns the specified node template.
	Get(context.Context, *GetNodeTemplateRequest) (*NodeTemplate, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyNodeTemplateRequest) (*Policy, error)
	// Creates a NodeTemplate resource in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertNodeTemplateRequest) (*Operation, error)
	// Retrieves a list of node templates available to the specified
	// project.
	List(context.Context, *ListNodeTemplatesRequest) (*NodeTemplateList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyNodeTemplateRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsNodeTemplateRequest) (*TestPermissionsResponse, error)
}

// UnimplementedNodeTemplatesServer should be embedded to have forward compatible implementations.
type UnimplementedNodeTemplatesServer struct {
}

func (UnimplementedNodeTemplatesServer) AggregatedList(context.Context, *AggregatedListNodeTemplatesRequest) (*NodeTemplateAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNodeTemplatesServer) Delete(context.Context, *DeleteNodeTemplateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedNodeTemplatesServer) Get(context.Context, *GetNodeTemplateRequest) (*NodeTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNodeTemplatesServer) GetIamPolicy(context.Context, *GetIamPolicyNodeTemplateRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedNodeTemplatesServer) Insert(context.Context, *InsertNodeTemplateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedNodeTemplatesServer) List(context.Context, *ListNodeTemplatesRequest) (*NodeTemplateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedNodeTemplatesServer) SetIamPolicy(context.Context, *SetIamPolicyNodeTemplateRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedNodeTemplatesServer) TestIamPermissions(context.Context, *TestIamPermissionsNodeTemplateRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeNodeTemplatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeTemplatesServer will
// result in compilation errors.
type UnsafeNodeTemplatesServer interface {
	mustEmbedUnimplementedNodeTemplatesServer()
}

func RegisterNodeTemplatesServer(s grpc.ServiceRegistrar, srv NodeTemplatesServer) {
	s.RegisterService(&NodeTemplates_ServiceDesc, srv)
}

func _NodeTemplates_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNodeTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).AggregatedList(ctx, req.(*AggregatedListNodeTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteNodeTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).Delete(ctx, req.(*DeleteNodeTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).Get(ctx, req.(*GetNodeTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyNodeTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).GetIamPolicy(ctx, req.(*GetIamPolicyNodeTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertNodeTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).Insert(ctx, req.(*InsertNodeTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).List(ctx, req.(*ListNodeTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyNodeTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).SetIamPolicy(ctx, req.(*SetIamPolicyNodeTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTemplates_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsNodeTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTemplatesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTemplates_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTemplatesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsNodeTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeTemplates_ServiceDesc is the grpc.ServiceDesc for NodeTemplates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeTemplates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NodeTemplates",
	HandlerType: (*NodeTemplatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _NodeTemplates_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _NodeTemplates_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NodeTemplates_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _NodeTemplates_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _NodeTemplates_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NodeTemplates_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _NodeTemplates_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _NodeTemplates_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	NodeTypes_AggregatedList_FullMethodName = "/google.cloud.compute.v1.NodeTypes/AggregatedList"
	NodeTypes_Get_FullMethodName            = "/google.cloud.compute.v1.NodeTypes/Get"
	NodeTypes_List_FullMethodName           = "/google.cloud.compute.v1.NodeTypes/List"
)

// NodeTypesClient is the client API for NodeTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type NodeTypesClient interface {
	// Retrieves an aggregated list of node types.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListNodeTypesRequest, opts ...grpc.CallOption) (*NodeTypeAggregatedList, error)
	// Returns the specified node type.
	Get(ctx context.Context, in *GetNodeTypeRequest, opts ...grpc.CallOption) (*NodeType, error)
	// Retrieves a list of node types available to the specified
	// project.
	List(ctx context.Context, in *ListNodeTypesRequest, opts ...grpc.CallOption) (*NodeTypeList, error)
}

type nodeTypesClient struct {
	cc grpc.ClientConnInterface
}

func NewNodeTypesClient(cc grpc.ClientConnInterface) NodeTypesClient {
	return &nodeTypesClient{cc}
}

func (c *nodeTypesClient) AggregatedList(ctx context.Context, in *AggregatedListNodeTypesRequest, opts ...grpc.CallOption) (*NodeTypeAggregatedList, error) {
	out := new(NodeTypeAggregatedList)
	err := c.cc.Invoke(ctx, NodeTypes_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTypesClient) Get(ctx context.Context, in *GetNodeTypeRequest, opts ...grpc.CallOption) (*NodeType, error) {
	out := new(NodeType)
	err := c.cc.Invoke(ctx, NodeTypes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *nodeTypesClient) List(ctx context.Context, in *ListNodeTypesRequest, opts ...grpc.CallOption) (*NodeTypeList, error) {
	out := new(NodeTypeList)
	err := c.cc.Invoke(ctx, NodeTypes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// NodeTypesServer is the server API for NodeTypes service.
// All implementations should embed UnimplementedNodeTypesServer
// for forward compatibility
type NodeTypesServer interface {
	// Retrieves an aggregated list of node types.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListNodeTypesRequest) (*NodeTypeAggregatedList, error)
	// Returns the specified node type.
	Get(context.Context, *GetNodeTypeRequest) (*NodeType, error)
	// Retrieves a list of node types available to the specified
	// project.
	List(context.Context, *ListNodeTypesRequest) (*NodeTypeList, error)
}

// UnimplementedNodeTypesServer should be embedded to have forward compatible implementations.
type UnimplementedNodeTypesServer struct {
}

func (UnimplementedNodeTypesServer) AggregatedList(context.Context, *AggregatedListNodeTypesRequest) (*NodeTypeAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedNodeTypesServer) Get(context.Context, *GetNodeTypeRequest) (*NodeType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedNodeTypesServer) List(context.Context, *ListNodeTypesRequest) (*NodeTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeNodeTypesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to NodeTypesServer will
// result in compilation errors.
type UnsafeNodeTypesServer interface {
	mustEmbedUnimplementedNodeTypesServer()
}

func RegisterNodeTypesServer(s grpc.ServiceRegistrar, srv NodeTypesServer) {
	s.RegisterService(&NodeTypes_ServiceDesc, srv)
}

func _NodeTypes_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListNodeTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTypesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTypes_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTypesServer).AggregatedList(ctx, req.(*AggregatedListNodeTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTypes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNodeTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTypesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTypes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTypesServer).Get(ctx, req.(*GetNodeTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _NodeTypes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNodeTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(NodeTypesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: NodeTypes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(NodeTypesServer).List(ctx, req.(*ListNodeTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// NodeTypes_ServiceDesc is the grpc.ServiceDesc for NodeTypes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var NodeTypes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.NodeTypes",
	HandlerType: (*NodeTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _NodeTypes_AggregatedList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _NodeTypes_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _NodeTypes_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	OrganizationSecurityPolicies_AddAssociation_FullMethodName                  = "/google.cloud.compute.v1.OrganizationSecurityPolicies/AddAssociation"
	OrganizationSecurityPolicies_AddRule_FullMethodName                         = "/google.cloud.compute.v1.OrganizationSecurityPolicies/AddRule"
	OrganizationSecurityPolicies_CopyRules_FullMethodName                       = "/google.cloud.compute.v1.OrganizationSecurityPolicies/CopyRules"
	OrganizationSecurityPolicies_Delete_FullMethodName                          = "/google.cloud.compute.v1.OrganizationSecurityPolicies/Delete"
	OrganizationSecurityPolicies_Get_FullMethodName                             = "/google.cloud.compute.v1.OrganizationSecurityPolicies/Get"
	OrganizationSecurityPolicies_GetAssociation_FullMethodName                  = "/google.cloud.compute.v1.OrganizationSecurityPolicies/GetAssociation"
	OrganizationSecurityPolicies_GetRule_FullMethodName                         = "/google.cloud.compute.v1.OrganizationSecurityPolicies/GetRule"
	OrganizationSecurityPolicies_Insert_FullMethodName                          = "/google.cloud.compute.v1.OrganizationSecurityPolicies/Insert"
	OrganizationSecurityPolicies_List_FullMethodName                            = "/google.cloud.compute.v1.OrganizationSecurityPolicies/List"
	OrganizationSecurityPolicies_ListAssociations_FullMethodName                = "/google.cloud.compute.v1.OrganizationSecurityPolicies/ListAssociations"
	OrganizationSecurityPolicies_ListPreconfiguredExpressionSets_FullMethodName = "/google.cloud.compute.v1.OrganizationSecurityPolicies/ListPreconfiguredExpressionSets"
	OrganizationSecurityPolicies_Move_FullMethodName                            = "/google.cloud.compute.v1.OrganizationSecurityPolicies/Move"
	OrganizationSecurityPolicies_Patch_FullMethodName                           = "/google.cloud.compute.v1.OrganizationSecurityPolicies/Patch"
	OrganizationSecurityPolicies_PatchRule_FullMethodName                       = "/google.cloud.compute.v1.OrganizationSecurityPolicies/PatchRule"
	OrganizationSecurityPolicies_RemoveAssociation_FullMethodName               = "/google.cloud.compute.v1.OrganizationSecurityPolicies/RemoveAssociation"
	OrganizationSecurityPolicies_RemoveRule_FullMethodName                      = "/google.cloud.compute.v1.OrganizationSecurityPolicies/RemoveRule"
)

// OrganizationSecurityPoliciesClient is the client API for OrganizationSecurityPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type OrganizationSecurityPoliciesClient interface {
	// Inserts an association for the specified security policy.
	//
	// This has billing implications.  Projects in the hierarchy with effective
	// hierarchical security policies will be automatically enrolled into Cloud
	// Armor Enterprise if not already enrolled.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.addAssociation
	// instead.
	AddAssociation(ctx context.Context, in *AddAssociationOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts a rule into a security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.addRule instead.
	AddRule(ctx context.Context, in *AddRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Copies rules to the specified security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.cloneRules
	// instead.
	CopyRules(ctx context.Context, in *CopyRulesOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified policy.
	//
	// Use this API to remove Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to remove firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.delete instead.
	Delete(ctx context.Context, in *DeleteOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// List all of the ordered rules present in a single specified policy.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.get instead.
	Get(ctx context.Context, in *GetOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicy, error)
	// Gets an association with the specified name.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.getAssociation
	// instead.
	GetAssociation(ctx context.Context, in *GetAssociationOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyAssociation, error)
	// Gets a rule at the specified priority.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.getRule instead.
	GetRule(ctx context.Context, in *GetRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyRule, error)
	// Creates a new policy in the specified organization using the data included
	// in the request.
	//
	// Use this API to add Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to add firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.insert instead.
	Insert(ctx context.Context, in *InsertOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// List all the policies that have been configured for the specified
	// organization.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.list instead.
	List(ctx context.Context, in *ListOrganizationSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPolicyList, error)
	// Lists associations of a specified target, i.e., organization or folder.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.listAssociations
	// instead.
	ListAssociations(ctx context.Context, in *ListAssociationsOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*OrganizationSecurityPoliciesListAssociationsResponse, error)
	// Gets the current list of preconfigured Web Application Firewall (WAF)
	// expressions.
	ListPreconfiguredExpressionSets(ctx context.Context, in *ListPreconfiguredExpressionSetsOrganizationSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error)
	// Moves the specified security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.move instead.
	Move(ctx context.Context, in *MoveOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches the specified policy with the data included in the request.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.patch instead.
	Patch(ctx context.Context, in *PatchOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a rule at the specified priority.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.patchRule
	// instead.
	PatchRule(ctx context.Context, in *PatchRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes an association for the specified security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.removeAssociation
	// instead.
	RemoveAssociation(ctx context.Context, in *RemoveAssociationOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a rule at the specified priority.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.removeRule
	// instead.
	RemoveRule(ctx context.Context, in *RemoveRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type organizationSecurityPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewOrganizationSecurityPoliciesClient(cc grpc.ClientConnInterface) OrganizationSecurityPoliciesClient {
	return &organizationSecurityPoliciesClient{cc}
}

func (c *organizationSecurityPoliciesClient) AddAssociation(ctx context.Context, in *AddAssociationOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_AddAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) AddRule(ctx context.Context, in *AddRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_AddRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) CopyRules(ctx context.Context, in *CopyRulesOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_CopyRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) Delete(ctx context.Context, in *DeleteOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) Get(ctx context.Context, in *GetOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicy, error) {
	out := new(SecurityPolicy)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) GetAssociation(ctx context.Context, in *GetAssociationOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyAssociation, error) {
	out := new(SecurityPolicyAssociation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_GetAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) GetRule(ctx context.Context, in *GetRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyRule, error) {
	out := new(SecurityPolicyRule)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_GetRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) Insert(ctx context.Context, in *InsertOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) List(ctx context.Context, in *ListOrganizationSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPolicyList, error) {
	out := new(SecurityPolicyList)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) ListAssociations(ctx context.Context, in *ListAssociationsOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*OrganizationSecurityPoliciesListAssociationsResponse, error) {
	out := new(OrganizationSecurityPoliciesListAssociationsResponse)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_ListAssociations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) ListPreconfiguredExpressionSets(ctx context.Context, in *ListPreconfiguredExpressionSetsOrganizationSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error) {
	out := new(SecurityPoliciesListPreconfiguredExpressionSetsResponse)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_ListPreconfiguredExpressionSets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) Move(ctx context.Context, in *MoveOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_Move_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) Patch(ctx context.Context, in *PatchOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) PatchRule(ctx context.Context, in *PatchRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_PatchRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) RemoveAssociation(ctx context.Context, in *RemoveAssociationOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_RemoveAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *organizationSecurityPoliciesClient) RemoveRule(ctx context.Context, in *RemoveRuleOrganizationSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, OrganizationSecurityPolicies_RemoveRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// OrganizationSecurityPoliciesServer is the server API for OrganizationSecurityPolicies service.
// All implementations should embed UnimplementedOrganizationSecurityPoliciesServer
// for forward compatibility
type OrganizationSecurityPoliciesServer interface {
	// Inserts an association for the specified security policy.
	//
	// This has billing implications.  Projects in the hierarchy with effective
	// hierarchical security policies will be automatically enrolled into Cloud
	// Armor Enterprise if not already enrolled.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.addAssociation
	// instead.
	AddAssociation(context.Context, *AddAssociationOrganizationSecurityPolicyRequest) (*Operation, error)
	// Inserts a rule into a security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.addRule instead.
	AddRule(context.Context, *AddRuleOrganizationSecurityPolicyRequest) (*Operation, error)
	// Copies rules to the specified security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.cloneRules
	// instead.
	CopyRules(context.Context, *CopyRulesOrganizationSecurityPolicyRequest) (*Operation, error)
	// Deletes the specified policy.
	//
	// Use this API to remove Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to remove firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.delete instead.
	Delete(context.Context, *DeleteOrganizationSecurityPolicyRequest) (*Operation, error)
	// List all of the ordered rules present in a single specified policy.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.get instead.
	Get(context.Context, *GetOrganizationSecurityPolicyRequest) (*SecurityPolicy, error)
	// Gets an association with the specified name.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.getAssociation
	// instead.
	GetAssociation(context.Context, *GetAssociationOrganizationSecurityPolicyRequest) (*SecurityPolicyAssociation, error)
	// Gets a rule at the specified priority.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.getRule instead.
	GetRule(context.Context, *GetRuleOrganizationSecurityPolicyRequest) (*SecurityPolicyRule, error)
	// Creates a new policy in the specified organization using the data included
	// in the request.
	//
	// Use this API to add Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to add firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.insert instead.
	Insert(context.Context, *InsertOrganizationSecurityPolicyRequest) (*Operation, error)
	// List all the policies that have been configured for the specified
	// organization.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is now
	// disabled for most organizations. Use firewallPolicies.list instead.
	List(context.Context, *ListOrganizationSecurityPoliciesRequest) (*SecurityPolicyList, error)
	// Lists associations of a specified target, i.e., organization or folder.
	//
	// Use this API to read Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to read firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.listAssociations
	// instead.
	ListAssociations(context.Context, *ListAssociationsOrganizationSecurityPolicyRequest) (*OrganizationSecurityPoliciesListAssociationsResponse, error)
	// Gets the current list of preconfigured Web Application Firewall (WAF)
	// expressions.
	ListPreconfiguredExpressionSets(context.Context, *ListPreconfiguredExpressionSetsOrganizationSecurityPoliciesRequest) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error)
	// Moves the specified security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.move instead.
	Move(context.Context, *MoveOrganizationSecurityPolicyRequest) (*Operation, error)
	// Patches the specified policy with the data included in the request.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.patch instead.
	Patch(context.Context, *PatchOrganizationSecurityPolicyRequest) (*Operation, error)
	// Patches a rule at the specified priority.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.patchRule
	// instead.
	PatchRule(context.Context, *PatchRuleOrganizationSecurityPolicyRequest) (*Operation, error)
	// Removes an association for the specified security policy.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.removeAssociation
	// instead.
	RemoveAssociation(context.Context, *RemoveAssociationOrganizationSecurityPolicyRequest) (*Operation, error)
	// Deletes a rule at the specified priority.
	//
	// Use this API to modify Cloud Armor policies. Previously, alpha and beta
	// versions of this API were used to modify firewall policies. This usage is
	// now disabled for most organizations. Use firewallPolicies.removeRule
	// instead.
	RemoveRule(context.Context, *RemoveRuleOrganizationSecurityPolicyRequest) (*Operation, error)
}

// UnimplementedOrganizationSecurityPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedOrganizationSecurityPoliciesServer struct {
}

func (UnimplementedOrganizationSecurityPoliciesServer) AddAssociation(context.Context, *AddAssociationOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAssociation not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) AddRule(context.Context, *AddRuleOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) CopyRules(context.Context, *CopyRulesOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CopyRules not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) Delete(context.Context, *DeleteOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) Get(context.Context, *GetOrganizationSecurityPolicyRequest) (*SecurityPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) GetAssociation(context.Context, *GetAssociationOrganizationSecurityPolicyRequest) (*SecurityPolicyAssociation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssociation not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) GetRule(context.Context, *GetRuleOrganizationSecurityPolicyRequest) (*SecurityPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) Insert(context.Context, *InsertOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) List(context.Context, *ListOrganizationSecurityPoliciesRequest) (*SecurityPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) ListAssociations(context.Context, *ListAssociationsOrganizationSecurityPolicyRequest) (*OrganizationSecurityPoliciesListAssociationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAssociations not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) ListPreconfiguredExpressionSets(context.Context, *ListPreconfiguredExpressionSetsOrganizationSecurityPoliciesRequest) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPreconfiguredExpressionSets not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) Move(context.Context, *MoveOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Move not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) Patch(context.Context, *PatchOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) PatchRule(context.Context, *PatchRuleOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRule not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) RemoveAssociation(context.Context, *RemoveAssociationOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAssociation not implemented")
}
func (UnimplementedOrganizationSecurityPoliciesServer) RemoveRule(context.Context, *RemoveRuleOrganizationSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}

// UnsafeOrganizationSecurityPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to OrganizationSecurityPoliciesServer will
// result in compilation errors.
type UnsafeOrganizationSecurityPoliciesServer interface {
	mustEmbedUnimplementedOrganizationSecurityPoliciesServer()
}

func RegisterOrganizationSecurityPoliciesServer(s grpc.ServiceRegistrar, srv OrganizationSecurityPoliciesServer) {
	s.RegisterService(&OrganizationSecurityPolicies_ServiceDesc, srv)
}

func _OrganizationSecurityPolicies_AddAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAssociationOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).AddAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_AddAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).AddAssociation(ctx, req.(*AddAssociationOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).AddRule(ctx, req.(*AddRuleOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_CopyRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CopyRulesOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).CopyRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_CopyRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).CopyRules(ctx, req.(*CopyRulesOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).Delete(ctx, req.(*DeleteOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).Get(ctx, req.(*GetOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_GetAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssociationOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).GetAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_GetAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).GetAssociation(ctx, req.(*GetAssociationOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).GetRule(ctx, req.(*GetRuleOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).Insert(ctx, req.(*InsertOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListOrganizationSecurityPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).List(ctx, req.(*ListOrganizationSecurityPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_ListAssociations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAssociationsOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).ListAssociations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_ListAssociations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).ListAssociations(ctx, req.(*ListAssociationsOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_ListPreconfiguredExpressionSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPreconfiguredExpressionSetsOrganizationSecurityPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).ListPreconfiguredExpressionSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_ListPreconfiguredExpressionSets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).ListPreconfiguredExpressionSets(ctx, req.(*ListPreconfiguredExpressionSetsOrganizationSecurityPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_Move_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).Move(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_Move_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).Move(ctx, req.(*MoveOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).Patch(ctx, req.(*PatchOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_PatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRuleOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).PatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_PatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).PatchRule(ctx, req.(*PatchRuleOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_RemoveAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveAssociationOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).RemoveAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_RemoveAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).RemoveAssociation(ctx, req.(*RemoveAssociationOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _OrganizationSecurityPolicies_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleOrganizationSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(OrganizationSecurityPoliciesServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: OrganizationSecurityPolicies_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(OrganizationSecurityPoliciesServer).RemoveRule(ctx, req.(*RemoveRuleOrganizationSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// OrganizationSecurityPolicies_ServiceDesc is the grpc.ServiceDesc for OrganizationSecurityPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var OrganizationSecurityPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.OrganizationSecurityPolicies",
	HandlerType: (*OrganizationSecurityPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddAssociation",
			Handler:    _OrganizationSecurityPolicies_AddAssociation_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _OrganizationSecurityPolicies_AddRule_Handler,
		},
		{
			MethodName: "CopyRules",
			Handler:    _OrganizationSecurityPolicies_CopyRules_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _OrganizationSecurityPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _OrganizationSecurityPolicies_Get_Handler,
		},
		{
			MethodName: "GetAssociation",
			Handler:    _OrganizationSecurityPolicies_GetAssociation_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _OrganizationSecurityPolicies_GetRule_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _OrganizationSecurityPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _OrganizationSecurityPolicies_List_Handler,
		},
		{
			MethodName: "ListAssociations",
			Handler:    _OrganizationSecurityPolicies_ListAssociations_Handler,
		},
		{
			MethodName: "ListPreconfiguredExpressionSets",
			Handler:    _OrganizationSecurityPolicies_ListPreconfiguredExpressionSets_Handler,
		},
		{
			MethodName: "Move",
			Handler:    _OrganizationSecurityPolicies_Move_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _OrganizationSecurityPolicies_Patch_Handler,
		},
		{
			MethodName: "PatchRule",
			Handler:    _OrganizationSecurityPolicies_PatchRule_Handler,
		},
		{
			MethodName: "RemoveAssociation",
			Handler:    _OrganizationSecurityPolicies_RemoveAssociation_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _OrganizationSecurityPolicies_RemoveRule_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	PacketMirrorings_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.PacketMirrorings/AggregatedList"
	PacketMirrorings_Delete_FullMethodName             = "/google.cloud.compute.v1.PacketMirrorings/Delete"
	PacketMirrorings_Get_FullMethodName                = "/google.cloud.compute.v1.PacketMirrorings/Get"
	PacketMirrorings_Insert_FullMethodName             = "/google.cloud.compute.v1.PacketMirrorings/Insert"
	PacketMirrorings_List_FullMethodName               = "/google.cloud.compute.v1.PacketMirrorings/List"
	PacketMirrorings_Patch_FullMethodName              = "/google.cloud.compute.v1.PacketMirrorings/Patch"
	PacketMirrorings_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.PacketMirrorings/TestIamPermissions"
)

// PacketMirroringsClient is the client API for PacketMirrorings service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PacketMirroringsClient interface {
	// Retrieves an aggregated list of packetMirrorings.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListPacketMirroringsRequest, opts ...grpc.CallOption) (*PacketMirroringAggregatedList, error)
	// Deletes the specified PacketMirroring resource.
	Delete(ctx context.Context, in *DeletePacketMirroringRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified PacketMirroring resource.
	Get(ctx context.Context, in *GetPacketMirroringRequest, opts ...grpc.CallOption) (*PacketMirroring, error)
	// Creates a PacketMirroring resource in the specified project and region
	// using the data included in the request.
	Insert(ctx context.Context, in *InsertPacketMirroringRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of PacketMirroring resources available to the specified
	// project and region.
	List(ctx context.Context, in *ListPacketMirroringsRequest, opts ...grpc.CallOption) (*PacketMirroringList, error)
	// Patches the specified PacketMirroring resource with the data included in
	// the request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchPacketMirroringRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsPacketMirroringRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type packetMirroringsClient struct {
	cc grpc.ClientConnInterface
}

func NewPacketMirroringsClient(cc grpc.ClientConnInterface) PacketMirroringsClient {
	return &packetMirroringsClient{cc}
}

func (c *packetMirroringsClient) AggregatedList(ctx context.Context, in *AggregatedListPacketMirroringsRequest, opts ...grpc.CallOption) (*PacketMirroringAggregatedList, error) {
	out := new(PacketMirroringAggregatedList)
	err := c.cc.Invoke(ctx, PacketMirrorings_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *packetMirroringsClient) Delete(ctx context.Context, in *DeletePacketMirroringRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PacketMirrorings_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *packetMirroringsClient) Get(ctx context.Context, in *GetPacketMirroringRequest, opts ...grpc.CallOption) (*PacketMirroring, error) {
	out := new(PacketMirroring)
	err := c.cc.Invoke(ctx, PacketMirrorings_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *packetMirroringsClient) Insert(ctx context.Context, in *InsertPacketMirroringRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PacketMirrorings_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *packetMirroringsClient) List(ctx context.Context, in *ListPacketMirroringsRequest, opts ...grpc.CallOption) (*PacketMirroringList, error) {
	out := new(PacketMirroringList)
	err := c.cc.Invoke(ctx, PacketMirrorings_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *packetMirroringsClient) Patch(ctx context.Context, in *PatchPacketMirroringRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PacketMirrorings_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *packetMirroringsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsPacketMirroringRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, PacketMirrorings_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PacketMirroringsServer is the server API for PacketMirrorings service.
// All implementations should embed UnimplementedPacketMirroringsServer
// for forward compatibility
type PacketMirroringsServer interface {
	// Retrieves an aggregated list of packetMirrorings.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListPacketMirroringsRequest) (*PacketMirroringAggregatedList, error)
	// Deletes the specified PacketMirroring resource.
	Delete(context.Context, *DeletePacketMirroringRequest) (*Operation, error)
	// Returns the specified PacketMirroring resource.
	Get(context.Context, *GetPacketMirroringRequest) (*PacketMirroring, error)
	// Creates a PacketMirroring resource in the specified project and region
	// using the data included in the request.
	Insert(context.Context, *InsertPacketMirroringRequest) (*Operation, error)
	// Retrieves a list of PacketMirroring resources available to the specified
	// project and region.
	List(context.Context, *ListPacketMirroringsRequest) (*PacketMirroringList, error)
	// Patches the specified PacketMirroring resource with the data included in
	// the request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchPacketMirroringRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsPacketMirroringRequest) (*TestPermissionsResponse, error)
}

// UnimplementedPacketMirroringsServer should be embedded to have forward compatible implementations.
type UnimplementedPacketMirroringsServer struct {
}

func (UnimplementedPacketMirroringsServer) AggregatedList(context.Context, *AggregatedListPacketMirroringsRequest) (*PacketMirroringAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedPacketMirroringsServer) Delete(context.Context, *DeletePacketMirroringRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPacketMirroringsServer) Get(context.Context, *GetPacketMirroringRequest) (*PacketMirroring, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPacketMirroringsServer) Insert(context.Context, *InsertPacketMirroringRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedPacketMirroringsServer) List(context.Context, *ListPacketMirroringsRequest) (*PacketMirroringList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPacketMirroringsServer) Patch(context.Context, *PatchPacketMirroringRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedPacketMirroringsServer) TestIamPermissions(context.Context, *TestIamPermissionsPacketMirroringRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafePacketMirroringsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PacketMirroringsServer will
// result in compilation errors.
type UnsafePacketMirroringsServer interface {
	mustEmbedUnimplementedPacketMirroringsServer()
}

func RegisterPacketMirroringsServer(s grpc.ServiceRegistrar, srv PacketMirroringsServer) {
	s.RegisterService(&PacketMirrorings_ServiceDesc, srv)
}

func _PacketMirrorings_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListPacketMirroringsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).AggregatedList(ctx, req.(*AggregatedListPacketMirroringsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PacketMirrorings_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePacketMirroringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).Delete(ctx, req.(*DeletePacketMirroringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PacketMirrorings_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPacketMirroringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).Get(ctx, req.(*GetPacketMirroringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PacketMirrorings_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertPacketMirroringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).Insert(ctx, req.(*InsertPacketMirroringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PacketMirrorings_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPacketMirroringsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).List(ctx, req.(*ListPacketMirroringsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PacketMirrorings_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPacketMirroringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).Patch(ctx, req.(*PatchPacketMirroringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PacketMirrorings_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsPacketMirroringRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PacketMirroringsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PacketMirrorings_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PacketMirroringsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsPacketMirroringRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PacketMirrorings_ServiceDesc is the grpc.ServiceDesc for PacketMirrorings service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PacketMirrorings_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.PacketMirrorings",
	HandlerType: (*PacketMirroringsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _PacketMirrorings_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PacketMirrorings_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PacketMirrorings_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _PacketMirrorings_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PacketMirrorings_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _PacketMirrorings_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _PacketMirrorings_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	PreviewFeatures_Get_FullMethodName    = "/google.cloud.compute.v1.PreviewFeatures/Get"
	PreviewFeatures_List_FullMethodName   = "/google.cloud.compute.v1.PreviewFeatures/List"
	PreviewFeatures_Update_FullMethodName = "/google.cloud.compute.v1.PreviewFeatures/Update"
)

// PreviewFeaturesClient is the client API for PreviewFeatures service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PreviewFeaturesClient interface {
	// Returns the details of the given PreviewFeature.
	Get(ctx context.Context, in *GetPreviewFeatureRequest, opts ...grpc.CallOption) (*PreviewFeature, error)
	// Returns the details of the given PreviewFeature.
	List(ctx context.Context, in *ListPreviewFeaturesRequest, opts ...grpc.CallOption) (*PreviewFeatureList, error)
	// Patches the given PreviewFeature. This method is used to enable or disable
	// a PreviewFeature.
	Update(ctx context.Context, in *UpdatePreviewFeatureRequest, opts ...grpc.CallOption) (*Operation, error)
}

type previewFeaturesClient struct {
	cc grpc.ClientConnInterface
}

func NewPreviewFeaturesClient(cc grpc.ClientConnInterface) PreviewFeaturesClient {
	return &previewFeaturesClient{cc}
}

func (c *previewFeaturesClient) Get(ctx context.Context, in *GetPreviewFeatureRequest, opts ...grpc.CallOption) (*PreviewFeature, error) {
	out := new(PreviewFeature)
	err := c.cc.Invoke(ctx, PreviewFeatures_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *previewFeaturesClient) List(ctx context.Context, in *ListPreviewFeaturesRequest, opts ...grpc.CallOption) (*PreviewFeatureList, error) {
	out := new(PreviewFeatureList)
	err := c.cc.Invoke(ctx, PreviewFeatures_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *previewFeaturesClient) Update(ctx context.Context, in *UpdatePreviewFeatureRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PreviewFeatures_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PreviewFeaturesServer is the server API for PreviewFeatures service.
// All implementations should embed UnimplementedPreviewFeaturesServer
// for forward compatibility
type PreviewFeaturesServer interface {
	// Returns the details of the given PreviewFeature.
	Get(context.Context, *GetPreviewFeatureRequest) (*PreviewFeature, error)
	// Returns the details of the given PreviewFeature.
	List(context.Context, *ListPreviewFeaturesRequest) (*PreviewFeatureList, error)
	// Patches the given PreviewFeature. This method is used to enable or disable
	// a PreviewFeature.
	Update(context.Context, *UpdatePreviewFeatureRequest) (*Operation, error)
}

// UnimplementedPreviewFeaturesServer should be embedded to have forward compatible implementations.
type UnimplementedPreviewFeaturesServer struct {
}

func (UnimplementedPreviewFeaturesServer) Get(context.Context, *GetPreviewFeatureRequest) (*PreviewFeature, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPreviewFeaturesServer) List(context.Context, *ListPreviewFeaturesRequest) (*PreviewFeatureList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPreviewFeaturesServer) Update(context.Context, *UpdatePreviewFeatureRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafePreviewFeaturesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PreviewFeaturesServer will
// result in compilation errors.
type UnsafePreviewFeaturesServer interface {
	mustEmbedUnimplementedPreviewFeaturesServer()
}

func RegisterPreviewFeaturesServer(s grpc.ServiceRegistrar, srv PreviewFeaturesServer) {
	s.RegisterService(&PreviewFeatures_ServiceDesc, srv)
}

func _PreviewFeatures_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPreviewFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PreviewFeaturesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PreviewFeatures_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PreviewFeaturesServer).Get(ctx, req.(*GetPreviewFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PreviewFeatures_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPreviewFeaturesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PreviewFeaturesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PreviewFeatures_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PreviewFeaturesServer).List(ctx, req.(*ListPreviewFeaturesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PreviewFeatures_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePreviewFeatureRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PreviewFeaturesServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PreviewFeatures_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PreviewFeaturesServer).Update(ctx, req.(*UpdatePreviewFeatureRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PreviewFeatures_ServiceDesc is the grpc.ServiceDesc for PreviewFeatures service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PreviewFeatures_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.PreviewFeatures",
	HandlerType: (*PreviewFeaturesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _PreviewFeatures_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PreviewFeatures_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _PreviewFeatures_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Projects_DisableXpnHost_FullMethodName            = "/google.cloud.compute.v1.Projects/DisableXpnHost"
	Projects_DisableXpnResource_FullMethodName        = "/google.cloud.compute.v1.Projects/DisableXpnResource"
	Projects_EnableXpnHost_FullMethodName             = "/google.cloud.compute.v1.Projects/EnableXpnHost"
	Projects_EnableXpnResource_FullMethodName         = "/google.cloud.compute.v1.Projects/EnableXpnResource"
	Projects_Get_FullMethodName                       = "/google.cloud.compute.v1.Projects/Get"
	Projects_GetXpnHost_FullMethodName                = "/google.cloud.compute.v1.Projects/GetXpnHost"
	Projects_GetXpnResources_FullMethodName           = "/google.cloud.compute.v1.Projects/GetXpnResources"
	Projects_ListXpnHosts_FullMethodName              = "/google.cloud.compute.v1.Projects/ListXpnHosts"
	Projects_MoveDisk_FullMethodName                  = "/google.cloud.compute.v1.Projects/MoveDisk"
	Projects_MoveInstance_FullMethodName              = "/google.cloud.compute.v1.Projects/MoveInstance"
	Projects_SetCloudArmorTier_FullMethodName         = "/google.cloud.compute.v1.Projects/SetCloudArmorTier"
	Projects_SetCommonInstanceMetadata_FullMethodName = "/google.cloud.compute.v1.Projects/SetCommonInstanceMetadata"
	Projects_SetDefaultNetworkTier_FullMethodName     = "/google.cloud.compute.v1.Projects/SetDefaultNetworkTier"
	Projects_SetUsageExportBucket_FullMethodName      = "/google.cloud.compute.v1.Projects/SetUsageExportBucket"
)

// ProjectsClient is the client API for Projects service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ProjectsClient interface {
	// Disable this project as a shared VPC host project.
	DisableXpnHost(ctx context.Context, in *DisableXpnHostProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Disable a service resource (also known as service project) associated with
	// this host project.
	DisableXpnResource(ctx context.Context, in *DisableXpnResourceProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Enable this project as a shared VPC host project.
	EnableXpnHost(ctx context.Context, in *EnableXpnHostProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Enable service resource (a.k.a service project) for a host project, so that
	// subnets in the host project can be used by instances in the service
	// project.
	EnableXpnResource(ctx context.Context, in *EnableXpnResourceProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified Project resource.
	//
	// To decrease latency for this method, you can optionally omit any unneeded
	// information from the response by using a field mask. This practice is
	// especially recommended for unused quota information (the `quotas` field).
	// To exclude one or more fields, set your request's `fields` query parameter
	// to only include the fields you need. For example, to only include the `id`
	// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
	// your request.
	Get(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*Project, error)
	// Gets the shared VPC host project that this project links to. May be empty
	// if no link exists.
	GetXpnHost(ctx context.Context, in *GetXpnHostProjectRequest, opts ...grpc.CallOption) (*Project, error)
	// Gets service resources (a.k.a service project) associated with this host
	// project.
	GetXpnResources(ctx context.Context, in *GetXpnResourcesProjectsRequest, opts ...grpc.CallOption) (*ProjectsGetXpnResources, error)
	// Lists all shared VPC host projects visible to the user in an organization.
	ListXpnHosts(ctx context.Context, in *ListXpnHostsProjectsRequest, opts ...grpc.CallOption) (*XpnHostList, error)
	// Moves a persistent disk from one zone to another.
	// *Note*: The moveDisk API will be deprecated on September 29, 2026.
	//
	// Starting September 29, 2025, you can't use the moveDisk API on new
	// projects. To move a disk to a different region or zone, follow the steps in
	// [Change the location of a
	// disk](https://cloud.google.com/compute/docs/disks/migrate-to-hyperdisk#migrate-to-hd).
	//
	// Projects that already use the moveDisk API can continue usage until
	// September 29, 2026.
	//
	// Starting November 1, 2025, API responses will include a warning message in
	// the response body about the upcoming deprecation. You can skip the message
	// to continue using the service without interruption.
	MoveDisk(ctx context.Context, in *MoveDiskProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Moves an instance and its attached persistent disks from one zone to
	// another.
	// *Note*: Moving VMs or disks by using this method might
	//
	//	cause unexpected behavior. For more information, see the [known
	//	issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
	//
	// [Deprecated] This method is deprecated. See [moving instance across
	// zones](/compute/docs/instances/moving-instance-across-zones) instead.
	MoveInstance(ctx context.Context, in *MoveInstanceProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the Cloud Armor tier of the project. To set ENTERPRISE or above the
	// billing account of the project must be subscribed to Cloud Armor
	// Enterprise. See Subscribing
	// to Cloud Armor Enterprise for more information.
	SetCloudArmorTier(ctx context.Context, in *SetCloudArmorTierProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets metadata common to all instances within the specified project using
	// the data included in the request.
	SetCommonInstanceMetadata(ctx context.Context, in *SetCommonInstanceMetadataProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the default network tier of the project. The default network tier is
	// used when an address/forwardingRule/instance is created without specifying
	// the network tier field.
	SetDefaultNetworkTier(ctx context.Context, in *SetDefaultNetworkTierProjectRequest, opts ...grpc.CallOption) (*Operation, error)
	// Enables the usage export feature and sets theusage export bucket
	// where reports are stored. If you provide an empty request body using this
	// method, the usage export feature will be disabled.
	SetUsageExportBucket(ctx context.Context, in *SetUsageExportBucketProjectRequest, opts ...grpc.CallOption) (*Operation, error)
}

type projectsClient struct {
	cc grpc.ClientConnInterface
}

func NewProjectsClient(cc grpc.ClientConnInterface) ProjectsClient {
	return &projectsClient{cc}
}

func (c *projectsClient) DisableXpnHost(ctx context.Context, in *DisableXpnHostProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_DisableXpnHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) DisableXpnResource(ctx context.Context, in *DisableXpnResourceProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_DisableXpnResource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) EnableXpnHost(ctx context.Context, in *EnableXpnHostProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_EnableXpnHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) EnableXpnResource(ctx context.Context, in *EnableXpnResourceProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_EnableXpnResource_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) Get(ctx context.Context, in *GetProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	out := new(Project)
	err := c.cc.Invoke(ctx, Projects_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetXpnHost(ctx context.Context, in *GetXpnHostProjectRequest, opts ...grpc.CallOption) (*Project, error) {
	out := new(Project)
	err := c.cc.Invoke(ctx, Projects_GetXpnHost_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) GetXpnResources(ctx context.Context, in *GetXpnResourcesProjectsRequest, opts ...grpc.CallOption) (*ProjectsGetXpnResources, error) {
	out := new(ProjectsGetXpnResources)
	err := c.cc.Invoke(ctx, Projects_GetXpnResources_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) ListXpnHosts(ctx context.Context, in *ListXpnHostsProjectsRequest, opts ...grpc.CallOption) (*XpnHostList, error) {
	out := new(XpnHostList)
	err := c.cc.Invoke(ctx, Projects_ListXpnHosts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) MoveDisk(ctx context.Context, in *MoveDiskProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_MoveDisk_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) MoveInstance(ctx context.Context, in *MoveInstanceProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_MoveInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) SetCloudArmorTier(ctx context.Context, in *SetCloudArmorTierProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_SetCloudArmorTier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) SetCommonInstanceMetadata(ctx context.Context, in *SetCommonInstanceMetadataProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_SetCommonInstanceMetadata_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) SetDefaultNetworkTier(ctx context.Context, in *SetDefaultNetworkTierProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_SetDefaultNetworkTier_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *projectsClient) SetUsageExportBucket(ctx context.Context, in *SetUsageExportBucketProjectRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Projects_SetUsageExportBucket_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ProjectsServer is the server API for Projects service.
// All implementations should embed UnimplementedProjectsServer
// for forward compatibility
type ProjectsServer interface {
	// Disable this project as a shared VPC host project.
	DisableXpnHost(context.Context, *DisableXpnHostProjectRequest) (*Operation, error)
	// Disable a service resource (also known as service project) associated with
	// this host project.
	DisableXpnResource(context.Context, *DisableXpnResourceProjectRequest) (*Operation, error)
	// Enable this project as a shared VPC host project.
	EnableXpnHost(context.Context, *EnableXpnHostProjectRequest) (*Operation, error)
	// Enable service resource (a.k.a service project) for a host project, so that
	// subnets in the host project can be used by instances in the service
	// project.
	EnableXpnResource(context.Context, *EnableXpnResourceProjectRequest) (*Operation, error)
	// Returns the specified Project resource.
	//
	// To decrease latency for this method, you can optionally omit any unneeded
	// information from the response by using a field mask. This practice is
	// especially recommended for unused quota information (the `quotas` field).
	// To exclude one or more fields, set your request's `fields` query parameter
	// to only include the fields you need. For example, to only include the `id`
	// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
	// your request.
	Get(context.Context, *GetProjectRequest) (*Project, error)
	// Gets the shared VPC host project that this project links to. May be empty
	// if no link exists.
	GetXpnHost(context.Context, *GetXpnHostProjectRequest) (*Project, error)
	// Gets service resources (a.k.a service project) associated with this host
	// project.
	GetXpnResources(context.Context, *GetXpnResourcesProjectsRequest) (*ProjectsGetXpnResources, error)
	// Lists all shared VPC host projects visible to the user in an organization.
	ListXpnHosts(context.Context, *ListXpnHostsProjectsRequest) (*XpnHostList, error)
	// Moves a persistent disk from one zone to another.
	// *Note*: The moveDisk API will be deprecated on September 29, 2026.
	//
	// Starting September 29, 2025, you can't use the moveDisk API on new
	// projects. To move a disk to a different region or zone, follow the steps in
	// [Change the location of a
	// disk](https://cloud.google.com/compute/docs/disks/migrate-to-hyperdisk#migrate-to-hd).
	//
	// Projects that already use the moveDisk API can continue usage until
	// September 29, 2026.
	//
	// Starting November 1, 2025, API responses will include a warning message in
	// the response body about the upcoming deprecation. You can skip the message
	// to continue using the service without interruption.
	MoveDisk(context.Context, *MoveDiskProjectRequest) (*Operation, error)
	// Moves an instance and its attached persistent disks from one zone to
	// another.
	// *Note*: Moving VMs or disks by using this method might
	//
	//	cause unexpected behavior. For more information, see the [known
	//	issue](/compute/docs/troubleshooting/known-issues#moving_vms_or_disks_using_the_moveinstance_api_or_the_causes_unexpected_behavior).
	//
	// [Deprecated] This method is deprecated. See [moving instance across
	// zones](/compute/docs/instances/moving-instance-across-zones) instead.
	MoveInstance(context.Context, *MoveInstanceProjectRequest) (*Operation, error)
	// Sets the Cloud Armor tier of the project. To set ENTERPRISE or above the
	// billing account of the project must be subscribed to Cloud Armor
	// Enterprise. See Subscribing
	// to Cloud Armor Enterprise for more information.
	SetCloudArmorTier(context.Context, *SetCloudArmorTierProjectRequest) (*Operation, error)
	// Sets metadata common to all instances within the specified project using
	// the data included in the request.
	SetCommonInstanceMetadata(context.Context, *SetCommonInstanceMetadataProjectRequest) (*Operation, error)
	// Sets the default network tier of the project. The default network tier is
	// used when an address/forwardingRule/instance is created without specifying
	// the network tier field.
	SetDefaultNetworkTier(context.Context, *SetDefaultNetworkTierProjectRequest) (*Operation, error)
	// Enables the usage export feature and sets theusage export bucket
	// where reports are stored. If you provide an empty request body using this
	// method, the usage export feature will be disabled.
	SetUsageExportBucket(context.Context, *SetUsageExportBucketProjectRequest) (*Operation, error)
}

// UnimplementedProjectsServer should be embedded to have forward compatible implementations.
type UnimplementedProjectsServer struct {
}

func (UnimplementedProjectsServer) DisableXpnHost(context.Context, *DisableXpnHostProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableXpnHost not implemented")
}
func (UnimplementedProjectsServer) DisableXpnResource(context.Context, *DisableXpnResourceProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableXpnResource not implemented")
}
func (UnimplementedProjectsServer) EnableXpnHost(context.Context, *EnableXpnHostProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableXpnHost not implemented")
}
func (UnimplementedProjectsServer) EnableXpnResource(context.Context, *EnableXpnResourceProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableXpnResource not implemented")
}
func (UnimplementedProjectsServer) Get(context.Context, *GetProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedProjectsServer) GetXpnHost(context.Context, *GetXpnHostProjectRequest) (*Project, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetXpnHost not implemented")
}
func (UnimplementedProjectsServer) GetXpnResources(context.Context, *GetXpnResourcesProjectsRequest) (*ProjectsGetXpnResources, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetXpnResources not implemented")
}
func (UnimplementedProjectsServer) ListXpnHosts(context.Context, *ListXpnHostsProjectsRequest) (*XpnHostList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListXpnHosts not implemented")
}
func (UnimplementedProjectsServer) MoveDisk(context.Context, *MoveDiskProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveDisk not implemented")
}
func (UnimplementedProjectsServer) MoveInstance(context.Context, *MoveInstanceProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MoveInstance not implemented")
}
func (UnimplementedProjectsServer) SetCloudArmorTier(context.Context, *SetCloudArmorTierProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCloudArmorTier not implemented")
}
func (UnimplementedProjectsServer) SetCommonInstanceMetadata(context.Context, *SetCommonInstanceMetadataProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCommonInstanceMetadata not implemented")
}
func (UnimplementedProjectsServer) SetDefaultNetworkTier(context.Context, *SetDefaultNetworkTierProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetDefaultNetworkTier not implemented")
}
func (UnimplementedProjectsServer) SetUsageExportBucket(context.Context, *SetUsageExportBucketProjectRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUsageExportBucket not implemented")
}

// UnsafeProjectsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ProjectsServer will
// result in compilation errors.
type UnsafeProjectsServer interface {
	mustEmbedUnimplementedProjectsServer()
}

func RegisterProjectsServer(s grpc.ServiceRegistrar, srv ProjectsServer) {
	s.RegisterService(&Projects_ServiceDesc, srv)
}

func _Projects_DisableXpnHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableXpnHostProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).DisableXpnHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_DisableXpnHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).DisableXpnHost(ctx, req.(*DisableXpnHostProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_DisableXpnResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableXpnResourceProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).DisableXpnResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_DisableXpnResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).DisableXpnResource(ctx, req.(*DisableXpnResourceProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_EnableXpnHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableXpnHostProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).EnableXpnHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_EnableXpnHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).EnableXpnHost(ctx, req.(*EnableXpnHostProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_EnableXpnResource_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableXpnResourceProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).EnableXpnResource(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_EnableXpnResource_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).EnableXpnResource(ctx, req.(*EnableXpnResourceProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).Get(ctx, req.(*GetProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetXpnHost_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetXpnHostProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetXpnHost(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetXpnHost_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetXpnHost(ctx, req.(*GetXpnHostProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_GetXpnResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetXpnResourcesProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).GetXpnResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_GetXpnResources_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).GetXpnResources(ctx, req.(*GetXpnResourcesProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_ListXpnHosts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListXpnHostsProjectsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).ListXpnHosts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_ListXpnHosts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).ListXpnHosts(ctx, req.(*ListXpnHostsProjectsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_MoveDisk_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveDiskProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).MoveDisk(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_MoveDisk_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).MoveDisk(ctx, req.(*MoveDiskProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_MoveInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MoveInstanceProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).MoveInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_MoveInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).MoveInstance(ctx, req.(*MoveInstanceProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_SetCloudArmorTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCloudArmorTierProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).SetCloudArmorTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_SetCloudArmorTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).SetCloudArmorTier(ctx, req.(*SetCloudArmorTierProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_SetCommonInstanceMetadata_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCommonInstanceMetadataProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).SetCommonInstanceMetadata(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_SetCommonInstanceMetadata_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).SetCommonInstanceMetadata(ctx, req.(*SetCommonInstanceMetadataProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_SetDefaultNetworkTier_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetDefaultNetworkTierProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).SetDefaultNetworkTier(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_SetDefaultNetworkTier_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).SetDefaultNetworkTier(ctx, req.(*SetDefaultNetworkTierProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Projects_SetUsageExportBucket_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUsageExportBucketProjectRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ProjectsServer).SetUsageExportBucket(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Projects_SetUsageExportBucket_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ProjectsServer).SetUsageExportBucket(ctx, req.(*SetUsageExportBucketProjectRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Projects_ServiceDesc is the grpc.ServiceDesc for Projects service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Projects_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Projects",
	HandlerType: (*ProjectsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "DisableXpnHost",
			Handler:    _Projects_DisableXpnHost_Handler,
		},
		{
			MethodName: "DisableXpnResource",
			Handler:    _Projects_DisableXpnResource_Handler,
		},
		{
			MethodName: "EnableXpnHost",
			Handler:    _Projects_EnableXpnHost_Handler,
		},
		{
			MethodName: "EnableXpnResource",
			Handler:    _Projects_EnableXpnResource_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Projects_Get_Handler,
		},
		{
			MethodName: "GetXpnHost",
			Handler:    _Projects_GetXpnHost_Handler,
		},
		{
			MethodName: "GetXpnResources",
			Handler:    _Projects_GetXpnResources_Handler,
		},
		{
			MethodName: "ListXpnHosts",
			Handler:    _Projects_ListXpnHosts_Handler,
		},
		{
			MethodName: "MoveDisk",
			Handler:    _Projects_MoveDisk_Handler,
		},
		{
			MethodName: "MoveInstance",
			Handler:    _Projects_MoveInstance_Handler,
		},
		{
			MethodName: "SetCloudArmorTier",
			Handler:    _Projects_SetCloudArmorTier_Handler,
		},
		{
			MethodName: "SetCommonInstanceMetadata",
			Handler:    _Projects_SetCommonInstanceMetadata_Handler,
		},
		{
			MethodName: "SetDefaultNetworkTier",
			Handler:    _Projects_SetDefaultNetworkTier_Handler,
		},
		{
			MethodName: "SetUsageExportBucket",
			Handler:    _Projects_SetUsageExportBucket_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	PublicAdvertisedPrefixes_Announce_FullMethodName = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Announce"
	PublicAdvertisedPrefixes_Delete_FullMethodName   = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Delete"
	PublicAdvertisedPrefixes_Get_FullMethodName      = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Get"
	PublicAdvertisedPrefixes_Insert_FullMethodName   = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Insert"
	PublicAdvertisedPrefixes_List_FullMethodName     = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/List"
	PublicAdvertisedPrefixes_Patch_FullMethodName    = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Patch"
	PublicAdvertisedPrefixes_Withdraw_FullMethodName = "/google.cloud.compute.v1.PublicAdvertisedPrefixes/Withdraw"
)

// PublicAdvertisedPrefixesClient is the client API for PublicAdvertisedPrefixes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicAdvertisedPrefixesClient interface {
	// Announces the specified PublicAdvertisedPrefix
	Announce(ctx context.Context, in *AnnouncePublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified PublicAdvertisedPrefix
	Delete(ctx context.Context, in *DeletePublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified PublicAdvertisedPrefix resource.
	Get(ctx context.Context, in *GetPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*PublicAdvertisedPrefix, error)
	// Creates a PublicAdvertisedPrefix in the specified project
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the PublicAdvertisedPrefixes for a project.
	List(ctx context.Context, in *ListPublicAdvertisedPrefixesRequest, opts ...grpc.CallOption) (*PublicAdvertisedPrefixList, error)
	// Patches the specified Router resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Withdraws the specified PublicAdvertisedPrefix
	Withdraw(ctx context.Context, in *WithdrawPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
}

type publicAdvertisedPrefixesClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicAdvertisedPrefixesClient(cc grpc.ClientConnInterface) PublicAdvertisedPrefixesClient {
	return &publicAdvertisedPrefixesClient{cc}
}

func (c *publicAdvertisedPrefixesClient) Announce(ctx context.Context, in *AnnouncePublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_Announce_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAdvertisedPrefixesClient) Delete(ctx context.Context, in *DeletePublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAdvertisedPrefixesClient) Get(ctx context.Context, in *GetPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*PublicAdvertisedPrefix, error) {
	out := new(PublicAdvertisedPrefix)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAdvertisedPrefixesClient) Insert(ctx context.Context, in *InsertPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAdvertisedPrefixesClient) List(ctx context.Context, in *ListPublicAdvertisedPrefixesRequest, opts ...grpc.CallOption) (*PublicAdvertisedPrefixList, error) {
	out := new(PublicAdvertisedPrefixList)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAdvertisedPrefixesClient) Patch(ctx context.Context, in *PatchPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicAdvertisedPrefixesClient) Withdraw(ctx context.Context, in *WithdrawPublicAdvertisedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicAdvertisedPrefixes_Withdraw_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublicAdvertisedPrefixesServer is the server API for PublicAdvertisedPrefixes service.
// All implementations should embed UnimplementedPublicAdvertisedPrefixesServer
// for forward compatibility
type PublicAdvertisedPrefixesServer interface {
	// Announces the specified PublicAdvertisedPrefix
	Announce(context.Context, *AnnouncePublicAdvertisedPrefixeRequest) (*Operation, error)
	// Deletes the specified PublicAdvertisedPrefix
	Delete(context.Context, *DeletePublicAdvertisedPrefixeRequest) (*Operation, error)
	// Returns the specified PublicAdvertisedPrefix resource.
	Get(context.Context, *GetPublicAdvertisedPrefixeRequest) (*PublicAdvertisedPrefix, error)
	// Creates a PublicAdvertisedPrefix in the specified project
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertPublicAdvertisedPrefixeRequest) (*Operation, error)
	// Lists the PublicAdvertisedPrefixes for a project.
	List(context.Context, *ListPublicAdvertisedPrefixesRequest) (*PublicAdvertisedPrefixList, error)
	// Patches the specified Router resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchPublicAdvertisedPrefixeRequest) (*Operation, error)
	// Withdraws the specified PublicAdvertisedPrefix
	Withdraw(context.Context, *WithdrawPublicAdvertisedPrefixeRequest) (*Operation, error)
}

// UnimplementedPublicAdvertisedPrefixesServer should be embedded to have forward compatible implementations.
type UnimplementedPublicAdvertisedPrefixesServer struct {
}

func (UnimplementedPublicAdvertisedPrefixesServer) Announce(context.Context, *AnnouncePublicAdvertisedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Announce not implemented")
}
func (UnimplementedPublicAdvertisedPrefixesServer) Delete(context.Context, *DeletePublicAdvertisedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPublicAdvertisedPrefixesServer) Get(context.Context, *GetPublicAdvertisedPrefixeRequest) (*PublicAdvertisedPrefix, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPublicAdvertisedPrefixesServer) Insert(context.Context, *InsertPublicAdvertisedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedPublicAdvertisedPrefixesServer) List(context.Context, *ListPublicAdvertisedPrefixesRequest) (*PublicAdvertisedPrefixList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPublicAdvertisedPrefixesServer) Patch(context.Context, *PatchPublicAdvertisedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedPublicAdvertisedPrefixesServer) Withdraw(context.Context, *WithdrawPublicAdvertisedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}

// UnsafePublicAdvertisedPrefixesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicAdvertisedPrefixesServer will
// result in compilation errors.
type UnsafePublicAdvertisedPrefixesServer interface {
	mustEmbedUnimplementedPublicAdvertisedPrefixesServer()
}

func RegisterPublicAdvertisedPrefixesServer(s grpc.ServiceRegistrar, srv PublicAdvertisedPrefixesServer) {
	s.RegisterService(&PublicAdvertisedPrefixes_ServiceDesc, srv)
}

func _PublicAdvertisedPrefixes_Announce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnnouncePublicAdvertisedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).Announce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_Announce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).Announce(ctx, req.(*AnnouncePublicAdvertisedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAdvertisedPrefixes_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePublicAdvertisedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).Delete(ctx, req.(*DeletePublicAdvertisedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAdvertisedPrefixes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicAdvertisedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).Get(ctx, req.(*GetPublicAdvertisedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAdvertisedPrefixes_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertPublicAdvertisedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).Insert(ctx, req.(*InsertPublicAdvertisedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAdvertisedPrefixes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPublicAdvertisedPrefixesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).List(ctx, req.(*ListPublicAdvertisedPrefixesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAdvertisedPrefixes_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPublicAdvertisedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).Patch(ctx, req.(*PatchPublicAdvertisedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicAdvertisedPrefixes_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawPublicAdvertisedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicAdvertisedPrefixesServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicAdvertisedPrefixes_Withdraw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicAdvertisedPrefixesServer).Withdraw(ctx, req.(*WithdrawPublicAdvertisedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PublicAdvertisedPrefixes_ServiceDesc is the grpc.ServiceDesc for PublicAdvertisedPrefixes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublicAdvertisedPrefixes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.PublicAdvertisedPrefixes",
	HandlerType: (*PublicAdvertisedPrefixesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Announce",
			Handler:    _PublicAdvertisedPrefixes_Announce_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PublicAdvertisedPrefixes_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PublicAdvertisedPrefixes_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _PublicAdvertisedPrefixes_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PublicAdvertisedPrefixes_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _PublicAdvertisedPrefixes_Patch_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _PublicAdvertisedPrefixes_Withdraw_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	PublicDelegatedPrefixes_AggregatedList_FullMethodName = "/google.cloud.compute.v1.PublicDelegatedPrefixes/AggregatedList"
	PublicDelegatedPrefixes_Announce_FullMethodName       = "/google.cloud.compute.v1.PublicDelegatedPrefixes/Announce"
	PublicDelegatedPrefixes_Delete_FullMethodName         = "/google.cloud.compute.v1.PublicDelegatedPrefixes/Delete"
	PublicDelegatedPrefixes_Get_FullMethodName            = "/google.cloud.compute.v1.PublicDelegatedPrefixes/Get"
	PublicDelegatedPrefixes_Insert_FullMethodName         = "/google.cloud.compute.v1.PublicDelegatedPrefixes/Insert"
	PublicDelegatedPrefixes_List_FullMethodName           = "/google.cloud.compute.v1.PublicDelegatedPrefixes/List"
	PublicDelegatedPrefixes_Patch_FullMethodName          = "/google.cloud.compute.v1.PublicDelegatedPrefixes/Patch"
	PublicDelegatedPrefixes_Withdraw_FullMethodName       = "/google.cloud.compute.v1.PublicDelegatedPrefixes/Withdraw"
)

// PublicDelegatedPrefixesClient is the client API for PublicDelegatedPrefixes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PublicDelegatedPrefixesClient interface {
	// Lists all PublicDelegatedPrefix resources owned by the specific project
	// across all scopes.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListPublicDelegatedPrefixesRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefixAggregatedList, error)
	// Announces the specified PublicDelegatedPrefix in the given region.
	Announce(ctx context.Context, in *AnnouncePublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified PublicDelegatedPrefix in the given region.
	Delete(ctx context.Context, in *DeletePublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified PublicDelegatedPrefix resource in the given region.
	Get(ctx context.Context, in *GetPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefix, error)
	// Creates a PublicDelegatedPrefix in the specified project in the given
	// region using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the PublicDelegatedPrefixes for a project in the given region.
	List(ctx context.Context, in *ListPublicDelegatedPrefixesRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefixList, error)
	// Patches the specified PublicDelegatedPrefix resource with the data included
	// in the request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
	// Withdraws the specified PublicDelegatedPrefix in the given region.
	Withdraw(ctx context.Context, in *WithdrawPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error)
}

type publicDelegatedPrefixesClient struct {
	cc grpc.ClientConnInterface
}

func NewPublicDelegatedPrefixesClient(cc grpc.ClientConnInterface) PublicDelegatedPrefixesClient {
	return &publicDelegatedPrefixesClient{cc}
}

func (c *publicDelegatedPrefixesClient) AggregatedList(ctx context.Context, in *AggregatedListPublicDelegatedPrefixesRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefixAggregatedList, error) {
	out := new(PublicDelegatedPrefixAggregatedList)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) Announce(ctx context.Context, in *AnnouncePublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_Announce_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) Delete(ctx context.Context, in *DeletePublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) Get(ctx context.Context, in *GetPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefix, error) {
	out := new(PublicDelegatedPrefix)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) Insert(ctx context.Context, in *InsertPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) List(ctx context.Context, in *ListPublicDelegatedPrefixesRequest, opts ...grpc.CallOption) (*PublicDelegatedPrefixList, error) {
	out := new(PublicDelegatedPrefixList)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) Patch(ctx context.Context, in *PatchPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *publicDelegatedPrefixesClient) Withdraw(ctx context.Context, in *WithdrawPublicDelegatedPrefixeRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, PublicDelegatedPrefixes_Withdraw_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PublicDelegatedPrefixesServer is the server API for PublicDelegatedPrefixes service.
// All implementations should embed UnimplementedPublicDelegatedPrefixesServer
// for forward compatibility
type PublicDelegatedPrefixesServer interface {
	// Lists all PublicDelegatedPrefix resources owned by the specific project
	// across all scopes.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListPublicDelegatedPrefixesRequest) (*PublicDelegatedPrefixAggregatedList, error)
	// Announces the specified PublicDelegatedPrefix in the given region.
	Announce(context.Context, *AnnouncePublicDelegatedPrefixeRequest) (*Operation, error)
	// Deletes the specified PublicDelegatedPrefix in the given region.
	Delete(context.Context, *DeletePublicDelegatedPrefixeRequest) (*Operation, error)
	// Returns the specified PublicDelegatedPrefix resource in the given region.
	Get(context.Context, *GetPublicDelegatedPrefixeRequest) (*PublicDelegatedPrefix, error)
	// Creates a PublicDelegatedPrefix in the specified project in the given
	// region using the parameters that are included in the request.
	Insert(context.Context, *InsertPublicDelegatedPrefixeRequest) (*Operation, error)
	// Lists the PublicDelegatedPrefixes for a project in the given region.
	List(context.Context, *ListPublicDelegatedPrefixesRequest) (*PublicDelegatedPrefixList, error)
	// Patches the specified PublicDelegatedPrefix resource with the data included
	// in the request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchPublicDelegatedPrefixeRequest) (*Operation, error)
	// Withdraws the specified PublicDelegatedPrefix in the given region.
	Withdraw(context.Context, *WithdrawPublicDelegatedPrefixeRequest) (*Operation, error)
}

// UnimplementedPublicDelegatedPrefixesServer should be embedded to have forward compatible implementations.
type UnimplementedPublicDelegatedPrefixesServer struct {
}

func (UnimplementedPublicDelegatedPrefixesServer) AggregatedList(context.Context, *AggregatedListPublicDelegatedPrefixesRequest) (*PublicDelegatedPrefixAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) Announce(context.Context, *AnnouncePublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Announce not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) Delete(context.Context, *DeletePublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) Get(context.Context, *GetPublicDelegatedPrefixeRequest) (*PublicDelegatedPrefix, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) Insert(context.Context, *InsertPublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) List(context.Context, *ListPublicDelegatedPrefixesRequest) (*PublicDelegatedPrefixList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) Patch(context.Context, *PatchPublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedPublicDelegatedPrefixesServer) Withdraw(context.Context, *WithdrawPublicDelegatedPrefixeRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Withdraw not implemented")
}

// UnsafePublicDelegatedPrefixesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PublicDelegatedPrefixesServer will
// result in compilation errors.
type UnsafePublicDelegatedPrefixesServer interface {
	mustEmbedUnimplementedPublicDelegatedPrefixesServer()
}

func RegisterPublicDelegatedPrefixesServer(s grpc.ServiceRegistrar, srv PublicDelegatedPrefixesServer) {
	s.RegisterService(&PublicDelegatedPrefixes_ServiceDesc, srv)
}

func _PublicDelegatedPrefixes_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListPublicDelegatedPrefixesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).AggregatedList(ctx, req.(*AggregatedListPublicDelegatedPrefixesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_Announce_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AnnouncePublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).Announce(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_Announce_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).Announce(ctx, req.(*AnnouncePublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).Delete(ctx, req.(*DeletePublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).Get(ctx, req.(*GetPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).Insert(ctx, req.(*InsertPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPublicDelegatedPrefixesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).List(ctx, req.(*ListPublicDelegatedPrefixesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).Patch(ctx, req.(*PatchPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PublicDelegatedPrefixes_Withdraw_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WithdrawPublicDelegatedPrefixeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PublicDelegatedPrefixesServer).Withdraw(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PublicDelegatedPrefixes_Withdraw_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PublicDelegatedPrefixesServer).Withdraw(ctx, req.(*WithdrawPublicDelegatedPrefixeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PublicDelegatedPrefixes_ServiceDesc is the grpc.ServiceDesc for PublicDelegatedPrefixes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PublicDelegatedPrefixes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.PublicDelegatedPrefixes",
	HandlerType: (*PublicDelegatedPrefixesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _PublicDelegatedPrefixes_AggregatedList_Handler,
		},
		{
			MethodName: "Announce",
			Handler:    _PublicDelegatedPrefixes_Announce_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _PublicDelegatedPrefixes_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _PublicDelegatedPrefixes_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _PublicDelegatedPrefixes_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _PublicDelegatedPrefixes_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _PublicDelegatedPrefixes_Patch_Handler,
		},
		{
			MethodName: "Withdraw",
			Handler:    _PublicDelegatedPrefixes_Withdraw_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionAutoscalers_Delete_FullMethodName             = "/google.cloud.compute.v1.RegionAutoscalers/Delete"
	RegionAutoscalers_Get_FullMethodName                = "/google.cloud.compute.v1.RegionAutoscalers/Get"
	RegionAutoscalers_Insert_FullMethodName             = "/google.cloud.compute.v1.RegionAutoscalers/Insert"
	RegionAutoscalers_List_FullMethodName               = "/google.cloud.compute.v1.RegionAutoscalers/List"
	RegionAutoscalers_Patch_FullMethodName              = "/google.cloud.compute.v1.RegionAutoscalers/Patch"
	RegionAutoscalers_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.RegionAutoscalers/TestIamPermissions"
	RegionAutoscalers_Update_FullMethodName             = "/google.cloud.compute.v1.RegionAutoscalers/Update"
)

// RegionAutoscalersClient is the client API for RegionAutoscalers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionAutoscalersClient interface {
	// Deletes the specified autoscaler.
	Delete(ctx context.Context, in *DeleteRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified autoscaler.
	Get(ctx context.Context, in *GetRegionAutoscalerRequest, opts ...grpc.CallOption) (*Autoscaler, error)
	// Creates an autoscaler in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of autoscalers contained within
	// the specified region.
	List(ctx context.Context, in *ListRegionAutoscalersRequest, opts ...grpc.CallOption) (*RegionAutoscalerList, error)
	// Updates an autoscaler in the specified project using
	// the data included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionAutoscalerRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates an autoscaler in the specified project using
	// the data included in the request.
	Update(ctx context.Context, in *UpdateRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionAutoscalersClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionAutoscalersClient(cc grpc.ClientConnInterface) RegionAutoscalersClient {
	return &regionAutoscalersClient{cc}
}

func (c *regionAutoscalersClient) Delete(ctx context.Context, in *DeleteRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionAutoscalers_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAutoscalersClient) Get(ctx context.Context, in *GetRegionAutoscalerRequest, opts ...grpc.CallOption) (*Autoscaler, error) {
	out := new(Autoscaler)
	err := c.cc.Invoke(ctx, RegionAutoscalers_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAutoscalersClient) Insert(ctx context.Context, in *InsertRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionAutoscalers_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAutoscalersClient) List(ctx context.Context, in *ListRegionAutoscalersRequest, opts ...grpc.CallOption) (*RegionAutoscalerList, error) {
	out := new(RegionAutoscalerList)
	err := c.cc.Invoke(ctx, RegionAutoscalers_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAutoscalersClient) Patch(ctx context.Context, in *PatchRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionAutoscalers_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAutoscalersClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionAutoscalerRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionAutoscalers_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionAutoscalersClient) Update(ctx context.Context, in *UpdateRegionAutoscalerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionAutoscalers_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionAutoscalersServer is the server API for RegionAutoscalers service.
// All implementations should embed UnimplementedRegionAutoscalersServer
// for forward compatibility
type RegionAutoscalersServer interface {
	// Deletes the specified autoscaler.
	Delete(context.Context, *DeleteRegionAutoscalerRequest) (*Operation, error)
	// Returns the specified autoscaler.
	Get(context.Context, *GetRegionAutoscalerRequest) (*Autoscaler, error)
	// Creates an autoscaler in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertRegionAutoscalerRequest) (*Operation, error)
	// Retrieves a list of autoscalers contained within
	// the specified region.
	List(context.Context, *ListRegionAutoscalersRequest) (*RegionAutoscalerList, error)
	// Updates an autoscaler in the specified project using
	// the data included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRegionAutoscalerRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionAutoscalerRequest) (*TestPermissionsResponse, error)
	// Updates an autoscaler in the specified project using
	// the data included in the request.
	Update(context.Context, *UpdateRegionAutoscalerRequest) (*Operation, error)
}

// UnimplementedRegionAutoscalersServer should be embedded to have forward compatible implementations.
type UnimplementedRegionAutoscalersServer struct {
}

func (UnimplementedRegionAutoscalersServer) Delete(context.Context, *DeleteRegionAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionAutoscalersServer) Get(context.Context, *GetRegionAutoscalerRequest) (*Autoscaler, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionAutoscalersServer) Insert(context.Context, *InsertRegionAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionAutoscalersServer) List(context.Context, *ListRegionAutoscalersRequest) (*RegionAutoscalerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionAutoscalersServer) Patch(context.Context, *PatchRegionAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionAutoscalersServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionAutoscalerRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedRegionAutoscalersServer) Update(context.Context, *UpdateRegionAutoscalerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeRegionAutoscalersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionAutoscalersServer will
// result in compilation errors.
type UnsafeRegionAutoscalersServer interface {
	mustEmbedUnimplementedRegionAutoscalersServer()
}

func RegisterRegionAutoscalersServer(s grpc.ServiceRegistrar, srv RegionAutoscalersServer) {
	s.RegisterService(&RegionAutoscalers_ServiceDesc, srv)
}

func _RegionAutoscalers_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).Delete(ctx, req.(*DeleteRegionAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAutoscalers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).Get(ctx, req.(*GetRegionAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAutoscalers_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).Insert(ctx, req.(*InsertRegionAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAutoscalers_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionAutoscalersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).List(ctx, req.(*ListRegionAutoscalersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAutoscalers_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).Patch(ctx, req.(*PatchRegionAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAutoscalers_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionAutoscalers_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionAutoscalerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionAutoscalersServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionAutoscalers_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionAutoscalersServer).Update(ctx, req.(*UpdateRegionAutoscalerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionAutoscalers_ServiceDesc is the grpc.ServiceDesc for RegionAutoscalers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionAutoscalers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionAutoscalers",
	HandlerType: (*RegionAutoscalersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionAutoscalers_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionAutoscalers_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionAutoscalers_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionAutoscalers_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionAutoscalers_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionAutoscalers_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionAutoscalers_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionBackendServices_Delete_FullMethodName             = "/google.cloud.compute.v1.RegionBackendServices/Delete"
	RegionBackendServices_Get_FullMethodName                = "/google.cloud.compute.v1.RegionBackendServices/Get"
	RegionBackendServices_GetHealth_FullMethodName          = "/google.cloud.compute.v1.RegionBackendServices/GetHealth"
	RegionBackendServices_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.RegionBackendServices/GetIamPolicy"
	RegionBackendServices_Insert_FullMethodName             = "/google.cloud.compute.v1.RegionBackendServices/Insert"
	RegionBackendServices_List_FullMethodName               = "/google.cloud.compute.v1.RegionBackendServices/List"
	RegionBackendServices_ListUsable_FullMethodName         = "/google.cloud.compute.v1.RegionBackendServices/ListUsable"
	RegionBackendServices_Patch_FullMethodName              = "/google.cloud.compute.v1.RegionBackendServices/Patch"
	RegionBackendServices_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.RegionBackendServices/SetIamPolicy"
	RegionBackendServices_SetSecurityPolicy_FullMethodName  = "/google.cloud.compute.v1.RegionBackendServices/SetSecurityPolicy"
	RegionBackendServices_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.RegionBackendServices/TestIamPermissions"
	RegionBackendServices_Update_FullMethodName             = "/google.cloud.compute.v1.RegionBackendServices/Update"
)

// RegionBackendServicesClient is the client API for RegionBackendServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionBackendServicesClient interface {
	// Deletes the specified regional BackendService resource.
	Delete(ctx context.Context, in *DeleteRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified regional BackendService resource.
	Get(ctx context.Context, in *GetRegionBackendServiceRequest, opts ...grpc.CallOption) (*BackendService, error)
	// Gets the most recent health check results for this
	// regional BackendService.
	GetHealth(ctx context.Context, in *GetHealthRegionBackendServiceRequest, opts ...grpc.CallOption) (*BackendServiceGroupHealth, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a regional BackendService resource in the specified project using
	// the data included in the request. For more information, see
	// Backend services overview.
	Insert(ctx context.Context, in *InsertRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of regional BackendService resources available to the
	// specified project in the given region.
	List(ctx context.Context, in *ListRegionBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceList, error)
	// Retrieves a list of all usable backend services in the specified project in
	// the given region.
	ListUsable(ctx context.Context, in *ListUsableRegionBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceListUsable, error)
	// Updates the specified regional BackendService resource with the data
	// included in the request. For more information, see
	// Understanding backend services This method
	// supports PATCH semantics and uses the JSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the Google Cloud Armor security policy for the specified backend
	// service. For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionBackendServiceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified regional BackendService resource with the data
	// included in the request. For more information,
	// see
	// Backend services overview.
	Update(ctx context.Context, in *UpdateRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionBackendServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionBackendServicesClient(cc grpc.ClientConnInterface) RegionBackendServicesClient {
	return &regionBackendServicesClient{cc}
}

func (c *regionBackendServicesClient) Delete(ctx context.Context, in *DeleteRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionBackendServices_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) Get(ctx context.Context, in *GetRegionBackendServiceRequest, opts ...grpc.CallOption) (*BackendService, error) {
	out := new(BackendService)
	err := c.cc.Invoke(ctx, RegionBackendServices_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) GetHealth(ctx context.Context, in *GetHealthRegionBackendServiceRequest, opts ...grpc.CallOption) (*BackendServiceGroupHealth, error) {
	out := new(BackendServiceGroupHealth)
	err := c.cc.Invoke(ctx, RegionBackendServices_GetHealth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionBackendServices_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) Insert(ctx context.Context, in *InsertRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionBackendServices_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) List(ctx context.Context, in *ListRegionBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceList, error) {
	out := new(BackendServiceList)
	err := c.cc.Invoke(ctx, RegionBackendServices_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) ListUsable(ctx context.Context, in *ListUsableRegionBackendServicesRequest, opts ...grpc.CallOption) (*BackendServiceListUsable, error) {
	out := new(BackendServiceListUsable)
	err := c.cc.Invoke(ctx, RegionBackendServices_ListUsable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) Patch(ctx context.Context, in *PatchRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionBackendServices_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionBackendServiceRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionBackendServices_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionBackendServices_SetSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionBackendServiceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionBackendServices_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionBackendServicesClient) Update(ctx context.Context, in *UpdateRegionBackendServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionBackendServices_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionBackendServicesServer is the server API for RegionBackendServices service.
// All implementations should embed UnimplementedRegionBackendServicesServer
// for forward compatibility
type RegionBackendServicesServer interface {
	// Deletes the specified regional BackendService resource.
	Delete(context.Context, *DeleteRegionBackendServiceRequest) (*Operation, error)
	// Returns the specified regional BackendService resource.
	Get(context.Context, *GetRegionBackendServiceRequest) (*BackendService, error)
	// Gets the most recent health check results for this
	// regional BackendService.
	GetHealth(context.Context, *GetHealthRegionBackendServiceRequest) (*BackendServiceGroupHealth, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyRegionBackendServiceRequest) (*Policy, error)
	// Creates a regional BackendService resource in the specified project using
	// the data included in the request. For more information, see
	// Backend services overview.
	Insert(context.Context, *InsertRegionBackendServiceRequest) (*Operation, error)
	// Retrieves the list of regional BackendService resources available to the
	// specified project in the given region.
	List(context.Context, *ListRegionBackendServicesRequest) (*BackendServiceList, error)
	// Retrieves a list of all usable backend services in the specified project in
	// the given region.
	ListUsable(context.Context, *ListUsableRegionBackendServicesRequest) (*BackendServiceListUsable, error)
	// Updates the specified regional BackendService resource with the data
	// included in the request. For more information, see
	// Understanding backend services This method
	// supports PATCH semantics and uses the JSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRegionBackendServiceRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyRegionBackendServiceRequest) (*Policy, error)
	// Sets the Google Cloud Armor security policy for the specified backend
	// service. For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(context.Context, *SetSecurityPolicyRegionBackendServiceRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionBackendServiceRequest) (*TestPermissionsResponse, error)
	// Updates the specified regional BackendService resource with the data
	// included in the request. For more information,
	// see
	// Backend services overview.
	Update(context.Context, *UpdateRegionBackendServiceRequest) (*Operation, error)
}

// UnimplementedRegionBackendServicesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionBackendServicesServer struct {
}

func (UnimplementedRegionBackendServicesServer) Delete(context.Context, *DeleteRegionBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionBackendServicesServer) Get(context.Context, *GetRegionBackendServiceRequest) (*BackendService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionBackendServicesServer) GetHealth(context.Context, *GetHealthRegionBackendServiceRequest) (*BackendServiceGroupHealth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedRegionBackendServicesServer) GetIamPolicy(context.Context, *GetIamPolicyRegionBackendServiceRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedRegionBackendServicesServer) Insert(context.Context, *InsertRegionBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionBackendServicesServer) List(context.Context, *ListRegionBackendServicesRequest) (*BackendServiceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionBackendServicesServer) ListUsable(context.Context, *ListUsableRegionBackendServicesRequest) (*BackendServiceListUsable, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsable not implemented")
}
func (UnimplementedRegionBackendServicesServer) Patch(context.Context, *PatchRegionBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionBackendServicesServer) SetIamPolicy(context.Context, *SetIamPolicyRegionBackendServiceRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedRegionBackendServicesServer) SetSecurityPolicy(context.Context, *SetSecurityPolicyRegionBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSecurityPolicy not implemented")
}
func (UnimplementedRegionBackendServicesServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionBackendServiceRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedRegionBackendServicesServer) Update(context.Context, *UpdateRegionBackendServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeRegionBackendServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionBackendServicesServer will
// result in compilation errors.
type UnsafeRegionBackendServicesServer interface {
	mustEmbedUnimplementedRegionBackendServicesServer()
}

func RegisterRegionBackendServicesServer(s grpc.ServiceRegistrar, srv RegionBackendServicesServer) {
	s.RegisterService(&RegionBackendServices_ServiceDesc, srv)
}

func _RegionBackendServices_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).Delete(ctx, req.(*DeleteRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).Get(ctx, req.(*GetRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).GetHealth(ctx, req.(*GetHealthRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).GetIamPolicy(ctx, req.(*GetIamPolicyRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).Insert(ctx, req.(*InsertRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionBackendServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).List(ctx, req.(*ListRegionBackendServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_ListUsable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsableRegionBackendServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).ListUsable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_ListUsable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).ListUsable(ctx, req.(*ListUsableRegionBackendServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).Patch(ctx, req.(*PatchRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).SetIamPolicy(ctx, req.(*SetIamPolicyRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_SetSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSecurityPolicyRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).SetSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_SetSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).SetSecurityPolicy(ctx, req.(*SetSecurityPolicyRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionBackendServices_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionBackendServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionBackendServicesServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionBackendServices_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionBackendServicesServer).Update(ctx, req.(*UpdateRegionBackendServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionBackendServices_ServiceDesc is the grpc.ServiceDesc for RegionBackendServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionBackendServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionBackendServices",
	HandlerType: (*RegionBackendServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionBackendServices_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionBackendServices_Get_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _RegionBackendServices_GetHealth_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _RegionBackendServices_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionBackendServices_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionBackendServices_List_Handler,
		},
		{
			MethodName: "ListUsable",
			Handler:    _RegionBackendServices_ListUsable_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionBackendServices_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _RegionBackendServices_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetSecurityPolicy",
			Handler:    _RegionBackendServices_SetSecurityPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionBackendServices_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionBackendServices_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionCommitments_AggregatedList_FullMethodName = "/google.cloud.compute.v1.RegionCommitments/AggregatedList"
	RegionCommitments_Get_FullMethodName            = "/google.cloud.compute.v1.RegionCommitments/Get"
	RegionCommitments_Insert_FullMethodName         = "/google.cloud.compute.v1.RegionCommitments/Insert"
	RegionCommitments_List_FullMethodName           = "/google.cloud.compute.v1.RegionCommitments/List"
	RegionCommitments_Update_FullMethodName         = "/google.cloud.compute.v1.RegionCommitments/Update"
)

// RegionCommitmentsClient is the client API for RegionCommitments service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionCommitmentsClient interface {
	// Retrieves an aggregated list of commitments by region.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListRegionCommitmentsRequest, opts ...grpc.CallOption) (*CommitmentAggregatedList, error)
	// Returns the specified commitment resource.
	Get(ctx context.Context, in *GetRegionCommitmentRequest, opts ...grpc.CallOption) (*Commitment, error)
	// Creates a commitment in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertRegionCommitmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of commitments contained within
	// the specified region.
	List(ctx context.Context, in *ListRegionCommitmentsRequest, opts ...grpc.CallOption) (*CommitmentList, error)
	// Updates the specified commitment with the data included in the request.
	// Update is performed only on selected fields included as part of
	// update-mask. Only the following fields can be updated: auto_renew and plan.
	Update(ctx context.Context, in *UpdateRegionCommitmentRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionCommitmentsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionCommitmentsClient(cc grpc.ClientConnInterface) RegionCommitmentsClient {
	return &regionCommitmentsClient{cc}
}

func (c *regionCommitmentsClient) AggregatedList(ctx context.Context, in *AggregatedListRegionCommitmentsRequest, opts ...grpc.CallOption) (*CommitmentAggregatedList, error) {
	out := new(CommitmentAggregatedList)
	err := c.cc.Invoke(ctx, RegionCommitments_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionCommitmentsClient) Get(ctx context.Context, in *GetRegionCommitmentRequest, opts ...grpc.CallOption) (*Commitment, error) {
	out := new(Commitment)
	err := c.cc.Invoke(ctx, RegionCommitments_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionCommitmentsClient) Insert(ctx context.Context, in *InsertRegionCommitmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionCommitments_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionCommitmentsClient) List(ctx context.Context, in *ListRegionCommitmentsRequest, opts ...grpc.CallOption) (*CommitmentList, error) {
	out := new(CommitmentList)
	err := c.cc.Invoke(ctx, RegionCommitments_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionCommitmentsClient) Update(ctx context.Context, in *UpdateRegionCommitmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionCommitments_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionCommitmentsServer is the server API for RegionCommitments service.
// All implementations should embed UnimplementedRegionCommitmentsServer
// for forward compatibility
type RegionCommitmentsServer interface {
	// Retrieves an aggregated list of commitments by region.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListRegionCommitmentsRequest) (*CommitmentAggregatedList, error)
	// Returns the specified commitment resource.
	Get(context.Context, *GetRegionCommitmentRequest) (*Commitment, error)
	// Creates a commitment in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertRegionCommitmentRequest) (*Operation, error)
	// Retrieves a list of commitments contained within
	// the specified region.
	List(context.Context, *ListRegionCommitmentsRequest) (*CommitmentList, error)
	// Updates the specified commitment with the data included in the request.
	// Update is performed only on selected fields included as part of
	// update-mask. Only the following fields can be updated: auto_renew and plan.
	Update(context.Context, *UpdateRegionCommitmentRequest) (*Operation, error)
}

// UnimplementedRegionCommitmentsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionCommitmentsServer struct {
}

func (UnimplementedRegionCommitmentsServer) AggregatedList(context.Context, *AggregatedListRegionCommitmentsRequest) (*CommitmentAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedRegionCommitmentsServer) Get(context.Context, *GetRegionCommitmentRequest) (*Commitment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionCommitmentsServer) Insert(context.Context, *InsertRegionCommitmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionCommitmentsServer) List(context.Context, *ListRegionCommitmentsRequest) (*CommitmentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionCommitmentsServer) Update(context.Context, *UpdateRegionCommitmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeRegionCommitmentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionCommitmentsServer will
// result in compilation errors.
type UnsafeRegionCommitmentsServer interface {
	mustEmbedUnimplementedRegionCommitmentsServer()
}

func RegisterRegionCommitmentsServer(s grpc.ServiceRegistrar, srv RegionCommitmentsServer) {
	s.RegisterService(&RegionCommitments_ServiceDesc, srv)
}

func _RegionCommitments_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListRegionCommitmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionCommitmentsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionCommitments_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionCommitmentsServer).AggregatedList(ctx, req.(*AggregatedListRegionCommitmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionCommitments_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionCommitmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionCommitmentsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionCommitments_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionCommitmentsServer).Get(ctx, req.(*GetRegionCommitmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionCommitments_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionCommitmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionCommitmentsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionCommitments_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionCommitmentsServer).Insert(ctx, req.(*InsertRegionCommitmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionCommitments_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionCommitmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionCommitmentsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionCommitments_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionCommitmentsServer).List(ctx, req.(*ListRegionCommitmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionCommitments_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionCommitmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionCommitmentsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionCommitments_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionCommitmentsServer).Update(ctx, req.(*UpdateRegionCommitmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionCommitments_ServiceDesc is the grpc.ServiceDesc for RegionCommitments service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionCommitments_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionCommitments",
	HandlerType: (*RegionCommitmentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _RegionCommitments_AggregatedList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionCommitments_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionCommitments_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionCommitments_List_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionCommitments_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionDiskTypes_Get_FullMethodName  = "/google.cloud.compute.v1.RegionDiskTypes/Get"
	RegionDiskTypes_List_FullMethodName = "/google.cloud.compute.v1.RegionDiskTypes/List"
)

// RegionDiskTypesClient is the client API for RegionDiskTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionDiskTypesClient interface {
	// Returns the specified regional disk type.
	Get(ctx context.Context, in *GetRegionDiskTypeRequest, opts ...grpc.CallOption) (*DiskType, error)
	// Retrieves a list of regional disk types available to the specified project.
	List(ctx context.Context, in *ListRegionDiskTypesRequest, opts ...grpc.CallOption) (*RegionDiskTypeList, error)
}

type regionDiskTypesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionDiskTypesClient(cc grpc.ClientConnInterface) RegionDiskTypesClient {
	return &regionDiskTypesClient{cc}
}

func (c *regionDiskTypesClient) Get(ctx context.Context, in *GetRegionDiskTypeRequest, opts ...grpc.CallOption) (*DiskType, error) {
	out := new(DiskType)
	err := c.cc.Invoke(ctx, RegionDiskTypes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDiskTypesClient) List(ctx context.Context, in *ListRegionDiskTypesRequest, opts ...grpc.CallOption) (*RegionDiskTypeList, error) {
	out := new(RegionDiskTypeList)
	err := c.cc.Invoke(ctx, RegionDiskTypes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionDiskTypesServer is the server API for RegionDiskTypes service.
// All implementations should embed UnimplementedRegionDiskTypesServer
// for forward compatibility
type RegionDiskTypesServer interface {
	// Returns the specified regional disk type.
	Get(context.Context, *GetRegionDiskTypeRequest) (*DiskType, error)
	// Retrieves a list of regional disk types available to the specified project.
	List(context.Context, *ListRegionDiskTypesRequest) (*RegionDiskTypeList, error)
}

// UnimplementedRegionDiskTypesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionDiskTypesServer struct {
}

func (UnimplementedRegionDiskTypesServer) Get(context.Context, *GetRegionDiskTypeRequest) (*DiskType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionDiskTypesServer) List(context.Context, *ListRegionDiskTypesRequest) (*RegionDiskTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeRegionDiskTypesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionDiskTypesServer will
// result in compilation errors.
type UnsafeRegionDiskTypesServer interface {
	mustEmbedUnimplementedRegionDiskTypesServer()
}

func RegisterRegionDiskTypesServer(s grpc.ServiceRegistrar, srv RegionDiskTypesServer) {
	s.RegisterService(&RegionDiskTypes_ServiceDesc, srv)
}

func _RegionDiskTypes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionDiskTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDiskTypesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDiskTypes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDiskTypesServer).Get(ctx, req.(*GetRegionDiskTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDiskTypes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionDiskTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDiskTypesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDiskTypes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDiskTypesServer).List(ctx, req.(*ListRegionDiskTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionDiskTypes_ServiceDesc is the grpc.ServiceDesc for RegionDiskTypes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionDiskTypes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionDiskTypes",
	HandlerType: (*RegionDiskTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RegionDiskTypes_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionDiskTypes_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionDisks_AddResourcePolicies_FullMethodName       = "/google.cloud.compute.v1.RegionDisks/AddResourcePolicies"
	RegionDisks_BulkInsert_FullMethodName                = "/google.cloud.compute.v1.RegionDisks/BulkInsert"
	RegionDisks_CreateSnapshot_FullMethodName            = "/google.cloud.compute.v1.RegionDisks/CreateSnapshot"
	RegionDisks_Delete_FullMethodName                    = "/google.cloud.compute.v1.RegionDisks/Delete"
	RegionDisks_Get_FullMethodName                       = "/google.cloud.compute.v1.RegionDisks/Get"
	RegionDisks_GetIamPolicy_FullMethodName              = "/google.cloud.compute.v1.RegionDisks/GetIamPolicy"
	RegionDisks_Insert_FullMethodName                    = "/google.cloud.compute.v1.RegionDisks/Insert"
	RegionDisks_List_FullMethodName                      = "/google.cloud.compute.v1.RegionDisks/List"
	RegionDisks_RemoveResourcePolicies_FullMethodName    = "/google.cloud.compute.v1.RegionDisks/RemoveResourcePolicies"
	RegionDisks_Resize_FullMethodName                    = "/google.cloud.compute.v1.RegionDisks/Resize"
	RegionDisks_SetIamPolicy_FullMethodName              = "/google.cloud.compute.v1.RegionDisks/SetIamPolicy"
	RegionDisks_SetLabels_FullMethodName                 = "/google.cloud.compute.v1.RegionDisks/SetLabels"
	RegionDisks_StartAsyncReplication_FullMethodName     = "/google.cloud.compute.v1.RegionDisks/StartAsyncReplication"
	RegionDisks_StopAsyncReplication_FullMethodName      = "/google.cloud.compute.v1.RegionDisks/StopAsyncReplication"
	RegionDisks_StopGroupAsyncReplication_FullMethodName = "/google.cloud.compute.v1.RegionDisks/StopGroupAsyncReplication"
	RegionDisks_TestIamPermissions_FullMethodName        = "/google.cloud.compute.v1.RegionDisks/TestIamPermissions"
	RegionDisks_Update_FullMethodName                    = "/google.cloud.compute.v1.RegionDisks/Update"
)

// RegionDisksClient is the client API for RegionDisks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionDisksClient interface {
	// Adds existing resource policies to a regional disk. You can only add one
	// policy which will be applied to this disk for scheduling snapshot
	// creation.
	AddResourcePolicies(ctx context.Context, in *AddResourcePoliciesRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Bulk create a set of disks.
	BulkInsert(ctx context.Context, in *BulkInsertRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Creates a snapshot of a specified persistent disk. For regular snapshot
	// creation, consider using snapshots.insert
	// instead, as that method supports more features, such as creating snapshots
	// in a project different from the source disk project.
	CreateSnapshot(ctx context.Context, in *CreateSnapshotRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified regional persistent disk. Deleting a regional disk
	// removes all the replicas of its data permanently and is irreversible.
	// However, deleting a disk does not delete anysnapshots
	// previously made from the disk. You must separatelydelete
	// snapshots.
	Delete(ctx context.Context, in *DeleteRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns a specified regional persistent disk.
	Get(ctx context.Context, in *GetRegionDiskRequest, opts ...grpc.CallOption) (*Disk, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionDiskRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a persistent regional disk in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of persistent disks contained within
	// the specified region.
	List(ctx context.Context, in *ListRegionDisksRequest, opts ...grpc.CallOption) (*DiskList, error)
	// Removes resource policies from a regional disk.
	RemoveResourcePolicies(ctx context.Context, in *RemoveResourcePoliciesRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Resizes the specified regional persistent disk.
	Resize(ctx context.Context, in *ResizeRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionDiskRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on the target regional disk.
	SetLabels(ctx context.Context, in *SetLabelsRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Starts asynchronous replication.
	// Must be invoked on the primary disk.
	StartAsyncReplication(ctx context.Context, in *StartAsyncReplicationRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Stops asynchronous replication.
	// Can be invoked either on the primary or on the secondary disk.
	StopAsyncReplication(ctx context.Context, in *StopAsyncReplicationRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Stops asynchronous replication for a consistency group of disks.
	// Can be invoked either in the primary or secondary scope.
	StopGroupAsyncReplication(ctx context.Context, in *StopGroupAsyncReplicationRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionDiskRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Update the specified disk with the data included in the request. Update is
	// performed only on selected fields included as part of update-mask. Only the
	// following fields can be modified: user_license.
	Update(ctx context.Context, in *UpdateRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionDisksClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionDisksClient(cc grpc.ClientConnInterface) RegionDisksClient {
	return &regionDisksClient{cc}
}

func (c *regionDisksClient) AddResourcePolicies(ctx context.Context, in *AddResourcePoliciesRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_AddResourcePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) BulkInsert(ctx context.Context, in *BulkInsertRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_BulkInsert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) CreateSnapshot(ctx context.Context, in *CreateSnapshotRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_CreateSnapshot_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) Delete(ctx context.Context, in *DeleteRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) Get(ctx context.Context, in *GetRegionDiskRequest, opts ...grpc.CallOption) (*Disk, error) {
	out := new(Disk)
	err := c.cc.Invoke(ctx, RegionDisks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionDiskRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionDisks_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) Insert(ctx context.Context, in *InsertRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) List(ctx context.Context, in *ListRegionDisksRequest, opts ...grpc.CallOption) (*DiskList, error) {
	out := new(DiskList)
	err := c.cc.Invoke(ctx, RegionDisks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) RemoveResourcePolicies(ctx context.Context, in *RemoveResourcePoliciesRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_RemoveResourcePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) Resize(ctx context.Context, in *ResizeRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_Resize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionDiskRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionDisks_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) SetLabels(ctx context.Context, in *SetLabelsRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) StartAsyncReplication(ctx context.Context, in *StartAsyncReplicationRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_StartAsyncReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) StopAsyncReplication(ctx context.Context, in *StopAsyncReplicationRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_StopAsyncReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) StopGroupAsyncReplication(ctx context.Context, in *StopGroupAsyncReplicationRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_StopGroupAsyncReplication_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionDiskRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionDisks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionDisksClient) Update(ctx context.Context, in *UpdateRegionDiskRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionDisks_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionDisksServer is the server API for RegionDisks service.
// All implementations should embed UnimplementedRegionDisksServer
// for forward compatibility
type RegionDisksServer interface {
	// Adds existing resource policies to a regional disk. You can only add one
	// policy which will be applied to this disk for scheduling snapshot
	// creation.
	AddResourcePolicies(context.Context, *AddResourcePoliciesRegionDiskRequest) (*Operation, error)
	// Bulk create a set of disks.
	BulkInsert(context.Context, *BulkInsertRegionDiskRequest) (*Operation, error)
	// Creates a snapshot of a specified persistent disk. For regular snapshot
	// creation, consider using snapshots.insert
	// instead, as that method supports more features, such as creating snapshots
	// in a project different from the source disk project.
	CreateSnapshot(context.Context, *CreateSnapshotRegionDiskRequest) (*Operation, error)
	// Deletes the specified regional persistent disk. Deleting a regional disk
	// removes all the replicas of its data permanently and is irreversible.
	// However, deleting a disk does not delete anysnapshots
	// previously made from the disk. You must separatelydelete
	// snapshots.
	Delete(context.Context, *DeleteRegionDiskRequest) (*Operation, error)
	// Returns a specified regional persistent disk.
	Get(context.Context, *GetRegionDiskRequest) (*Disk, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyRegionDiskRequest) (*Policy, error)
	// Creates a persistent regional disk in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertRegionDiskRequest) (*Operation, error)
	// Retrieves the list of persistent disks contained within
	// the specified region.
	List(context.Context, *ListRegionDisksRequest) (*DiskList, error)
	// Removes resource policies from a regional disk.
	RemoveResourcePolicies(context.Context, *RemoveResourcePoliciesRegionDiskRequest) (*Operation, error)
	// Resizes the specified regional persistent disk.
	Resize(context.Context, *ResizeRegionDiskRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyRegionDiskRequest) (*Policy, error)
	// Sets the labels on the target regional disk.
	SetLabels(context.Context, *SetLabelsRegionDiskRequest) (*Operation, error)
	// Starts asynchronous replication.
	// Must be invoked on the primary disk.
	StartAsyncReplication(context.Context, *StartAsyncReplicationRegionDiskRequest) (*Operation, error)
	// Stops asynchronous replication.
	// Can be invoked either on the primary or on the secondary disk.
	StopAsyncReplication(context.Context, *StopAsyncReplicationRegionDiskRequest) (*Operation, error)
	// Stops asynchronous replication for a consistency group of disks.
	// Can be invoked either in the primary or secondary scope.
	StopGroupAsyncReplication(context.Context, *StopGroupAsyncReplicationRegionDiskRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionDiskRequest) (*TestPermissionsResponse, error)
	// Update the specified disk with the data included in the request. Update is
	// performed only on selected fields included as part of update-mask. Only the
	// following fields can be modified: user_license.
	Update(context.Context, *UpdateRegionDiskRequest) (*Operation, error)
}

// UnimplementedRegionDisksServer should be embedded to have forward compatible implementations.
type UnimplementedRegionDisksServer struct {
}

func (UnimplementedRegionDisksServer) AddResourcePolicies(context.Context, *AddResourcePoliciesRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddResourcePolicies not implemented")
}
func (UnimplementedRegionDisksServer) BulkInsert(context.Context, *BulkInsertRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkInsert not implemented")
}
func (UnimplementedRegionDisksServer) CreateSnapshot(context.Context, *CreateSnapshotRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateSnapshot not implemented")
}
func (UnimplementedRegionDisksServer) Delete(context.Context, *DeleteRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionDisksServer) Get(context.Context, *GetRegionDiskRequest) (*Disk, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionDisksServer) GetIamPolicy(context.Context, *GetIamPolicyRegionDiskRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedRegionDisksServer) Insert(context.Context, *InsertRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionDisksServer) List(context.Context, *ListRegionDisksRequest) (*DiskList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionDisksServer) RemoveResourcePolicies(context.Context, *RemoveResourcePoliciesRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveResourcePolicies not implemented")
}
func (UnimplementedRegionDisksServer) Resize(context.Context, *ResizeRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resize not implemented")
}
func (UnimplementedRegionDisksServer) SetIamPolicy(context.Context, *SetIamPolicyRegionDiskRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedRegionDisksServer) SetLabels(context.Context, *SetLabelsRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedRegionDisksServer) StartAsyncReplication(context.Context, *StartAsyncReplicationRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartAsyncReplication not implemented")
}
func (UnimplementedRegionDisksServer) StopAsyncReplication(context.Context, *StopAsyncReplicationRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopAsyncReplication not implemented")
}
func (UnimplementedRegionDisksServer) StopGroupAsyncReplication(context.Context, *StopGroupAsyncReplicationRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopGroupAsyncReplication not implemented")
}
func (UnimplementedRegionDisksServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionDiskRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedRegionDisksServer) Update(context.Context, *UpdateRegionDiskRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeRegionDisksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionDisksServer will
// result in compilation errors.
type UnsafeRegionDisksServer interface {
	mustEmbedUnimplementedRegionDisksServer()
}

func RegisterRegionDisksServer(s grpc.ServiceRegistrar, srv RegionDisksServer) {
	s.RegisterService(&RegionDisks_ServiceDesc, srv)
}

func _RegionDisks_AddResourcePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddResourcePoliciesRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).AddResourcePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_AddResourcePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).AddResourcePolicies(ctx, req.(*AddResourcePoliciesRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_BulkInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkInsertRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).BulkInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_BulkInsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).BulkInsert(ctx, req.(*BulkInsertRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_CreateSnapshot_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateSnapshotRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).CreateSnapshot(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_CreateSnapshot_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).CreateSnapshot(ctx, req.(*CreateSnapshotRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).Delete(ctx, req.(*DeleteRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).Get(ctx, req.(*GetRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).GetIamPolicy(ctx, req.(*GetIamPolicyRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).Insert(ctx, req.(*InsertRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionDisksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).List(ctx, req.(*ListRegionDisksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_RemoveResourcePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveResourcePoliciesRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).RemoveResourcePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_RemoveResourcePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).RemoveResourcePolicies(ctx, req.(*RemoveResourcePoliciesRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_Resize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).Resize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_Resize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).Resize(ctx, req.(*ResizeRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).SetIamPolicy(ctx, req.(*SetIamPolicyRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).SetLabels(ctx, req.(*SetLabelsRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_StartAsyncReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartAsyncReplicationRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).StartAsyncReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_StartAsyncReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).StartAsyncReplication(ctx, req.(*StartAsyncReplicationRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_StopAsyncReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopAsyncReplicationRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).StopAsyncReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_StopAsyncReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).StopAsyncReplication(ctx, req.(*StopAsyncReplicationRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_StopGroupAsyncReplication_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopGroupAsyncReplicationRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).StopGroupAsyncReplication(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_StopGroupAsyncReplication_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).StopGroupAsyncReplication(ctx, req.(*StopGroupAsyncReplicationRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionDisks_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionDiskRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionDisksServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionDisks_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionDisksServer).Update(ctx, req.(*UpdateRegionDiskRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionDisks_ServiceDesc is the grpc.ServiceDesc for RegionDisks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionDisks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionDisks",
	HandlerType: (*RegionDisksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddResourcePolicies",
			Handler:    _RegionDisks_AddResourcePolicies_Handler,
		},
		{
			MethodName: "BulkInsert",
			Handler:    _RegionDisks_BulkInsert_Handler,
		},
		{
			MethodName: "CreateSnapshot",
			Handler:    _RegionDisks_CreateSnapshot_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegionDisks_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionDisks_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _RegionDisks_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionDisks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionDisks_List_Handler,
		},
		{
			MethodName: "RemoveResourcePolicies",
			Handler:    _RegionDisks_RemoveResourcePolicies_Handler,
		},
		{
			MethodName: "Resize",
			Handler:    _RegionDisks_Resize_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _RegionDisks_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _RegionDisks_SetLabels_Handler,
		},
		{
			MethodName: "StartAsyncReplication",
			Handler:    _RegionDisks_StartAsyncReplication_Handler,
		},
		{
			MethodName: "StopAsyncReplication",
			Handler:    _RegionDisks_StopAsyncReplication_Handler,
		},
		{
			MethodName: "StopGroupAsyncReplication",
			Handler:    _RegionDisks_StopGroupAsyncReplication_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionDisks_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionDisks_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionHealthCheckServices_Delete_FullMethodName = "/google.cloud.compute.v1.RegionHealthCheckServices/Delete"
	RegionHealthCheckServices_Get_FullMethodName    = "/google.cloud.compute.v1.RegionHealthCheckServices/Get"
	RegionHealthCheckServices_Insert_FullMethodName = "/google.cloud.compute.v1.RegionHealthCheckServices/Insert"
	RegionHealthCheckServices_List_FullMethodName   = "/google.cloud.compute.v1.RegionHealthCheckServices/List"
	RegionHealthCheckServices_Patch_FullMethodName  = "/google.cloud.compute.v1.RegionHealthCheckServices/Patch"
)

// RegionHealthCheckServicesClient is the client API for RegionHealthCheckServices service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionHealthCheckServicesClient interface {
	// Deletes the specified regional HealthCheckService.
	Delete(ctx context.Context, in *DeleteRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified regional HealthCheckService resource.
	Get(ctx context.Context, in *GetRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*HealthCheckService, error)
	// Creates a regional HealthCheckService resource in the
	// specified project and region using the data included in the request.
	Insert(ctx context.Context, in *InsertRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all the HealthCheckService resources that have been
	// configured for the specified project in the given region.
	List(ctx context.Context, in *ListRegionHealthCheckServicesRequest, opts ...grpc.CallOption) (*HealthCheckServicesList, error)
	// Updates the specified regional HealthCheckService resource
	// with the data included in the request.  This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionHealthCheckServicesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionHealthCheckServicesClient(cc grpc.ClientConnInterface) RegionHealthCheckServicesClient {
	return &regionHealthCheckServicesClient{cc}
}

func (c *regionHealthCheckServicesClient) Delete(ctx context.Context, in *DeleteRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthCheckServices_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthCheckServicesClient) Get(ctx context.Context, in *GetRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*HealthCheckService, error) {
	out := new(HealthCheckService)
	err := c.cc.Invoke(ctx, RegionHealthCheckServices_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthCheckServicesClient) Insert(ctx context.Context, in *InsertRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthCheckServices_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthCheckServicesClient) List(ctx context.Context, in *ListRegionHealthCheckServicesRequest, opts ...grpc.CallOption) (*HealthCheckServicesList, error) {
	out := new(HealthCheckServicesList)
	err := c.cc.Invoke(ctx, RegionHealthCheckServices_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthCheckServicesClient) Patch(ctx context.Context, in *PatchRegionHealthCheckServiceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthCheckServices_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionHealthCheckServicesServer is the server API for RegionHealthCheckServices service.
// All implementations should embed UnimplementedRegionHealthCheckServicesServer
// for forward compatibility
type RegionHealthCheckServicesServer interface {
	// Deletes the specified regional HealthCheckService.
	Delete(context.Context, *DeleteRegionHealthCheckServiceRequest) (*Operation, error)
	// Returns the specified regional HealthCheckService resource.
	Get(context.Context, *GetRegionHealthCheckServiceRequest) (*HealthCheckService, error)
	// Creates a regional HealthCheckService resource in the
	// specified project and region using the data included in the request.
	Insert(context.Context, *InsertRegionHealthCheckServiceRequest) (*Operation, error)
	// Lists all the HealthCheckService resources that have been
	// configured for the specified project in the given region.
	List(context.Context, *ListRegionHealthCheckServicesRequest) (*HealthCheckServicesList, error)
	// Updates the specified regional HealthCheckService resource
	// with the data included in the request.  This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRegionHealthCheckServiceRequest) (*Operation, error)
}

// UnimplementedRegionHealthCheckServicesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionHealthCheckServicesServer struct {
}

func (UnimplementedRegionHealthCheckServicesServer) Delete(context.Context, *DeleteRegionHealthCheckServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionHealthCheckServicesServer) Get(context.Context, *GetRegionHealthCheckServiceRequest) (*HealthCheckService, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionHealthCheckServicesServer) Insert(context.Context, *InsertRegionHealthCheckServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionHealthCheckServicesServer) List(context.Context, *ListRegionHealthCheckServicesRequest) (*HealthCheckServicesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionHealthCheckServicesServer) Patch(context.Context, *PatchRegionHealthCheckServiceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeRegionHealthCheckServicesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionHealthCheckServicesServer will
// result in compilation errors.
type UnsafeRegionHealthCheckServicesServer interface {
	mustEmbedUnimplementedRegionHealthCheckServicesServer()
}

func RegisterRegionHealthCheckServicesServer(s grpc.ServiceRegistrar, srv RegionHealthCheckServicesServer) {
	s.RegisterService(&RegionHealthCheckServices_ServiceDesc, srv)
}

func _RegionHealthCheckServices_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionHealthCheckServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthCheckServicesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthCheckServices_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthCheckServicesServer).Delete(ctx, req.(*DeleteRegionHealthCheckServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthCheckServices_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionHealthCheckServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthCheckServicesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthCheckServices_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthCheckServicesServer).Get(ctx, req.(*GetRegionHealthCheckServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthCheckServices_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionHealthCheckServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthCheckServicesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthCheckServices_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthCheckServicesServer).Insert(ctx, req.(*InsertRegionHealthCheckServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthCheckServices_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionHealthCheckServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthCheckServicesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthCheckServices_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthCheckServicesServer).List(ctx, req.(*ListRegionHealthCheckServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthCheckServices_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionHealthCheckServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthCheckServicesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthCheckServices_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthCheckServicesServer).Patch(ctx, req.(*PatchRegionHealthCheckServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionHealthCheckServices_ServiceDesc is the grpc.ServiceDesc for RegionHealthCheckServices service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionHealthCheckServices_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionHealthCheckServices",
	HandlerType: (*RegionHealthCheckServicesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionHealthCheckServices_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionHealthCheckServices_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionHealthCheckServices_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionHealthCheckServices_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionHealthCheckServices_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionHealthChecks_Delete_FullMethodName             = "/google.cloud.compute.v1.RegionHealthChecks/Delete"
	RegionHealthChecks_Get_FullMethodName                = "/google.cloud.compute.v1.RegionHealthChecks/Get"
	RegionHealthChecks_Insert_FullMethodName             = "/google.cloud.compute.v1.RegionHealthChecks/Insert"
	RegionHealthChecks_List_FullMethodName               = "/google.cloud.compute.v1.RegionHealthChecks/List"
	RegionHealthChecks_Patch_FullMethodName              = "/google.cloud.compute.v1.RegionHealthChecks/Patch"
	RegionHealthChecks_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.RegionHealthChecks/TestIamPermissions"
	RegionHealthChecks_Update_FullMethodName             = "/google.cloud.compute.v1.RegionHealthChecks/Update"
)

// RegionHealthChecksClient is the client API for RegionHealthChecks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionHealthChecksClient interface {
	// Deletes the specified HealthCheck resource.
	Delete(ctx context.Context, in *DeleteRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified HealthCheck resource.
	Get(ctx context.Context, in *GetRegionHealthCheckRequest, opts ...grpc.CallOption) (*HealthCheck, error)
	// Creates a HealthCheck resource in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of HealthCheck resources available to the specified
	// project.
	List(ctx context.Context, in *ListRegionHealthChecksRequest, opts ...grpc.CallOption) (*HealthCheckList, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionHealthCheckRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request.
	Update(ctx context.Context, in *UpdateRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionHealthChecksClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionHealthChecksClient(cc grpc.ClientConnInterface) RegionHealthChecksClient {
	return &regionHealthChecksClient{cc}
}

func (c *regionHealthChecksClient) Delete(ctx context.Context, in *DeleteRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthChecks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthChecksClient) Get(ctx context.Context, in *GetRegionHealthCheckRequest, opts ...grpc.CallOption) (*HealthCheck, error) {
	out := new(HealthCheck)
	err := c.cc.Invoke(ctx, RegionHealthChecks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthChecksClient) Insert(ctx context.Context, in *InsertRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthChecks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthChecksClient) List(ctx context.Context, in *ListRegionHealthChecksRequest, opts ...grpc.CallOption) (*HealthCheckList, error) {
	out := new(HealthCheckList)
	err := c.cc.Invoke(ctx, RegionHealthChecks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthChecksClient) Patch(ctx context.Context, in *PatchRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthChecks_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthChecksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionHealthCheckRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionHealthChecks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionHealthChecksClient) Update(ctx context.Context, in *UpdateRegionHealthCheckRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionHealthChecks_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionHealthChecksServer is the server API for RegionHealthChecks service.
// All implementations should embed UnimplementedRegionHealthChecksServer
// for forward compatibility
type RegionHealthChecksServer interface {
	// Deletes the specified HealthCheck resource.
	Delete(context.Context, *DeleteRegionHealthCheckRequest) (*Operation, error)
	// Returns the specified HealthCheck resource.
	Get(context.Context, *GetRegionHealthCheckRequest) (*HealthCheck, error)
	// Creates a HealthCheck resource in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertRegionHealthCheckRequest) (*Operation, error)
	// Retrieves the list of HealthCheck resources available to the specified
	// project.
	List(context.Context, *ListRegionHealthChecksRequest) (*HealthCheckList, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRegionHealthCheckRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionHealthCheckRequest) (*TestPermissionsResponse, error)
	// Updates a HealthCheck resource in the specified project using the data
	// included in the request.
	Update(context.Context, *UpdateRegionHealthCheckRequest) (*Operation, error)
}

// UnimplementedRegionHealthChecksServer should be embedded to have forward compatible implementations.
type UnimplementedRegionHealthChecksServer struct {
}

func (UnimplementedRegionHealthChecksServer) Delete(context.Context, *DeleteRegionHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionHealthChecksServer) Get(context.Context, *GetRegionHealthCheckRequest) (*HealthCheck, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionHealthChecksServer) Insert(context.Context, *InsertRegionHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionHealthChecksServer) List(context.Context, *ListRegionHealthChecksRequest) (*HealthCheckList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionHealthChecksServer) Patch(context.Context, *PatchRegionHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionHealthChecksServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionHealthCheckRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedRegionHealthChecksServer) Update(context.Context, *UpdateRegionHealthCheckRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeRegionHealthChecksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionHealthChecksServer will
// result in compilation errors.
type UnsafeRegionHealthChecksServer interface {
	mustEmbedUnimplementedRegionHealthChecksServer()
}

func RegisterRegionHealthChecksServer(s grpc.ServiceRegistrar, srv RegionHealthChecksServer) {
	s.RegisterService(&RegionHealthChecks_ServiceDesc, srv)
}

func _RegionHealthChecks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).Delete(ctx, req.(*DeleteRegionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthChecks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).Get(ctx, req.(*GetRegionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthChecks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).Insert(ctx, req.(*InsertRegionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthChecks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionHealthChecksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).List(ctx, req.(*ListRegionHealthChecksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthChecks_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).Patch(ctx, req.(*PatchRegionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthChecks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionHealthChecks_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionHealthCheckRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionHealthChecksServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionHealthChecks_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionHealthChecksServer).Update(ctx, req.(*UpdateRegionHealthCheckRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionHealthChecks_ServiceDesc is the grpc.ServiceDesc for RegionHealthChecks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionHealthChecks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionHealthChecks",
	HandlerType: (*RegionHealthChecksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionHealthChecks_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionHealthChecks_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionHealthChecks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionHealthChecks_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionHealthChecks_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionHealthChecks_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionHealthChecks_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionInstanceGroupManagers_AbandonInstances_FullMethodName         = "/google.cloud.compute.v1.RegionInstanceGroupManagers/AbandonInstances"
	RegionInstanceGroupManagers_ApplyUpdatesToInstances_FullMethodName  = "/google.cloud.compute.v1.RegionInstanceGroupManagers/ApplyUpdatesToInstances"
	RegionInstanceGroupManagers_CreateInstances_FullMethodName          = "/google.cloud.compute.v1.RegionInstanceGroupManagers/CreateInstances"
	RegionInstanceGroupManagers_Delete_FullMethodName                   = "/google.cloud.compute.v1.RegionInstanceGroupManagers/Delete"
	RegionInstanceGroupManagers_DeleteInstances_FullMethodName          = "/google.cloud.compute.v1.RegionInstanceGroupManagers/DeleteInstances"
	RegionInstanceGroupManagers_DeletePerInstanceConfigs_FullMethodName = "/google.cloud.compute.v1.RegionInstanceGroupManagers/DeletePerInstanceConfigs"
	RegionInstanceGroupManagers_Get_FullMethodName                      = "/google.cloud.compute.v1.RegionInstanceGroupManagers/Get"
	RegionInstanceGroupManagers_Insert_FullMethodName                   = "/google.cloud.compute.v1.RegionInstanceGroupManagers/Insert"
	RegionInstanceGroupManagers_List_FullMethodName                     = "/google.cloud.compute.v1.RegionInstanceGroupManagers/List"
	RegionInstanceGroupManagers_ListErrors_FullMethodName               = "/google.cloud.compute.v1.RegionInstanceGroupManagers/ListErrors"
	RegionInstanceGroupManagers_ListManagedInstances_FullMethodName     = "/google.cloud.compute.v1.RegionInstanceGroupManagers/ListManagedInstances"
	RegionInstanceGroupManagers_ListPerInstanceConfigs_FullMethodName   = "/google.cloud.compute.v1.RegionInstanceGroupManagers/ListPerInstanceConfigs"
	RegionInstanceGroupManagers_Patch_FullMethodName                    = "/google.cloud.compute.v1.RegionInstanceGroupManagers/Patch"
	RegionInstanceGroupManagers_PatchPerInstanceConfigs_FullMethodName  = "/google.cloud.compute.v1.RegionInstanceGroupManagers/PatchPerInstanceConfigs"
	RegionInstanceGroupManagers_RecreateInstances_FullMethodName        = "/google.cloud.compute.v1.RegionInstanceGroupManagers/RecreateInstances"
	RegionInstanceGroupManagers_Resize_FullMethodName                   = "/google.cloud.compute.v1.RegionInstanceGroupManagers/Resize"
	RegionInstanceGroupManagers_ResumeInstances_FullMethodName          = "/google.cloud.compute.v1.RegionInstanceGroupManagers/ResumeInstances"
	RegionInstanceGroupManagers_SetInstanceTemplate_FullMethodName      = "/google.cloud.compute.v1.RegionInstanceGroupManagers/SetInstanceTemplate"
	RegionInstanceGroupManagers_SetTargetPools_FullMethodName           = "/google.cloud.compute.v1.RegionInstanceGroupManagers/SetTargetPools"
	RegionInstanceGroupManagers_StartInstances_FullMethodName           = "/google.cloud.compute.v1.RegionInstanceGroupManagers/StartInstances"
	RegionInstanceGroupManagers_StopInstances_FullMethodName            = "/google.cloud.compute.v1.RegionInstanceGroupManagers/StopInstances"
	RegionInstanceGroupManagers_SuspendInstances_FullMethodName         = "/google.cloud.compute.v1.RegionInstanceGroupManagers/SuspendInstances"
	RegionInstanceGroupManagers_UpdatePerInstanceConfigs_FullMethodName = "/google.cloud.compute.v1.RegionInstanceGroupManagers/UpdatePerInstanceConfigs"
)

// RegionInstanceGroupManagersClient is the client API for RegionInstanceGroupManagers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionInstanceGroupManagersClient interface {
	// Flags the specified instances to be immediately removed from the managed
	// instance group. Abandoning an instance does not delete the
	// instance, but it does remove the instance from any target pools that are
	// applied by the managed instance group. This method reduces thetargetSize of the managed instance group by the
	// number of instances that you abandon. This operation is marked asDONE when the action is scheduled even if the instances have
	// not yet been removed from the group. You must separately verify the
	// status of the abandoning action with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	AbandonInstances(ctx context.Context, in *AbandonInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Apply updates to selected instances the managed instance group.
	ApplyUpdatesToInstances(ctx context.Context, in *ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Creates instances with per-instance configurations in this regional managed
	// instance group. Instances are created using the current instance template.
	// The create instances operation is marked DONE if
	// the createInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of thecreating or actions with the listmanagedinstances
	// method.
	CreateInstances(ctx context.Context, in *CreateInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified managed instance group and all of the instances
	// in that group.
	Delete(ctx context.Context, in *DeleteRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately deleted. The instances are also removed from any target
	// pools of which they were a member. This method reduces thetargetSize of the managed instance group by the number of
	// instances that you delete.
	// The deleteInstances operation is marked DONE if
	// the deleteInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of thedeleting action with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	DeleteInstances(ctx context.Context, in *DeleteInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes selected per-instance configurations for the managed instance
	// group.
	DeletePerInstanceConfigs(ctx context.Context, in *DeletePerInstanceConfigsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns all of the details about the specified managed instance group.
	Get(ctx context.Context, in *GetRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*InstanceGroupManager, error)
	// Creates a managed instance group using the information that you specify
	// in the request. After the group is created, instances in the group are
	// created using the specified instance template.
	// This operation is marked as DONE when the group is created
	// even if the instances in the group have not yet been created. You must
	// separately verify the status of the individual instances with thelistmanagedinstances
	// method.
	//
	// A regional managed instance group can contain up to 2000 instances.
	Insert(ctx context.Context, in *InsertRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of managed instance groups that are contained
	// within the specified region.
	List(ctx context.Context, in *ListRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagerList, error)
	// Lists all errors thrown by actions on instances for a given regional
	// managed instance group. The filter andorderBy query parameters are not supported.
	ListErrors(ctx context.Context, in *ListErrorsRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagersListErrorsResponse, error)
	// Lists the instances in the managed instance group and instances that are
	// scheduled to be created. The list includes any current actions
	// that the group has scheduled for its instances. The orderBy
	// query parameter is not supported.   The `pageToken` query parameter is
	// supported only if the group's `listManagedInstancesResults` field is set
	// to `PAGINATED`.
	ListManagedInstances(ctx context.Context, in *ListManagedInstancesRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagersListInstancesResponse, error)
	// Lists all of the per-instance configurations defined for the managed
	// instance group. The orderBy query parameter is not supported.
	ListPerInstanceConfigs(ctx context.Context, in *ListPerInstanceConfigsRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagersListInstanceConfigsResp, error)
	// Updates a managed instance group using the information that you specify
	// in the request.
	// This operation is marked as DONE when the group is patched
	// even if the instances in the group are still in the process of being
	// patched. You must separately verify the status of the individual instances
	// with the listmanagedinstances
	// method. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	//
	// If you update your group to specify a new template or instance
	// configuration, it's possible that your intended specification for each VM
	// in the group is different from the current state of that VM. To learn how
	// to apply an updated configuration to the VMs in a MIG, seeUpdating instances in
	// a MIG.
	Patch(ctx context.Context, in *PatchRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts or patches per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	PatchPerInstanceConfigs(ctx context.Context, in *PatchPerInstanceConfigsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified VM instances in the managed instance group to be
	// immediately recreated. Each instance is recreated using the group's current
	// configuration. This operation is marked as DONE when the flag
	// is set even if the instances have not yet been recreated. You must
	// separately verify the status of each instance by checking itscurrentAction field; for more information, see Checking
	// the status of managed instances.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	RecreateInstances(ctx context.Context, in *RecreateInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the intended size of the managed instance group. If you increase
	// the size, the group creates new instances using the current instance
	// template. If you decrease the size, the group deletes one or more
	// instances.
	//
	// The resize operation is marked DONE if theresize request is successful. The underlying actions take
	// additional time. You must separately verify the status of thecreating or deleting actions with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	Resize(ctx context.Context, in *ResizeRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// resumed. This method increases thetargetSize and decreases the targetSuspendedSize
	// of the managed instance group by the number of instances that you resume.
	// The resumeInstances operation is marked DONE if
	// the resumeInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theRESUMING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are suspended. For
	// example, if an instance was previously suspended using the suspendInstances
	// method, it can be resumed using the resumeInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are resumed.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	ResumeInstances(ctx context.Context, in *ResumeInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the instance template to use when creating new instances or recreating
	// instances in this group. Existing instances are not affected.
	SetInstanceTemplate(ctx context.Context, in *SetInstanceTemplateRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Modifies the target pools to which all new instances in this group are
	// assigned. Existing instances in the group are not affected.
	SetTargetPools(ctx context.Context, in *SetTargetPoolsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// started. This method increases thetargetSize and decreases the targetStoppedSize
	// of the managed instance group by the number of instances that you start.
	// The startInstances operation is marked DONE if
	// the startInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTARTING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are stopped. For
	// example, if an instance was previously stopped using the stopInstances
	// method, it can be started using the startInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are started.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StartInstances(ctx context.Context, in *StartInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately stopped. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetStoppedSize
	// of the managed instance group by the number of instances that you stop.
	// The stopInstances operation is marked DONE if
	// the stopInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTOPPING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays stopping the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is stopped.
	//
	// Stopped instances can be started using the startInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StopInstances(ctx context.Context, in *StopInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately suspended. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetSuspendedSize
	// of the managed instance group by the number of instances that you suspend.
	// The suspendInstances operation is marked DONE if
	// the suspendInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSUSPENDING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays suspension of the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is suspended.
	//
	// Suspended instances can be resumed using the resumeInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	SuspendInstances(ctx context.Context, in *SuspendInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts or updates per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	UpdatePerInstanceConfigs(ctx context.Context, in *UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionInstanceGroupManagersClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionInstanceGroupManagersClient(cc grpc.ClientConnInterface) RegionInstanceGroupManagersClient {
	return &regionInstanceGroupManagersClient{cc}
}

func (c *regionInstanceGroupManagersClient) AbandonInstances(ctx context.Context, in *AbandonInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_AbandonInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) ApplyUpdatesToInstances(ctx context.Context, in *ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_ApplyUpdatesToInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) CreateInstances(ctx context.Context, in *CreateInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_CreateInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) Delete(ctx context.Context, in *DeleteRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) DeleteInstances(ctx context.Context, in *DeleteInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_DeleteInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) DeletePerInstanceConfigs(ctx context.Context, in *DeletePerInstanceConfigsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_DeletePerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) Get(ctx context.Context, in *GetRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*InstanceGroupManager, error) {
	out := new(InstanceGroupManager)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) Insert(ctx context.Context, in *InsertRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) List(ctx context.Context, in *ListRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagerList, error) {
	out := new(RegionInstanceGroupManagerList)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) ListErrors(ctx context.Context, in *ListErrorsRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagersListErrorsResponse, error) {
	out := new(RegionInstanceGroupManagersListErrorsResponse)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_ListErrors_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) ListManagedInstances(ctx context.Context, in *ListManagedInstancesRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagersListInstancesResponse, error) {
	out := new(RegionInstanceGroupManagersListInstancesResponse)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_ListManagedInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) ListPerInstanceConfigs(ctx context.Context, in *ListPerInstanceConfigsRegionInstanceGroupManagersRequest, opts ...grpc.CallOption) (*RegionInstanceGroupManagersListInstanceConfigsResp, error) {
	out := new(RegionInstanceGroupManagersListInstanceConfigsResp)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_ListPerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) Patch(ctx context.Context, in *PatchRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) PatchPerInstanceConfigs(ctx context.Context, in *PatchPerInstanceConfigsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_PatchPerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) RecreateInstances(ctx context.Context, in *RecreateInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_RecreateInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) Resize(ctx context.Context, in *ResizeRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_Resize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) ResumeInstances(ctx context.Context, in *ResumeInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_ResumeInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) SetInstanceTemplate(ctx context.Context, in *SetInstanceTemplateRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_SetInstanceTemplate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) SetTargetPools(ctx context.Context, in *SetTargetPoolsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_SetTargetPools_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) StartInstances(ctx context.Context, in *StartInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_StartInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) StopInstances(ctx context.Context, in *StopInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_StopInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) SuspendInstances(ctx context.Context, in *SuspendInstancesRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_SuspendInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupManagersClient) UpdatePerInstanceConfigs(ctx context.Context, in *UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroupManagers_UpdatePerInstanceConfigs_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionInstanceGroupManagersServer is the server API for RegionInstanceGroupManagers service.
// All implementations should embed UnimplementedRegionInstanceGroupManagersServer
// for forward compatibility
type RegionInstanceGroupManagersServer interface {
	// Flags the specified instances to be immediately removed from the managed
	// instance group. Abandoning an instance does not delete the
	// instance, but it does remove the instance from any target pools that are
	// applied by the managed instance group. This method reduces thetargetSize of the managed instance group by the
	// number of instances that you abandon. This operation is marked asDONE when the action is scheduled even if the instances have
	// not yet been removed from the group. You must separately verify the
	// status of the abandoning action with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	AbandonInstances(context.Context, *AbandonInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Apply updates to selected instances the managed instance group.
	ApplyUpdatesToInstances(context.Context, *ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Creates instances with per-instance configurations in this regional managed
	// instance group. Instances are created using the current instance template.
	// The create instances operation is marked DONE if
	// the createInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of thecreating or actions with the listmanagedinstances
	// method.
	CreateInstances(context.Context, *CreateInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Deletes the specified managed instance group and all of the instances
	// in that group.
	Delete(context.Context, *DeleteRegionInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately deleted. The instances are also removed from any target
	// pools of which they were a member. This method reduces thetargetSize of the managed instance group by the number of
	// instances that you delete.
	// The deleteInstances operation is marked DONE if
	// the deleteInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of thedeleting action with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	DeleteInstances(context.Context, *DeleteInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Deletes selected per-instance configurations for the managed instance
	// group.
	DeletePerInstanceConfigs(context.Context, *DeletePerInstanceConfigsRegionInstanceGroupManagerRequest) (*Operation, error)
	// Returns all of the details about the specified managed instance group.
	Get(context.Context, *GetRegionInstanceGroupManagerRequest) (*InstanceGroupManager, error)
	// Creates a managed instance group using the information that you specify
	// in the request. After the group is created, instances in the group are
	// created using the specified instance template.
	// This operation is marked as DONE when the group is created
	// even if the instances in the group have not yet been created. You must
	// separately verify the status of the individual instances with thelistmanagedinstances
	// method.
	//
	// A regional managed instance group can contain up to 2000 instances.
	Insert(context.Context, *InsertRegionInstanceGroupManagerRequest) (*Operation, error)
	// Retrieves the list of managed instance groups that are contained
	// within the specified region.
	List(context.Context, *ListRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagerList, error)
	// Lists all errors thrown by actions on instances for a given regional
	// managed instance group. The filter andorderBy query parameters are not supported.
	ListErrors(context.Context, *ListErrorsRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagersListErrorsResponse, error)
	// Lists the instances in the managed instance group and instances that are
	// scheduled to be created. The list includes any current actions
	// that the group has scheduled for its instances. The orderBy
	// query parameter is not supported.   The `pageToken` query parameter is
	// supported only if the group's `listManagedInstancesResults` field is set
	// to `PAGINATED`.
	ListManagedInstances(context.Context, *ListManagedInstancesRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagersListInstancesResponse, error)
	// Lists all of the per-instance configurations defined for the managed
	// instance group. The orderBy query parameter is not supported.
	ListPerInstanceConfigs(context.Context, *ListPerInstanceConfigsRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagersListInstanceConfigsResp, error)
	// Updates a managed instance group using the information that you specify
	// in the request.
	// This operation is marked as DONE when the group is patched
	// even if the instances in the group are still in the process of being
	// patched. You must separately verify the status of the individual instances
	// with the listmanagedinstances
	// method. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	//
	// If you update your group to specify a new template or instance
	// configuration, it's possible that your intended specification for each VM
	// in the group is different from the current state of that VM. To learn how
	// to apply an updated configuration to the VMs in a MIG, seeUpdating instances in
	// a MIG.
	Patch(context.Context, *PatchRegionInstanceGroupManagerRequest) (*Operation, error)
	// Inserts or patches per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	PatchPerInstanceConfigs(context.Context, *PatchPerInstanceConfigsRegionInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified VM instances in the managed instance group to be
	// immediately recreated. Each instance is recreated using the group's current
	// configuration. This operation is marked as DONE when the flag
	// is set even if the instances have not yet been recreated. You must
	// separately verify the status of each instance by checking itscurrentAction field; for more information, see Checking
	// the status of managed instances.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	RecreateInstances(context.Context, *RecreateInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Changes the intended size of the managed instance group. If you increase
	// the size, the group creates new instances using the current instance
	// template. If you decrease the size, the group deletes one or more
	// instances.
	//
	// The resize operation is marked DONE if theresize request is successful. The underlying actions take
	// additional time. You must separately verify the status of thecreating or deleting actions with thelistmanagedinstances
	// method.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is removed or deleted.
	Resize(context.Context, *ResizeRegionInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// resumed. This method increases thetargetSize and decreases the targetSuspendedSize
	// of the managed instance group by the number of instances that you resume.
	// The resumeInstances operation is marked DONE if
	// the resumeInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theRESUMING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are suspended. For
	// example, if an instance was previously suspended using the suspendInstances
	// method, it can be resumed using the resumeInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are resumed.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	ResumeInstances(context.Context, *ResumeInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Sets the instance template to use when creating new instances or recreating
	// instances in this group. Existing instances are not affected.
	SetInstanceTemplate(context.Context, *SetInstanceTemplateRegionInstanceGroupManagerRequest) (*Operation, error)
	// Modifies the target pools to which all new instances in this group are
	// assigned. Existing instances in the group are not affected.
	SetTargetPools(context.Context, *SetTargetPoolsRegionInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// started. This method increases thetargetSize and decreases the targetStoppedSize
	// of the managed instance group by the number of instances that you start.
	// The startInstances operation is marked DONE if
	// the startInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTARTING action with thelistmanagedinstances
	// method.
	//
	// In this request, you can only specify instances that are stopped. For
	// example, if an instance was previously stopped using the stopInstances
	// method, it can be started using the startInstances method.
	//
	// If a health check is attached to the managed instance group, the specified
	// instances will be verified as healthy after they are started.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StartInstances(context.Context, *StartInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately stopped. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetStoppedSize
	// of the managed instance group by the number of instances that you stop.
	// The stopInstances operation is marked DONE if
	// the stopInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSTOPPING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays stopping the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is stopped.
	//
	// Stopped instances can be started using the startInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	StopInstances(context.Context, *StopInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Flags the specified instances in the managed instance group to be
	// immediately suspended. You can only specify instances that are running in
	// this request. This method reduces thetargetSize and increases the targetSuspendedSize
	// of the managed instance group by the number of instances that you suspend.
	// The suspendInstances operation is marked DONE if
	// the suspendInstances request is successful. The underlying
	// actions take additional time. You must separately verify the status of theSUSPENDING action with thelistmanagedinstances
	// method.
	//
	// If the standbyPolicy.initialDelaySec field is set, the group
	// delays suspension of the instances until initialDelaySec have
	// passed from instance.creationTimestamp (that is, when the
	// instance was created). This delay gives your application time to
	// set itself up and initialize on the instance. If more thaninitialDelaySec seconds have passed sinceinstance.creationTimestamp when this method is called, there
	// will be zero delay.
	//
	// If the group is part of a backend
	// service that has enabled
	// connection draining, it can take up to 60 seconds after the connection
	// draining duration has elapsed before the VM instance is suspended.
	//
	// Suspended instances can be resumed using the resumeInstances
	// method.
	//
	// You can specify a maximum of 1000 instances with this method per request.
	SuspendInstances(context.Context, *SuspendInstancesRegionInstanceGroupManagerRequest) (*Operation, error)
	// Inserts or updates per-instance configurations for the managed instance
	// group. perInstanceConfig.name serves as a key used to
	// distinguish whether to perform insert or patch.
	UpdatePerInstanceConfigs(context.Context, *UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest) (*Operation, error)
}

// UnimplementedRegionInstanceGroupManagersServer should be embedded to have forward compatible implementations.
type UnimplementedRegionInstanceGroupManagersServer struct {
}

func (UnimplementedRegionInstanceGroupManagersServer) AbandonInstances(context.Context, *AbandonInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AbandonInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) ApplyUpdatesToInstances(context.Context, *ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyUpdatesToInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) CreateInstances(context.Context, *CreateInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) Delete(context.Context, *DeleteRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) DeleteInstances(context.Context, *DeleteInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) DeletePerInstanceConfigs(context.Context, *DeletePerInstanceConfigsRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeletePerInstanceConfigs not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) Get(context.Context, *GetRegionInstanceGroupManagerRequest) (*InstanceGroupManager, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) Insert(context.Context, *InsertRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) List(context.Context, *ListRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagerList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) ListErrors(context.Context, *ListErrorsRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagersListErrorsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListErrors not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) ListManagedInstances(context.Context, *ListManagedInstancesRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagersListInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListManagedInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) ListPerInstanceConfigs(context.Context, *ListPerInstanceConfigsRegionInstanceGroupManagersRequest) (*RegionInstanceGroupManagersListInstanceConfigsResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPerInstanceConfigs not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) Patch(context.Context, *PatchRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) PatchPerInstanceConfigs(context.Context, *PatchPerInstanceConfigsRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchPerInstanceConfigs not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) RecreateInstances(context.Context, *RecreateInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RecreateInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) Resize(context.Context, *ResizeRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resize not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) ResumeInstances(context.Context, *ResumeInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResumeInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) SetInstanceTemplate(context.Context, *SetInstanceTemplateRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetInstanceTemplate not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) SetTargetPools(context.Context, *SetTargetPoolsRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTargetPools not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) StartInstances(context.Context, *StartInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StartInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) StopInstances(context.Context, *StopInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method StopInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) SuspendInstances(context.Context, *SuspendInstancesRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SuspendInstances not implemented")
}
func (UnimplementedRegionInstanceGroupManagersServer) UpdatePerInstanceConfigs(context.Context, *UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePerInstanceConfigs not implemented")
}

// UnsafeRegionInstanceGroupManagersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionInstanceGroupManagersServer will
// result in compilation errors.
type UnsafeRegionInstanceGroupManagersServer interface {
	mustEmbedUnimplementedRegionInstanceGroupManagersServer()
}

func RegisterRegionInstanceGroupManagersServer(s grpc.ServiceRegistrar, srv RegionInstanceGroupManagersServer) {
	s.RegisterService(&RegionInstanceGroupManagers_ServiceDesc, srv)
}

func _RegionInstanceGroupManagers_AbandonInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AbandonInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).AbandonInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_AbandonInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).AbandonInstances(ctx, req.(*AbandonInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_ApplyUpdatesToInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).ApplyUpdatesToInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_ApplyUpdatesToInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).ApplyUpdatesToInstances(ctx, req.(*ApplyUpdatesToInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_CreateInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).CreateInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_CreateInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).CreateInstances(ctx, req.(*CreateInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).Delete(ctx, req.(*DeleteRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_DeleteInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).DeleteInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_DeleteInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).DeleteInstances(ctx, req.(*DeleteInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_DeletePerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeletePerInstanceConfigsRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).DeletePerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_DeletePerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).DeletePerInstanceConfigs(ctx, req.(*DeletePerInstanceConfigsRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).Get(ctx, req.(*GetRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).Insert(ctx, req.(*InsertRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).List(ctx, req.(*ListRegionInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_ListErrors_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListErrorsRegionInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).ListErrors(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_ListErrors_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).ListErrors(ctx, req.(*ListErrorsRegionInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_ListManagedInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListManagedInstancesRegionInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).ListManagedInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_ListManagedInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).ListManagedInstances(ctx, req.(*ListManagedInstancesRegionInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_ListPerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPerInstanceConfigsRegionInstanceGroupManagersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).ListPerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_ListPerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).ListPerInstanceConfigs(ctx, req.(*ListPerInstanceConfigsRegionInstanceGroupManagersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).Patch(ctx, req.(*PatchRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_PatchPerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchPerInstanceConfigsRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).PatchPerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_PatchPerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).PatchPerInstanceConfigs(ctx, req.(*PatchPerInstanceConfigsRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_RecreateInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecreateInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).RecreateInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_RecreateInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).RecreateInstances(ctx, req.(*RecreateInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_Resize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).Resize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_Resize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).Resize(ctx, req.(*ResizeRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_ResumeInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResumeInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).ResumeInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_ResumeInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).ResumeInstances(ctx, req.(*ResumeInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_SetInstanceTemplate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetInstanceTemplateRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).SetInstanceTemplate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_SetInstanceTemplate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).SetInstanceTemplate(ctx, req.(*SetInstanceTemplateRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_SetTargetPools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTargetPoolsRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).SetTargetPools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_SetTargetPools_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).SetTargetPools(ctx, req.(*SetTargetPoolsRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_StartInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).StartInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_StartInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).StartInstances(ctx, req.(*StartInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_StopInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).StopInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_StopInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).StopInstances(ctx, req.(*StopInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_SuspendInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SuspendInstancesRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).SuspendInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_SuspendInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).SuspendInstances(ctx, req.(*SuspendInstancesRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroupManagers_UpdatePerInstanceConfigs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupManagersServer).UpdatePerInstanceConfigs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroupManagers_UpdatePerInstanceConfigs_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupManagersServer).UpdatePerInstanceConfigs(ctx, req.(*UpdatePerInstanceConfigsRegionInstanceGroupManagerRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionInstanceGroupManagers_ServiceDesc is the grpc.ServiceDesc for RegionInstanceGroupManagers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionInstanceGroupManagers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionInstanceGroupManagers",
	HandlerType: (*RegionInstanceGroupManagersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AbandonInstances",
			Handler:    _RegionInstanceGroupManagers_AbandonInstances_Handler,
		},
		{
			MethodName: "ApplyUpdatesToInstances",
			Handler:    _RegionInstanceGroupManagers_ApplyUpdatesToInstances_Handler,
		},
		{
			MethodName: "CreateInstances",
			Handler:    _RegionInstanceGroupManagers_CreateInstances_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegionInstanceGroupManagers_Delete_Handler,
		},
		{
			MethodName: "DeleteInstances",
			Handler:    _RegionInstanceGroupManagers_DeleteInstances_Handler,
		},
		{
			MethodName: "DeletePerInstanceConfigs",
			Handler:    _RegionInstanceGroupManagers_DeletePerInstanceConfigs_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionInstanceGroupManagers_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionInstanceGroupManagers_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionInstanceGroupManagers_List_Handler,
		},
		{
			MethodName: "ListErrors",
			Handler:    _RegionInstanceGroupManagers_ListErrors_Handler,
		},
		{
			MethodName: "ListManagedInstances",
			Handler:    _RegionInstanceGroupManagers_ListManagedInstances_Handler,
		},
		{
			MethodName: "ListPerInstanceConfigs",
			Handler:    _RegionInstanceGroupManagers_ListPerInstanceConfigs_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionInstanceGroupManagers_Patch_Handler,
		},
		{
			MethodName: "PatchPerInstanceConfigs",
			Handler:    _RegionInstanceGroupManagers_PatchPerInstanceConfigs_Handler,
		},
		{
			MethodName: "RecreateInstances",
			Handler:    _RegionInstanceGroupManagers_RecreateInstances_Handler,
		},
		{
			MethodName: "Resize",
			Handler:    _RegionInstanceGroupManagers_Resize_Handler,
		},
		{
			MethodName: "ResumeInstances",
			Handler:    _RegionInstanceGroupManagers_ResumeInstances_Handler,
		},
		{
			MethodName: "SetInstanceTemplate",
			Handler:    _RegionInstanceGroupManagers_SetInstanceTemplate_Handler,
		},
		{
			MethodName: "SetTargetPools",
			Handler:    _RegionInstanceGroupManagers_SetTargetPools_Handler,
		},
		{
			MethodName: "StartInstances",
			Handler:    _RegionInstanceGroupManagers_StartInstances_Handler,
		},
		{
			MethodName: "StopInstances",
			Handler:    _RegionInstanceGroupManagers_StopInstances_Handler,
		},
		{
			MethodName: "SuspendInstances",
			Handler:    _RegionInstanceGroupManagers_SuspendInstances_Handler,
		},
		{
			MethodName: "UpdatePerInstanceConfigs",
			Handler:    _RegionInstanceGroupManagers_UpdatePerInstanceConfigs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionInstanceGroups_Get_FullMethodName                = "/google.cloud.compute.v1.RegionInstanceGroups/Get"
	RegionInstanceGroups_List_FullMethodName               = "/google.cloud.compute.v1.RegionInstanceGroups/List"
	RegionInstanceGroups_ListInstances_FullMethodName      = "/google.cloud.compute.v1.RegionInstanceGroups/ListInstances"
	RegionInstanceGroups_SetNamedPorts_FullMethodName      = "/google.cloud.compute.v1.RegionInstanceGroups/SetNamedPorts"
	RegionInstanceGroups_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.RegionInstanceGroups/TestIamPermissions"
)

// RegionInstanceGroupsClient is the client API for RegionInstanceGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionInstanceGroupsClient interface {
	// Returns the specified instance group resource.
	Get(ctx context.Context, in *GetRegionInstanceGroupRequest, opts ...grpc.CallOption) (*InstanceGroup, error)
	// Retrieves the list of instance group resources contained within
	// the specified region.
	List(ctx context.Context, in *ListRegionInstanceGroupsRequest, opts ...grpc.CallOption) (*RegionInstanceGroupList, error)
	// Lists the instances in the specified instance group and displays
	// information about the named ports. Depending on the specified options, this
	// method can list all instances or only the instances that are running.
	// The orderBy query parameter is not supported.
	ListInstances(ctx context.Context, in *ListInstancesRegionInstanceGroupsRequest, opts ...grpc.CallOption) (*RegionInstanceGroupsListInstances, error)
	// Sets the named ports for the specified regional instance group.
	SetNamedPorts(ctx context.Context, in *SetNamedPortsRegionInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionInstanceGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type regionInstanceGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionInstanceGroupsClient(cc grpc.ClientConnInterface) RegionInstanceGroupsClient {
	return &regionInstanceGroupsClient{cc}
}

func (c *regionInstanceGroupsClient) Get(ctx context.Context, in *GetRegionInstanceGroupRequest, opts ...grpc.CallOption) (*InstanceGroup, error) {
	out := new(InstanceGroup)
	err := c.cc.Invoke(ctx, RegionInstanceGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupsClient) List(ctx context.Context, in *ListRegionInstanceGroupsRequest, opts ...grpc.CallOption) (*RegionInstanceGroupList, error) {
	out := new(RegionInstanceGroupList)
	err := c.cc.Invoke(ctx, RegionInstanceGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupsClient) ListInstances(ctx context.Context, in *ListInstancesRegionInstanceGroupsRequest, opts ...grpc.CallOption) (*RegionInstanceGroupsListInstances, error) {
	out := new(RegionInstanceGroupsListInstances)
	err := c.cc.Invoke(ctx, RegionInstanceGroups_ListInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupsClient) SetNamedPorts(ctx context.Context, in *SetNamedPortsRegionInstanceGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceGroups_SetNamedPorts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceGroupsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionInstanceGroupRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionInstanceGroups_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionInstanceGroupsServer is the server API for RegionInstanceGroups service.
// All implementations should embed UnimplementedRegionInstanceGroupsServer
// for forward compatibility
type RegionInstanceGroupsServer interface {
	// Returns the specified instance group resource.
	Get(context.Context, *GetRegionInstanceGroupRequest) (*InstanceGroup, error)
	// Retrieves the list of instance group resources contained within
	// the specified region.
	List(context.Context, *ListRegionInstanceGroupsRequest) (*RegionInstanceGroupList, error)
	// Lists the instances in the specified instance group and displays
	// information about the named ports. Depending on the specified options, this
	// method can list all instances or only the instances that are running.
	// The orderBy query parameter is not supported.
	ListInstances(context.Context, *ListInstancesRegionInstanceGroupsRequest) (*RegionInstanceGroupsListInstances, error)
	// Sets the named ports for the specified regional instance group.
	SetNamedPorts(context.Context, *SetNamedPortsRegionInstanceGroupRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionInstanceGroupRequest) (*TestPermissionsResponse, error)
}

// UnimplementedRegionInstanceGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionInstanceGroupsServer struct {
}

func (UnimplementedRegionInstanceGroupsServer) Get(context.Context, *GetRegionInstanceGroupRequest) (*InstanceGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionInstanceGroupsServer) List(context.Context, *ListRegionInstanceGroupsRequest) (*RegionInstanceGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionInstanceGroupsServer) ListInstances(context.Context, *ListInstancesRegionInstanceGroupsRequest) (*RegionInstanceGroupsListInstances, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (UnimplementedRegionInstanceGroupsServer) SetNamedPorts(context.Context, *SetNamedPortsRegionInstanceGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetNamedPorts not implemented")
}
func (UnimplementedRegionInstanceGroupsServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionInstanceGroupRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeRegionInstanceGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionInstanceGroupsServer will
// result in compilation errors.
type UnsafeRegionInstanceGroupsServer interface {
	mustEmbedUnimplementedRegionInstanceGroupsServer()
}

func RegisterRegionInstanceGroupsServer(s grpc.ServiceRegistrar, srv RegionInstanceGroupsServer) {
	s.RegisterService(&RegionInstanceGroups_ServiceDesc, srv)
}

func _RegionInstanceGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupsServer).Get(ctx, req.(*GetRegionInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionInstanceGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupsServer).List(ctx, req.(*ListRegionInstanceGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroups_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRegionInstanceGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupsServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroups_ListInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupsServer).ListInstances(ctx, req.(*ListInstancesRegionInstanceGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroups_SetNamedPorts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetNamedPortsRegionInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupsServer).SetNamedPorts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroups_SetNamedPorts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupsServer).SetNamedPorts(ctx, req.(*SetNamedPortsRegionInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceGroups_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionInstanceGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceGroupsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceGroups_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceGroupsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionInstanceGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionInstanceGroups_ServiceDesc is the grpc.ServiceDesc for RegionInstanceGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionInstanceGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionInstanceGroups",
	HandlerType: (*RegionInstanceGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _RegionInstanceGroups_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionInstanceGroups_List_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _RegionInstanceGroups_ListInstances_Handler,
		},
		{
			MethodName: "SetNamedPorts",
			Handler:    _RegionInstanceGroups_SetNamedPorts_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionInstanceGroups_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionInstanceTemplates_Delete_FullMethodName = "/google.cloud.compute.v1.RegionInstanceTemplates/Delete"
	RegionInstanceTemplates_Get_FullMethodName    = "/google.cloud.compute.v1.RegionInstanceTemplates/Get"
	RegionInstanceTemplates_Insert_FullMethodName = "/google.cloud.compute.v1.RegionInstanceTemplates/Insert"
	RegionInstanceTemplates_List_FullMethodName   = "/google.cloud.compute.v1.RegionInstanceTemplates/List"
)

// RegionInstanceTemplatesClient is the client API for RegionInstanceTemplates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionInstanceTemplatesClient interface {
	// Deletes the specified instance template. Deleting an instance template is
	// permanent and cannot be undone.
	Delete(ctx context.Context, in *DeleteRegionInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified instance template.
	Get(ctx context.Context, in *GetRegionInstanceTemplateRequest, opts ...grpc.CallOption) (*InstanceTemplate, error)
	// Creates an instance template in the specified project and region using the
	// global instance template whose URL is included in the request.
	Insert(ctx context.Context, in *InsertRegionInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of instance templates that are contained within the
	// specified project and region.
	List(ctx context.Context, in *ListRegionInstanceTemplatesRequest, opts ...grpc.CallOption) (*InstanceTemplateList, error)
}

type regionInstanceTemplatesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionInstanceTemplatesClient(cc grpc.ClientConnInterface) RegionInstanceTemplatesClient {
	return &regionInstanceTemplatesClient{cc}
}

func (c *regionInstanceTemplatesClient) Delete(ctx context.Context, in *DeleteRegionInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceTemplates_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceTemplatesClient) Get(ctx context.Context, in *GetRegionInstanceTemplateRequest, opts ...grpc.CallOption) (*InstanceTemplate, error) {
	out := new(InstanceTemplate)
	err := c.cc.Invoke(ctx, RegionInstanceTemplates_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceTemplatesClient) Insert(ctx context.Context, in *InsertRegionInstanceTemplateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstanceTemplates_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstanceTemplatesClient) List(ctx context.Context, in *ListRegionInstanceTemplatesRequest, opts ...grpc.CallOption) (*InstanceTemplateList, error) {
	out := new(InstanceTemplateList)
	err := c.cc.Invoke(ctx, RegionInstanceTemplates_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionInstanceTemplatesServer is the server API for RegionInstanceTemplates service.
// All implementations should embed UnimplementedRegionInstanceTemplatesServer
// for forward compatibility
type RegionInstanceTemplatesServer interface {
	// Deletes the specified instance template. Deleting an instance template is
	// permanent and cannot be undone.
	Delete(context.Context, *DeleteRegionInstanceTemplateRequest) (*Operation, error)
	// Returns the specified instance template.
	Get(context.Context, *GetRegionInstanceTemplateRequest) (*InstanceTemplate, error)
	// Creates an instance template in the specified project and region using the
	// global instance template whose URL is included in the request.
	Insert(context.Context, *InsertRegionInstanceTemplateRequest) (*Operation, error)
	// Retrieves a list of instance templates that are contained within the
	// specified project and region.
	List(context.Context, *ListRegionInstanceTemplatesRequest) (*InstanceTemplateList, error)
}

// UnimplementedRegionInstanceTemplatesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionInstanceTemplatesServer struct {
}

func (UnimplementedRegionInstanceTemplatesServer) Delete(context.Context, *DeleteRegionInstanceTemplateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionInstanceTemplatesServer) Get(context.Context, *GetRegionInstanceTemplateRequest) (*InstanceTemplate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionInstanceTemplatesServer) Insert(context.Context, *InsertRegionInstanceTemplateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionInstanceTemplatesServer) List(context.Context, *ListRegionInstanceTemplatesRequest) (*InstanceTemplateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeRegionInstanceTemplatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionInstanceTemplatesServer will
// result in compilation errors.
type UnsafeRegionInstanceTemplatesServer interface {
	mustEmbedUnimplementedRegionInstanceTemplatesServer()
}

func RegisterRegionInstanceTemplatesServer(s grpc.ServiceRegistrar, srv RegionInstanceTemplatesServer) {
	s.RegisterService(&RegionInstanceTemplates_ServiceDesc, srv)
}

func _RegionInstanceTemplates_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceTemplatesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceTemplates_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceTemplatesServer).Delete(ctx, req.(*DeleteRegionInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceTemplates_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceTemplatesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceTemplates_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceTemplatesServer).Get(ctx, req.(*GetRegionInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceTemplates_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionInstanceTemplateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceTemplatesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceTemplates_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceTemplatesServer).Insert(ctx, req.(*InsertRegionInstanceTemplateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstanceTemplates_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionInstanceTemplatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstanceTemplatesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstanceTemplates_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstanceTemplatesServer).List(ctx, req.(*ListRegionInstanceTemplatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionInstanceTemplates_ServiceDesc is the grpc.ServiceDesc for RegionInstanceTemplates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionInstanceTemplates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionInstanceTemplates",
	HandlerType: (*RegionInstanceTemplatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionInstanceTemplates_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionInstanceTemplates_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionInstanceTemplates_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionInstanceTemplates_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionInstances_BulkInsert_FullMethodName = "/google.cloud.compute.v1.RegionInstances/BulkInsert"
)

// RegionInstancesClient is the client API for RegionInstances service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionInstancesClient interface {
	// Creates multiple instances in a given region. Count specifies the number of
	// instances to create.
	BulkInsert(ctx context.Context, in *BulkInsertRegionInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionInstancesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionInstancesClient(cc grpc.ClientConnInterface) RegionInstancesClient {
	return &regionInstancesClient{cc}
}

func (c *regionInstancesClient) BulkInsert(ctx context.Context, in *BulkInsertRegionInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstances_BulkInsert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionInstancesServer is the server API for RegionInstances service.
// All implementations should embed UnimplementedRegionInstancesServer
// for forward compatibility
type RegionInstancesServer interface {
	// Creates multiple instances in a given region. Count specifies the number of
	// instances to create.
	BulkInsert(context.Context, *BulkInsertRegionInstanceRequest) (*Operation, error)
}

// UnimplementedRegionInstancesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionInstancesServer struct {
}

func (UnimplementedRegionInstancesServer) BulkInsert(context.Context, *BulkInsertRegionInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BulkInsert not implemented")
}

// UnsafeRegionInstancesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionInstancesServer will
// result in compilation errors.
type UnsafeRegionInstancesServer interface {
	mustEmbedUnimplementedRegionInstancesServer()
}

func RegisterRegionInstancesServer(s grpc.ServiceRegistrar, srv RegionInstancesServer) {
	s.RegisterService(&RegionInstances_ServiceDesc, srv)
}

func _RegionInstances_BulkInsert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BulkInsertRegionInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstancesServer).BulkInsert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstances_BulkInsert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstancesServer).BulkInsert(ctx, req.(*BulkInsertRegionInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionInstances_ServiceDesc is the grpc.ServiceDesc for RegionInstances service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionInstances_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionInstances",
	HandlerType: (*RegionInstancesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "BulkInsert",
			Handler:    _RegionInstances_BulkInsert_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionInstantSnapshots_Delete_FullMethodName             = "/google.cloud.compute.v1.RegionInstantSnapshots/Delete"
	RegionInstantSnapshots_Get_FullMethodName                = "/google.cloud.compute.v1.RegionInstantSnapshots/Get"
	RegionInstantSnapshots_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.RegionInstantSnapshots/GetIamPolicy"
	RegionInstantSnapshots_Insert_FullMethodName             = "/google.cloud.compute.v1.RegionInstantSnapshots/Insert"
	RegionInstantSnapshots_List_FullMethodName               = "/google.cloud.compute.v1.RegionInstantSnapshots/List"
	RegionInstantSnapshots_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.RegionInstantSnapshots/SetIamPolicy"
	RegionInstantSnapshots_SetLabels_FullMethodName          = "/google.cloud.compute.v1.RegionInstantSnapshots/SetLabels"
	RegionInstantSnapshots_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.RegionInstantSnapshots/TestIamPermissions"
)

// RegionInstantSnapshotsClient is the client API for RegionInstantSnapshots service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionInstantSnapshotsClient interface {
	// Deletes the specified InstantSnapshot resource. Keep in mind that deleting
	// a single instantSnapshot might not necessarily delete all the data on that
	// instantSnapshot. If any data on the instantSnapshot that is marked for
	// deletion is needed for subsequent instantSnapshots, the data will be moved
	// to the next corresponding instantSnapshot.
	//
	// For more information, seeDeleting
	// instantSnapshots.
	Delete(ctx context.Context, in *DeleteRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified InstantSnapshot resource in the specified region.
	Get(ctx context.Context, in *GetRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*InstantSnapshot, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates an instant snapshot in the specified region.
	Insert(ctx context.Context, in *InsertRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of InstantSnapshot resources contained within
	// the specified region.
	List(ctx context.Context, in *ListRegionInstantSnapshotsRequest, opts ...grpc.CallOption) (*InstantSnapshotList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on a instantSnapshot in the given region. To learn more
	// about labels, read the Labeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type regionInstantSnapshotsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionInstantSnapshotsClient(cc grpc.ClientConnInterface) RegionInstantSnapshotsClient {
	return &regionInstantSnapshotsClient{cc}
}

func (c *regionInstantSnapshotsClient) Delete(ctx context.Context, in *DeleteRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) Get(ctx context.Context, in *GetRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*InstantSnapshot, error) {
	out := new(InstantSnapshot)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) Insert(ctx context.Context, in *InsertRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) List(ctx context.Context, in *ListRegionInstantSnapshotsRequest, opts ...grpc.CallOption) (*InstantSnapshotList, error) {
	out := new(InstantSnapshotList)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) SetLabels(ctx context.Context, in *SetLabelsRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionInstantSnapshotsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionInstantSnapshotRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionInstantSnapshots_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionInstantSnapshotsServer is the server API for RegionInstantSnapshots service.
// All implementations should embed UnimplementedRegionInstantSnapshotsServer
// for forward compatibility
type RegionInstantSnapshotsServer interface {
	// Deletes the specified InstantSnapshot resource. Keep in mind that deleting
	// a single instantSnapshot might not necessarily delete all the data on that
	// instantSnapshot. If any data on the instantSnapshot that is marked for
	// deletion is needed for subsequent instantSnapshots, the data will be moved
	// to the next corresponding instantSnapshot.
	//
	// For more information, seeDeleting
	// instantSnapshots.
	Delete(context.Context, *DeleteRegionInstantSnapshotRequest) (*Operation, error)
	// Returns the specified InstantSnapshot resource in the specified region.
	Get(context.Context, *GetRegionInstantSnapshotRequest) (*InstantSnapshot, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyRegionInstantSnapshotRequest) (*Policy, error)
	// Creates an instant snapshot in the specified region.
	Insert(context.Context, *InsertRegionInstantSnapshotRequest) (*Operation, error)
	// Retrieves the list of InstantSnapshot resources contained within
	// the specified region.
	List(context.Context, *ListRegionInstantSnapshotsRequest) (*InstantSnapshotList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyRegionInstantSnapshotRequest) (*Policy, error)
	// Sets the labels on a instantSnapshot in the given region. To learn more
	// about labels, read the Labeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsRegionInstantSnapshotRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionInstantSnapshotRequest) (*TestPermissionsResponse, error)
}

// UnimplementedRegionInstantSnapshotsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionInstantSnapshotsServer struct {
}

func (UnimplementedRegionInstantSnapshotsServer) Delete(context.Context, *DeleteRegionInstantSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) Get(context.Context, *GetRegionInstantSnapshotRequest) (*InstantSnapshot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) GetIamPolicy(context.Context, *GetIamPolicyRegionInstantSnapshotRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) Insert(context.Context, *InsertRegionInstantSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) List(context.Context, *ListRegionInstantSnapshotsRequest) (*InstantSnapshotList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) SetIamPolicy(context.Context, *SetIamPolicyRegionInstantSnapshotRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) SetLabels(context.Context, *SetLabelsRegionInstantSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedRegionInstantSnapshotsServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionInstantSnapshotRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeRegionInstantSnapshotsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionInstantSnapshotsServer will
// result in compilation errors.
type UnsafeRegionInstantSnapshotsServer interface {
	mustEmbedUnimplementedRegionInstantSnapshotsServer()
}

func RegisterRegionInstantSnapshotsServer(s grpc.ServiceRegistrar, srv RegionInstantSnapshotsServer) {
	s.RegisterService(&RegionInstantSnapshots_ServiceDesc, srv)
}

func _RegionInstantSnapshots_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).Delete(ctx, req.(*DeleteRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).Get(ctx, req.(*GetRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).GetIamPolicy(ctx, req.(*GetIamPolicyRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).Insert(ctx, req.(*InsertRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionInstantSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).List(ctx, req.(*ListRegionInstantSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).SetIamPolicy(ctx, req.(*SetIamPolicyRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).SetLabels(ctx, req.(*SetLabelsRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionInstantSnapshots_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionInstantSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionInstantSnapshotsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionInstantSnapshots_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionInstantSnapshotsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionInstantSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionInstantSnapshots_ServiceDesc is the grpc.ServiceDesc for RegionInstantSnapshots service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionInstantSnapshots_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionInstantSnapshots",
	HandlerType: (*RegionInstantSnapshotsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionInstantSnapshots_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionInstantSnapshots_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _RegionInstantSnapshots_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionInstantSnapshots_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionInstantSnapshots_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _RegionInstantSnapshots_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _RegionInstantSnapshots_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionInstantSnapshots_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionNetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/AttachNetworkEndpoints"
	RegionNetworkEndpointGroups_Delete_FullMethodName                 = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/Delete"
	RegionNetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/DetachNetworkEndpoints"
	RegionNetworkEndpointGroups_Get_FullMethodName                    = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/Get"
	RegionNetworkEndpointGroups_Insert_FullMethodName                 = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/Insert"
	RegionNetworkEndpointGroups_List_FullMethodName                   = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/List"
	RegionNetworkEndpointGroups_ListNetworkEndpoints_FullMethodName   = "/google.cloud.compute.v1.RegionNetworkEndpointGroups/ListNetworkEndpoints"
)

// RegionNetworkEndpointGroupsClient is the client API for RegionNetworkEndpointGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionNetworkEndpointGroupsClient interface {
	// Attach a list of network endpoints to the specified network endpoint group.
	AttachNetworkEndpoints(ctx context.Context, in *AttachNetworkEndpointsRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified network endpoint group. Note that the NEG cannot be
	// deleted if it is configured as a backend of a backend service.
	Delete(ctx context.Context, in *DeleteRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Detach the network endpoint from the specified network endpoint group.
	DetachNetworkEndpoints(ctx context.Context, in *DetachNetworkEndpointsRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified network endpoint group.
	Get(ctx context.Context, in *GetRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*NetworkEndpointGroup, error)
	// Creates a network endpoint group in the specified project using the
	// parameters that are included in the request.
	Insert(ctx context.Context, in *InsertRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of regional network endpoint groups available to the
	// specified project in the given region.
	List(ctx context.Context, in *ListRegionNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupList, error)
	// Lists the network endpoints in the specified network endpoint group.
	ListNetworkEndpoints(ctx context.Context, in *ListNetworkEndpointsRegionNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupsListNetworkEndpoints, error)
}

type regionNetworkEndpointGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionNetworkEndpointGroupsClient(cc grpc.ClientConnInterface) RegionNetworkEndpointGroupsClient {
	return &regionNetworkEndpointGroupsClient{cc}
}

func (c *regionNetworkEndpointGroupsClient) AttachNetworkEndpoints(ctx context.Context, in *AttachNetworkEndpointsRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkEndpointGroupsClient) Delete(ctx context.Context, in *DeleteRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkEndpointGroupsClient) DetachNetworkEndpoints(ctx context.Context, in *DetachNetworkEndpointsRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkEndpointGroupsClient) Get(ctx context.Context, in *GetRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*NetworkEndpointGroup, error) {
	out := new(NetworkEndpointGroup)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkEndpointGroupsClient) Insert(ctx context.Context, in *InsertRegionNetworkEndpointGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkEndpointGroupsClient) List(ctx context.Context, in *ListRegionNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupList, error) {
	out := new(NetworkEndpointGroupList)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkEndpointGroupsClient) ListNetworkEndpoints(ctx context.Context, in *ListNetworkEndpointsRegionNetworkEndpointGroupsRequest, opts ...grpc.CallOption) (*NetworkEndpointGroupsListNetworkEndpoints, error) {
	out := new(NetworkEndpointGroupsListNetworkEndpoints)
	err := c.cc.Invoke(ctx, RegionNetworkEndpointGroups_ListNetworkEndpoints_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionNetworkEndpointGroupsServer is the server API for RegionNetworkEndpointGroups service.
// All implementations should embed UnimplementedRegionNetworkEndpointGroupsServer
// for forward compatibility
type RegionNetworkEndpointGroupsServer interface {
	// Attach a list of network endpoints to the specified network endpoint group.
	AttachNetworkEndpoints(context.Context, *AttachNetworkEndpointsRegionNetworkEndpointGroupRequest) (*Operation, error)
	// Deletes the specified network endpoint group. Note that the NEG cannot be
	// deleted if it is configured as a backend of a backend service.
	Delete(context.Context, *DeleteRegionNetworkEndpointGroupRequest) (*Operation, error)
	// Detach the network endpoint from the specified network endpoint group.
	DetachNetworkEndpoints(context.Context, *DetachNetworkEndpointsRegionNetworkEndpointGroupRequest) (*Operation, error)
	// Returns the specified network endpoint group.
	Get(context.Context, *GetRegionNetworkEndpointGroupRequest) (*NetworkEndpointGroup, error)
	// Creates a network endpoint group in the specified project using the
	// parameters that are included in the request.
	Insert(context.Context, *InsertRegionNetworkEndpointGroupRequest) (*Operation, error)
	// Retrieves the list of regional network endpoint groups available to the
	// specified project in the given region.
	List(context.Context, *ListRegionNetworkEndpointGroupsRequest) (*NetworkEndpointGroupList, error)
	// Lists the network endpoints in the specified network endpoint group.
	ListNetworkEndpoints(context.Context, *ListNetworkEndpointsRegionNetworkEndpointGroupsRequest) (*NetworkEndpointGroupsListNetworkEndpoints, error)
}

// UnimplementedRegionNetworkEndpointGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionNetworkEndpointGroupsServer struct {
}

func (UnimplementedRegionNetworkEndpointGroupsServer) AttachNetworkEndpoints(context.Context, *AttachNetworkEndpointsRegionNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AttachNetworkEndpoints not implemented")
}
func (UnimplementedRegionNetworkEndpointGroupsServer) Delete(context.Context, *DeleteRegionNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionNetworkEndpointGroupsServer) DetachNetworkEndpoints(context.Context, *DetachNetworkEndpointsRegionNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DetachNetworkEndpoints not implemented")
}
func (UnimplementedRegionNetworkEndpointGroupsServer) Get(context.Context, *GetRegionNetworkEndpointGroupRequest) (*NetworkEndpointGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionNetworkEndpointGroupsServer) Insert(context.Context, *InsertRegionNetworkEndpointGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionNetworkEndpointGroupsServer) List(context.Context, *ListRegionNetworkEndpointGroupsRequest) (*NetworkEndpointGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionNetworkEndpointGroupsServer) ListNetworkEndpoints(context.Context, *ListNetworkEndpointsRegionNetworkEndpointGroupsRequest) (*NetworkEndpointGroupsListNetworkEndpoints, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListNetworkEndpoints not implemented")
}

// UnsafeRegionNetworkEndpointGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionNetworkEndpointGroupsServer will
// result in compilation errors.
type UnsafeRegionNetworkEndpointGroupsServer interface {
	mustEmbedUnimplementedRegionNetworkEndpointGroupsServer()
}

func RegisterRegionNetworkEndpointGroupsServer(s grpc.ServiceRegistrar, srv RegionNetworkEndpointGroupsServer) {
	s.RegisterService(&RegionNetworkEndpointGroups_ServiceDesc, srv)
}

func _RegionNetworkEndpointGroups_AttachNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AttachNetworkEndpointsRegionNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).AttachNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_AttachNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).AttachNetworkEndpoints(ctx, req.(*AttachNetworkEndpointsRegionNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkEndpointGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).Delete(ctx, req.(*DeleteRegionNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkEndpointGroups_DetachNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DetachNetworkEndpointsRegionNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).DetachNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_DetachNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).DetachNetworkEndpoints(ctx, req.(*DetachNetworkEndpointsRegionNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkEndpointGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).Get(ctx, req.(*GetRegionNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkEndpointGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionNetworkEndpointGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).Insert(ctx, req.(*InsertRegionNetworkEndpointGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkEndpointGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).List(ctx, req.(*ListRegionNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkEndpointGroups_ListNetworkEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListNetworkEndpointsRegionNetworkEndpointGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkEndpointGroupsServer).ListNetworkEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkEndpointGroups_ListNetworkEndpoints_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkEndpointGroupsServer).ListNetworkEndpoints(ctx, req.(*ListNetworkEndpointsRegionNetworkEndpointGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionNetworkEndpointGroups_ServiceDesc is the grpc.ServiceDesc for RegionNetworkEndpointGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionNetworkEndpointGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionNetworkEndpointGroups",
	HandlerType: (*RegionNetworkEndpointGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AttachNetworkEndpoints",
			Handler:    _RegionNetworkEndpointGroups_AttachNetworkEndpoints_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegionNetworkEndpointGroups_Delete_Handler,
		},
		{
			MethodName: "DetachNetworkEndpoints",
			Handler:    _RegionNetworkEndpointGroups_DetachNetworkEndpoints_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionNetworkEndpointGroups_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionNetworkEndpointGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionNetworkEndpointGroups_List_Handler,
		},
		{
			MethodName: "ListNetworkEndpoints",
			Handler:    _RegionNetworkEndpointGroups_ListNetworkEndpoints_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionNetworkFirewallPolicies_AddAssociation_FullMethodName        = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/AddAssociation"
	RegionNetworkFirewallPolicies_AddRule_FullMethodName               = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/AddRule"
	RegionNetworkFirewallPolicies_CloneRules_FullMethodName            = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/CloneRules"
	RegionNetworkFirewallPolicies_Delete_FullMethodName                = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Delete"
	RegionNetworkFirewallPolicies_Get_FullMethodName                   = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Get"
	RegionNetworkFirewallPolicies_GetAssociation_FullMethodName        = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetAssociation"
	RegionNetworkFirewallPolicies_GetEffectiveFirewalls_FullMethodName = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetEffectiveFirewalls"
	RegionNetworkFirewallPolicies_GetIamPolicy_FullMethodName          = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetIamPolicy"
	RegionNetworkFirewallPolicies_GetRule_FullMethodName               = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/GetRule"
	RegionNetworkFirewallPolicies_Insert_FullMethodName                = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Insert"
	RegionNetworkFirewallPolicies_List_FullMethodName                  = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/List"
	RegionNetworkFirewallPolicies_Patch_FullMethodName                 = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/Patch"
	RegionNetworkFirewallPolicies_PatchRule_FullMethodName             = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/PatchRule"
	RegionNetworkFirewallPolicies_RemoveAssociation_FullMethodName     = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/RemoveAssociation"
	RegionNetworkFirewallPolicies_RemoveRule_FullMethodName            = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/RemoveRule"
	RegionNetworkFirewallPolicies_SetIamPolicy_FullMethodName          = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/SetIamPolicy"
	RegionNetworkFirewallPolicies_TestIamPermissions_FullMethodName    = "/google.cloud.compute.v1.RegionNetworkFirewallPolicies/TestIamPermissions"
)

// RegionNetworkFirewallPoliciesClient is the client API for RegionNetworkFirewallPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionNetworkFirewallPoliciesClient interface {
	// Inserts an association for the specified network firewall policy.
	AddAssociation(ctx context.Context, in *AddAssociationRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Inserts a rule into a network firewall policy.
	AddRule(ctx context.Context, in *AddRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Copies rules to the specified network firewall policy.
	CloneRules(ctx context.Context, in *CloneRulesRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified network firewall policy.
	Delete(ctx context.Context, in *DeleteRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified network firewall policy.
	Get(ctx context.Context, in *GetRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicy, error)
	// Gets an association with the specified name.
	GetAssociation(ctx context.Context, in *GetAssociationRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyAssociation, error)
	// Returns the effective firewalls on a given network.
	GetEffectiveFirewalls(ctx context.Context, in *GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Gets a rule of the specified priority.
	GetRule(ctx context.Context, in *GetRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error)
	// Creates a new network firewall policy in the specified project and region.
	Insert(ctx context.Context, in *InsertRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all the network firewall policies that have been configured
	// for the specified project in the given region.
	List(ctx context.Context, in *ListRegionNetworkFirewallPoliciesRequest, opts ...grpc.CallOption) (*FirewallPolicyList, error)
	// Patches the specified network firewall policy.
	Patch(ctx context.Context, in *PatchRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a rule of the specified priority.
	PatchRule(ctx context.Context, in *PatchRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes an association for the specified network firewall policy.
	RemoveAssociation(ctx context.Context, in *RemoveAssociationRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a rule of the specified priority.
	RemoveRule(ctx context.Context, in *RemoveRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type regionNetworkFirewallPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionNetworkFirewallPoliciesClient(cc grpc.ClientConnInterface) RegionNetworkFirewallPoliciesClient {
	return &regionNetworkFirewallPoliciesClient{cc}
}

func (c *regionNetworkFirewallPoliciesClient) AddAssociation(ctx context.Context, in *AddAssociationRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_AddAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) AddRule(ctx context.Context, in *AddRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_AddRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) CloneRules(ctx context.Context, in *CloneRulesRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_CloneRules_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) Delete(ctx context.Context, in *DeleteRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) Get(ctx context.Context, in *GetRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicy, error) {
	out := new(FirewallPolicy)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) GetAssociation(ctx context.Context, in *GetAssociationRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyAssociation, error) {
	out := new(FirewallPolicyAssociation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_GetAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) GetEffectiveFirewalls(ctx context.Context, in *GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse, error) {
	out := new(RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_GetEffectiveFirewalls_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) GetRule(ctx context.Context, in *GetRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*FirewallPolicyRule, error) {
	out := new(FirewallPolicyRule)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_GetRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) Insert(ctx context.Context, in *InsertRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) List(ctx context.Context, in *ListRegionNetworkFirewallPoliciesRequest, opts ...grpc.CallOption) (*FirewallPolicyList, error) {
	out := new(FirewallPolicyList)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) Patch(ctx context.Context, in *PatchRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) PatchRule(ctx context.Context, in *PatchRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_PatchRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) RemoveAssociation(ctx context.Context, in *RemoveAssociationRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_RemoveAssociation_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) RemoveRule(ctx context.Context, in *RemoveRuleRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_RemoveRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNetworkFirewallPoliciesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionNetworkFirewallPolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionNetworkFirewallPolicies_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionNetworkFirewallPoliciesServer is the server API for RegionNetworkFirewallPolicies service.
// All implementations should embed UnimplementedRegionNetworkFirewallPoliciesServer
// for forward compatibility
type RegionNetworkFirewallPoliciesServer interface {
	// Inserts an association for the specified network firewall policy.
	AddAssociation(context.Context, *AddAssociationRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Inserts a rule into a network firewall policy.
	AddRule(context.Context, *AddRuleRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Copies rules to the specified network firewall policy.
	CloneRules(context.Context, *CloneRulesRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Deletes the specified network firewall policy.
	Delete(context.Context, *DeleteRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Returns the specified network firewall policy.
	Get(context.Context, *GetRegionNetworkFirewallPolicyRequest) (*FirewallPolicy, error)
	// Gets an association with the specified name.
	GetAssociation(context.Context, *GetAssociationRegionNetworkFirewallPolicyRequest) (*FirewallPolicyAssociation, error)
	// Returns the effective firewalls on a given network.
	GetEffectiveFirewalls(context.Context, *GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest) (*RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyRegionNetworkFirewallPolicyRequest) (*Policy, error)
	// Gets a rule of the specified priority.
	GetRule(context.Context, *GetRuleRegionNetworkFirewallPolicyRequest) (*FirewallPolicyRule, error)
	// Creates a new network firewall policy in the specified project and region.
	Insert(context.Context, *InsertRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Lists all the network firewall policies that have been configured
	// for the specified project in the given region.
	List(context.Context, *ListRegionNetworkFirewallPoliciesRequest) (*FirewallPolicyList, error)
	// Patches the specified network firewall policy.
	Patch(context.Context, *PatchRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Patches a rule of the specified priority.
	PatchRule(context.Context, *PatchRuleRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Removes an association for the specified network firewall policy.
	RemoveAssociation(context.Context, *RemoveAssociationRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Deletes a rule of the specified priority.
	RemoveRule(context.Context, *RemoveRuleRegionNetworkFirewallPolicyRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyRegionNetworkFirewallPolicyRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionNetworkFirewallPolicyRequest) (*TestPermissionsResponse, error)
}

// UnimplementedRegionNetworkFirewallPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionNetworkFirewallPoliciesServer struct {
}

func (UnimplementedRegionNetworkFirewallPoliciesServer) AddAssociation(context.Context, *AddAssociationRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddAssociation not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) AddRule(context.Context, *AddRuleRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) CloneRules(context.Context, *CloneRulesRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CloneRules not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) Delete(context.Context, *DeleteRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) Get(context.Context, *GetRegionNetworkFirewallPolicyRequest) (*FirewallPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) GetAssociation(context.Context, *GetAssociationRegionNetworkFirewallPolicyRequest) (*FirewallPolicyAssociation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAssociation not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) GetEffectiveFirewalls(context.Context, *GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest) (*RegionNetworkFirewallPoliciesGetEffectiveFirewallsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetEffectiveFirewalls not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) GetIamPolicy(context.Context, *GetIamPolicyRegionNetworkFirewallPolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) GetRule(context.Context, *GetRuleRegionNetworkFirewallPolicyRequest) (*FirewallPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) Insert(context.Context, *InsertRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) List(context.Context, *ListRegionNetworkFirewallPoliciesRequest) (*FirewallPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) Patch(context.Context, *PatchRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) PatchRule(context.Context, *PatchRuleRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRule not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) RemoveAssociation(context.Context, *RemoveAssociationRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveAssociation not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) RemoveRule(context.Context, *RemoveRuleRegionNetworkFirewallPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) SetIamPolicy(context.Context, *SetIamPolicyRegionNetworkFirewallPolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedRegionNetworkFirewallPoliciesServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionNetworkFirewallPolicyRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeRegionNetworkFirewallPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionNetworkFirewallPoliciesServer will
// result in compilation errors.
type UnsafeRegionNetworkFirewallPoliciesServer interface {
	mustEmbedUnimplementedRegionNetworkFirewallPoliciesServer()
}

func RegisterRegionNetworkFirewallPoliciesServer(s grpc.ServiceRegistrar, srv RegionNetworkFirewallPoliciesServer) {
	s.RegisterService(&RegionNetworkFirewallPolicies_ServiceDesc, srv)
}

func _RegionNetworkFirewallPolicies_AddAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddAssociationRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).AddAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_AddAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).AddAssociation(ctx, req.(*AddAssociationRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).AddRule(ctx, req.(*AddRuleRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_CloneRules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CloneRulesRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).CloneRules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_CloneRules_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).CloneRules(ctx, req.(*CloneRulesRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).Delete(ctx, req.(*DeleteRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).Get(ctx, req.(*GetRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_GetAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetAssociationRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).GetAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_GetAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).GetAssociation(ctx, req.(*GetAssociationRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_GetEffectiveFirewalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).GetEffectiveFirewalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_GetEffectiveFirewalls_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).GetEffectiveFirewalls(ctx, req.(*GetEffectiveFirewallsRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).GetIamPolicy(ctx, req.(*GetIamPolicyRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).GetRule(ctx, req.(*GetRuleRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).Insert(ctx, req.(*InsertRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionNetworkFirewallPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).List(ctx, req.(*ListRegionNetworkFirewallPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).Patch(ctx, req.(*PatchRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_PatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRuleRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).PatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_PatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).PatchRule(ctx, req.(*PatchRuleRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_RemoveAssociation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveAssociationRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).RemoveAssociation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_RemoveAssociation_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).RemoveAssociation(ctx, req.(*RemoveAssociationRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).RemoveRule(ctx, req.(*RemoveRuleRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).SetIamPolicy(ctx, req.(*SetIamPolicyRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNetworkFirewallPolicies_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionNetworkFirewallPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNetworkFirewallPoliciesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNetworkFirewallPolicies_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNetworkFirewallPoliciesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionNetworkFirewallPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionNetworkFirewallPolicies_ServiceDesc is the grpc.ServiceDesc for RegionNetworkFirewallPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionNetworkFirewallPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionNetworkFirewallPolicies",
	HandlerType: (*RegionNetworkFirewallPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddAssociation",
			Handler:    _RegionNetworkFirewallPolicies_AddAssociation_Handler,
		},
		{
			MethodName: "AddRule",
			Handler:    _RegionNetworkFirewallPolicies_AddRule_Handler,
		},
		{
			MethodName: "CloneRules",
			Handler:    _RegionNetworkFirewallPolicies_CloneRules_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegionNetworkFirewallPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionNetworkFirewallPolicies_Get_Handler,
		},
		{
			MethodName: "GetAssociation",
			Handler:    _RegionNetworkFirewallPolicies_GetAssociation_Handler,
		},
		{
			MethodName: "GetEffectiveFirewalls",
			Handler:    _RegionNetworkFirewallPolicies_GetEffectiveFirewalls_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _RegionNetworkFirewallPolicies_GetIamPolicy_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _RegionNetworkFirewallPolicies_GetRule_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionNetworkFirewallPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionNetworkFirewallPolicies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionNetworkFirewallPolicies_Patch_Handler,
		},
		{
			MethodName: "PatchRule",
			Handler:    _RegionNetworkFirewallPolicies_PatchRule_Handler,
		},
		{
			MethodName: "RemoveAssociation",
			Handler:    _RegionNetworkFirewallPolicies_RemoveAssociation_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _RegionNetworkFirewallPolicies_RemoveRule_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _RegionNetworkFirewallPolicies_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionNetworkFirewallPolicies_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionNotificationEndpoints_Delete_FullMethodName             = "/google.cloud.compute.v1.RegionNotificationEndpoints/Delete"
	RegionNotificationEndpoints_Get_FullMethodName                = "/google.cloud.compute.v1.RegionNotificationEndpoints/Get"
	RegionNotificationEndpoints_Insert_FullMethodName             = "/google.cloud.compute.v1.RegionNotificationEndpoints/Insert"
	RegionNotificationEndpoints_List_FullMethodName               = "/google.cloud.compute.v1.RegionNotificationEndpoints/List"
	RegionNotificationEndpoints_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.RegionNotificationEndpoints/TestIamPermissions"
)

// RegionNotificationEndpointsClient is the client API for RegionNotificationEndpoints service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionNotificationEndpointsClient interface {
	// Deletes the specified NotificationEndpoint in the given region
	Delete(ctx context.Context, in *DeleteRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified NotificationEndpoint resource in the given region.
	Get(ctx context.Context, in *GetRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*NotificationEndpoint, error)
	// Create a NotificationEndpoint in the specified project in the given region
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the NotificationEndpoints for a project in the given region.
	List(ctx context.Context, in *ListRegionNotificationEndpointsRequest, opts ...grpc.CallOption) (*NotificationEndpointList, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type regionNotificationEndpointsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionNotificationEndpointsClient(cc grpc.ClientConnInterface) RegionNotificationEndpointsClient {
	return &regionNotificationEndpointsClient{cc}
}

func (c *regionNotificationEndpointsClient) Delete(ctx context.Context, in *DeleteRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNotificationEndpoints_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNotificationEndpointsClient) Get(ctx context.Context, in *GetRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*NotificationEndpoint, error) {
	out := new(NotificationEndpoint)
	err := c.cc.Invoke(ctx, RegionNotificationEndpoints_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNotificationEndpointsClient) Insert(ctx context.Context, in *InsertRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionNotificationEndpoints_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNotificationEndpointsClient) List(ctx context.Context, in *ListRegionNotificationEndpointsRequest, opts ...grpc.CallOption) (*NotificationEndpointList, error) {
	out := new(NotificationEndpointList)
	err := c.cc.Invoke(ctx, RegionNotificationEndpoints_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionNotificationEndpointsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRegionNotificationEndpointRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, RegionNotificationEndpoints_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionNotificationEndpointsServer is the server API for RegionNotificationEndpoints service.
// All implementations should embed UnimplementedRegionNotificationEndpointsServer
// for forward compatibility
type RegionNotificationEndpointsServer interface {
	// Deletes the specified NotificationEndpoint in the given region
	Delete(context.Context, *DeleteRegionNotificationEndpointRequest) (*Operation, error)
	// Returns the specified NotificationEndpoint resource in the given region.
	Get(context.Context, *GetRegionNotificationEndpointRequest) (*NotificationEndpoint, error)
	// Create a NotificationEndpoint in the specified project in the given region
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertRegionNotificationEndpointRequest) (*Operation, error)
	// Lists the NotificationEndpoints for a project in the given region.
	List(context.Context, *ListRegionNotificationEndpointsRequest) (*NotificationEndpointList, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRegionNotificationEndpointRequest) (*TestPermissionsResponse, error)
}

// UnimplementedRegionNotificationEndpointsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionNotificationEndpointsServer struct {
}

func (UnimplementedRegionNotificationEndpointsServer) Delete(context.Context, *DeleteRegionNotificationEndpointRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionNotificationEndpointsServer) Get(context.Context, *GetRegionNotificationEndpointRequest) (*NotificationEndpoint, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionNotificationEndpointsServer) Insert(context.Context, *InsertRegionNotificationEndpointRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionNotificationEndpointsServer) List(context.Context, *ListRegionNotificationEndpointsRequest) (*NotificationEndpointList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionNotificationEndpointsServer) TestIamPermissions(context.Context, *TestIamPermissionsRegionNotificationEndpointRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeRegionNotificationEndpointsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionNotificationEndpointsServer will
// result in compilation errors.
type UnsafeRegionNotificationEndpointsServer interface {
	mustEmbedUnimplementedRegionNotificationEndpointsServer()
}

func RegisterRegionNotificationEndpointsServer(s grpc.ServiceRegistrar, srv RegionNotificationEndpointsServer) {
	s.RegisterService(&RegionNotificationEndpoints_ServiceDesc, srv)
}

func _RegionNotificationEndpoints_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionNotificationEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNotificationEndpointsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNotificationEndpoints_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNotificationEndpointsServer).Delete(ctx, req.(*DeleteRegionNotificationEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNotificationEndpoints_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionNotificationEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNotificationEndpointsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNotificationEndpoints_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNotificationEndpointsServer).Get(ctx, req.(*GetRegionNotificationEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNotificationEndpoints_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionNotificationEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNotificationEndpointsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNotificationEndpoints_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNotificationEndpointsServer).Insert(ctx, req.(*InsertRegionNotificationEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNotificationEndpoints_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionNotificationEndpointsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNotificationEndpointsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNotificationEndpoints_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNotificationEndpointsServer).List(ctx, req.(*ListRegionNotificationEndpointsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionNotificationEndpoints_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRegionNotificationEndpointRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionNotificationEndpointsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionNotificationEndpoints_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionNotificationEndpointsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRegionNotificationEndpointRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionNotificationEndpoints_ServiceDesc is the grpc.ServiceDesc for RegionNotificationEndpoints service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionNotificationEndpoints_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionNotificationEndpoints",
	HandlerType: (*RegionNotificationEndpointsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionNotificationEndpoints_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionNotificationEndpoints_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionNotificationEndpoints_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionNotificationEndpoints_List_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _RegionNotificationEndpoints_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionOperations_Delete_FullMethodName = "/google.cloud.compute.v1.RegionOperations/Delete"
	RegionOperations_Get_FullMethodName    = "/google.cloud.compute.v1.RegionOperations/Get"
	RegionOperations_List_FullMethodName   = "/google.cloud.compute.v1.RegionOperations/List"
	RegionOperations_Wait_FullMethodName   = "/google.cloud.compute.v1.RegionOperations/Wait"
)

// RegionOperationsClient is the client API for RegionOperations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionOperationsClient interface {
	// Deletes the specified region-specific Operations resource.
	Delete(ctx context.Context, in *DeleteRegionOperationRequest, opts ...grpc.CallOption) (*DeleteRegionOperationResponse, error)
	// Retrieves the specified region-specific Operations resource.
	Get(ctx context.Context, in *GetRegionOperationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of Operation resources contained within
	// the specified region.
	List(ctx context.Context, in *ListRegionOperationsRequest, opts ...grpc.CallOption) (*OperationList, error)
	// Waits for the specified Operation resource to return as `DONE`
	// or for the request to approach the 2 minute deadline, and retrieves the
	// specified Operation resource. This method differs from the
	// `GET` method in that it waits for no more than the default
	// deadline (2 minutes) and then returns the current state of the operation,
	// which might be `DONE` or still in progress.
	//
	// This method is called on a best-effort basis. Specifically:
	//
	//   - In uncommon cases, when the server is overloaded, the request might
	//     return before the default deadline is reached, or might return after zero
	//     seconds.
	//   - If the default deadline is reached, there is no guarantee that the
	//     operation is actually done when the method returns. Be prepared to retry
	//     if the operation is not `DONE`.
	Wait(ctx context.Context, in *WaitRegionOperationRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionOperationsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionOperationsClient(cc grpc.ClientConnInterface) RegionOperationsClient {
	return &regionOperationsClient{cc}
}

func (c *regionOperationsClient) Delete(ctx context.Context, in *DeleteRegionOperationRequest, opts ...grpc.CallOption) (*DeleteRegionOperationResponse, error) {
	out := new(DeleteRegionOperationResponse)
	err := c.cc.Invoke(ctx, RegionOperations_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionOperationsClient) Get(ctx context.Context, in *GetRegionOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionOperations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionOperationsClient) List(ctx context.Context, in *ListRegionOperationsRequest, opts ...grpc.CallOption) (*OperationList, error) {
	out := new(OperationList)
	err := c.cc.Invoke(ctx, RegionOperations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionOperationsClient) Wait(ctx context.Context, in *WaitRegionOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionOperations_Wait_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionOperationsServer is the server API for RegionOperations service.
// All implementations should embed UnimplementedRegionOperationsServer
// for forward compatibility
type RegionOperationsServer interface {
	// Deletes the specified region-specific Operations resource.
	Delete(context.Context, *DeleteRegionOperationRequest) (*DeleteRegionOperationResponse, error)
	// Retrieves the specified region-specific Operations resource.
	Get(context.Context, *GetRegionOperationRequest) (*Operation, error)
	// Retrieves a list of Operation resources contained within
	// the specified region.
	List(context.Context, *ListRegionOperationsRequest) (*OperationList, error)
	// Waits for the specified Operation resource to return as `DONE`
	// or for the request to approach the 2 minute deadline, and retrieves the
	// specified Operation resource. This method differs from the
	// `GET` method in that it waits for no more than the default
	// deadline (2 minutes) and then returns the current state of the operation,
	// which might be `DONE` or still in progress.
	//
	// This method is called on a best-effort basis. Specifically:
	//
	//   - In uncommon cases, when the server is overloaded, the request might
	//     return before the default deadline is reached, or might return after zero
	//     seconds.
	//   - If the default deadline is reached, there is no guarantee that the
	//     operation is actually done when the method returns. Be prepared to retry
	//     if the operation is not `DONE`.
	Wait(context.Context, *WaitRegionOperationRequest) (*Operation, error)
}

// UnimplementedRegionOperationsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionOperationsServer struct {
}

func (UnimplementedRegionOperationsServer) Delete(context.Context, *DeleteRegionOperationRequest) (*DeleteRegionOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionOperationsServer) Get(context.Context, *GetRegionOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionOperationsServer) List(context.Context, *ListRegionOperationsRequest) (*OperationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionOperationsServer) Wait(context.Context, *WaitRegionOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}

// UnsafeRegionOperationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionOperationsServer will
// result in compilation errors.
type UnsafeRegionOperationsServer interface {
	mustEmbedUnimplementedRegionOperationsServer()
}

func RegisterRegionOperationsServer(s grpc.ServiceRegistrar, srv RegionOperationsServer) {
	s.RegisterService(&RegionOperations_ServiceDesc, srv)
}

func _RegionOperations_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionOperationsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionOperations_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionOperationsServer).Delete(ctx, req.(*DeleteRegionOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionOperations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionOperationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionOperations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionOperationsServer).Get(ctx, req.(*GetRegionOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionOperations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionOperationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionOperations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionOperationsServer).List(ctx, req.(*ListRegionOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionOperations_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitRegionOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionOperationsServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionOperations_Wait_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionOperationsServer).Wait(ctx, req.(*WaitRegionOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionOperations_ServiceDesc is the grpc.ServiceDesc for RegionOperations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionOperations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionOperations",
	HandlerType: (*RegionOperationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionOperations_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionOperations_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionOperations_List_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _RegionOperations_Wait_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionSecurityPolicies_AddRule_FullMethodName    = "/google.cloud.compute.v1.RegionSecurityPolicies/AddRule"
	RegionSecurityPolicies_Delete_FullMethodName     = "/google.cloud.compute.v1.RegionSecurityPolicies/Delete"
	RegionSecurityPolicies_Get_FullMethodName        = "/google.cloud.compute.v1.RegionSecurityPolicies/Get"
	RegionSecurityPolicies_GetRule_FullMethodName    = "/google.cloud.compute.v1.RegionSecurityPolicies/GetRule"
	RegionSecurityPolicies_Insert_FullMethodName     = "/google.cloud.compute.v1.RegionSecurityPolicies/Insert"
	RegionSecurityPolicies_List_FullMethodName       = "/google.cloud.compute.v1.RegionSecurityPolicies/List"
	RegionSecurityPolicies_Patch_FullMethodName      = "/google.cloud.compute.v1.RegionSecurityPolicies/Patch"
	RegionSecurityPolicies_PatchRule_FullMethodName  = "/google.cloud.compute.v1.RegionSecurityPolicies/PatchRule"
	RegionSecurityPolicies_RemoveRule_FullMethodName = "/google.cloud.compute.v1.RegionSecurityPolicies/RemoveRule"
	RegionSecurityPolicies_SetLabels_FullMethodName  = "/google.cloud.compute.v1.RegionSecurityPolicies/SetLabels"
)

// RegionSecurityPoliciesClient is the client API for RegionSecurityPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionSecurityPoliciesClient interface {
	// Inserts a rule into a security policy.
	AddRule(ctx context.Context, in *AddRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes the specified policy.
	Delete(ctx context.Context, in *DeleteRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// List all of the ordered rules present in a single specified policy.
	Get(ctx context.Context, in *GetRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicy, error)
	// Gets a rule at the specified priority.
	GetRule(ctx context.Context, in *GetRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(ctx context.Context, in *InsertRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// List all the policies that have been configured for the specified project
	// and region.
	List(ctx context.Context, in *ListRegionSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPolicyList, error)
	// Patches the specified policy with the data included in the request. To
	// clear fields in the policy, leave the fields empty and specify them in the
	// updateMask. This cannot be used to be update the rules in the policy.
	// Please use the per rule methods like addRule, patchRule, and removeRule
	// instead.
	Patch(ctx context.Context, in *PatchRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a rule at the specified priority. To clear fields in the rule,
	// leave the fields empty and specify them in the updateMask.
	PatchRule(ctx context.Context, in *PatchRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a rule at the specified priority.
	RemoveRule(ctx context.Context, in *RemoveRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on a security policy. To learn more about labels,
	// read the Labeling Resources
	// documentation.
	SetLabels(ctx context.Context, in *SetLabelsRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionSecurityPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionSecurityPoliciesClient(cc grpc.ClientConnInterface) RegionSecurityPoliciesClient {
	return &regionSecurityPoliciesClient{cc}
}

func (c *regionSecurityPoliciesClient) AddRule(ctx context.Context, in *AddRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_AddRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) Delete(ctx context.Context, in *DeleteRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) Get(ctx context.Context, in *GetRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicy, error) {
	out := new(SecurityPolicy)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) GetRule(ctx context.Context, in *GetRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyRule, error) {
	out := new(SecurityPolicyRule)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_GetRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) Insert(ctx context.Context, in *InsertRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) List(ctx context.Context, in *ListRegionSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPolicyList, error) {
	out := new(SecurityPolicyList)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) Patch(ctx context.Context, in *PatchRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) PatchRule(ctx context.Context, in *PatchRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_PatchRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) RemoveRule(ctx context.Context, in *RemoveRuleRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_RemoveRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSecurityPoliciesClient) SetLabels(ctx context.Context, in *SetLabelsRegionSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSecurityPolicies_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionSecurityPoliciesServer is the server API for RegionSecurityPolicies service.
// All implementations should embed UnimplementedRegionSecurityPoliciesServer
// for forward compatibility
type RegionSecurityPoliciesServer interface {
	// Inserts a rule into a security policy.
	AddRule(context.Context, *AddRuleRegionSecurityPolicyRequest) (*Operation, error)
	// Deletes the specified policy.
	Delete(context.Context, *DeleteRegionSecurityPolicyRequest) (*Operation, error)
	// List all of the ordered rules present in a single specified policy.
	Get(context.Context, *GetRegionSecurityPolicyRequest) (*SecurityPolicy, error)
	// Gets a rule at the specified priority.
	GetRule(context.Context, *GetRuleRegionSecurityPolicyRequest) (*SecurityPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(context.Context, *InsertRegionSecurityPolicyRequest) (*Operation, error)
	// List all the policies that have been configured for the specified project
	// and region.
	List(context.Context, *ListRegionSecurityPoliciesRequest) (*SecurityPolicyList, error)
	// Patches the specified policy with the data included in the request. To
	// clear fields in the policy, leave the fields empty and specify them in the
	// updateMask. This cannot be used to be update the rules in the policy.
	// Please use the per rule methods like addRule, patchRule, and removeRule
	// instead.
	Patch(context.Context, *PatchRegionSecurityPolicyRequest) (*Operation, error)
	// Patches a rule at the specified priority. To clear fields in the rule,
	// leave the fields empty and specify them in the updateMask.
	PatchRule(context.Context, *PatchRuleRegionSecurityPolicyRequest) (*Operation, error)
	// Deletes a rule at the specified priority.
	RemoveRule(context.Context, *RemoveRuleRegionSecurityPolicyRequest) (*Operation, error)
	// Sets the labels on a security policy. To learn more about labels,
	// read the Labeling Resources
	// documentation.
	SetLabels(context.Context, *SetLabelsRegionSecurityPolicyRequest) (*Operation, error)
}

// UnimplementedRegionSecurityPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionSecurityPoliciesServer struct {
}

func (UnimplementedRegionSecurityPoliciesServer) AddRule(context.Context, *AddRuleRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) Delete(context.Context, *DeleteRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) Get(context.Context, *GetRegionSecurityPolicyRequest) (*SecurityPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) GetRule(context.Context, *GetRuleRegionSecurityPolicyRequest) (*SecurityPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) Insert(context.Context, *InsertRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) List(context.Context, *ListRegionSecurityPoliciesRequest) (*SecurityPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) Patch(context.Context, *PatchRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) PatchRule(context.Context, *PatchRuleRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRule not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) RemoveRule(context.Context, *RemoveRuleRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedRegionSecurityPoliciesServer) SetLabels(context.Context, *SetLabelsRegionSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}

// UnsafeRegionSecurityPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionSecurityPoliciesServer will
// result in compilation errors.
type UnsafeRegionSecurityPoliciesServer interface {
	mustEmbedUnimplementedRegionSecurityPoliciesServer()
}

func RegisterRegionSecurityPoliciesServer(s grpc.ServiceRegistrar, srv RegionSecurityPoliciesServer) {
	s.RegisterService(&RegionSecurityPolicies_ServiceDesc, srv)
}

func _RegionSecurityPolicies_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).AddRule(ctx, req.(*AddRuleRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).Delete(ctx, req.(*DeleteRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).Get(ctx, req.(*GetRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).GetRule(ctx, req.(*GetRuleRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).Insert(ctx, req.(*InsertRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionSecurityPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).List(ctx, req.(*ListRegionSecurityPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).Patch(ctx, req.(*PatchRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_PatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRuleRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).PatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_PatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).PatchRule(ctx, req.(*PatchRuleRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).RemoveRule(ctx, req.(*RemoveRuleRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSecurityPolicies_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsRegionSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSecurityPoliciesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSecurityPolicies_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSecurityPoliciesServer).SetLabels(ctx, req.(*SetLabelsRegionSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionSecurityPolicies_ServiceDesc is the grpc.ServiceDesc for RegionSecurityPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionSecurityPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionSecurityPolicies",
	HandlerType: (*RegionSecurityPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRule",
			Handler:    _RegionSecurityPolicies_AddRule_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _RegionSecurityPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionSecurityPolicies_Get_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _RegionSecurityPolicies_GetRule_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionSecurityPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionSecurityPolicies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionSecurityPolicies_Patch_Handler,
		},
		{
			MethodName: "PatchRule",
			Handler:    _RegionSecurityPolicies_PatchRule_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _RegionSecurityPolicies_RemoveRule_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _RegionSecurityPolicies_SetLabels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionSslCertificates_Delete_FullMethodName = "/google.cloud.compute.v1.RegionSslCertificates/Delete"
	RegionSslCertificates_Get_FullMethodName    = "/google.cloud.compute.v1.RegionSslCertificates/Get"
	RegionSslCertificates_Insert_FullMethodName = "/google.cloud.compute.v1.RegionSslCertificates/Insert"
	RegionSslCertificates_List_FullMethodName   = "/google.cloud.compute.v1.RegionSslCertificates/List"
)

// RegionSslCertificatesClient is the client API for RegionSslCertificates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionSslCertificatesClient interface {
	// Deletes the specified SslCertificate resource in the region.
	Delete(ctx context.Context, in *DeleteRegionSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified SslCertificate resource in the specified region. Get
	// a list of available SSL certificates by making a list()
	// request.
	Get(ctx context.Context, in *GetRegionSslCertificateRequest, opts ...grpc.CallOption) (*SslCertificate, error)
	// Creates a SslCertificate resource in the specified project and region using
	// the data included in the request
	Insert(ctx context.Context, in *InsertRegionSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of SslCertificate resources available to the specified
	// project in the specified region.
	List(ctx context.Context, in *ListRegionSslCertificatesRequest, opts ...grpc.CallOption) (*SslCertificateList, error)
}

type regionSslCertificatesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionSslCertificatesClient(cc grpc.ClientConnInterface) RegionSslCertificatesClient {
	return &regionSslCertificatesClient{cc}
}

func (c *regionSslCertificatesClient) Delete(ctx context.Context, in *DeleteRegionSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSslCertificates_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslCertificatesClient) Get(ctx context.Context, in *GetRegionSslCertificateRequest, opts ...grpc.CallOption) (*SslCertificate, error) {
	out := new(SslCertificate)
	err := c.cc.Invoke(ctx, RegionSslCertificates_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslCertificatesClient) Insert(ctx context.Context, in *InsertRegionSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSslCertificates_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslCertificatesClient) List(ctx context.Context, in *ListRegionSslCertificatesRequest, opts ...grpc.CallOption) (*SslCertificateList, error) {
	out := new(SslCertificateList)
	err := c.cc.Invoke(ctx, RegionSslCertificates_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionSslCertificatesServer is the server API for RegionSslCertificates service.
// All implementations should embed UnimplementedRegionSslCertificatesServer
// for forward compatibility
type RegionSslCertificatesServer interface {
	// Deletes the specified SslCertificate resource in the region.
	Delete(context.Context, *DeleteRegionSslCertificateRequest) (*Operation, error)
	// Returns the specified SslCertificate resource in the specified region. Get
	// a list of available SSL certificates by making a list()
	// request.
	Get(context.Context, *GetRegionSslCertificateRequest) (*SslCertificate, error)
	// Creates a SslCertificate resource in the specified project and region using
	// the data included in the request
	Insert(context.Context, *InsertRegionSslCertificateRequest) (*Operation, error)
	// Retrieves the list of SslCertificate resources available to the specified
	// project in the specified region.
	List(context.Context, *ListRegionSslCertificatesRequest) (*SslCertificateList, error)
}

// UnimplementedRegionSslCertificatesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionSslCertificatesServer struct {
}

func (UnimplementedRegionSslCertificatesServer) Delete(context.Context, *DeleteRegionSslCertificateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionSslCertificatesServer) Get(context.Context, *GetRegionSslCertificateRequest) (*SslCertificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionSslCertificatesServer) Insert(context.Context, *InsertRegionSslCertificateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionSslCertificatesServer) List(context.Context, *ListRegionSslCertificatesRequest) (*SslCertificateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeRegionSslCertificatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionSslCertificatesServer will
// result in compilation errors.
type UnsafeRegionSslCertificatesServer interface {
	mustEmbedUnimplementedRegionSslCertificatesServer()
}

func RegisterRegionSslCertificatesServer(s grpc.ServiceRegistrar, srv RegionSslCertificatesServer) {
	s.RegisterService(&RegionSslCertificates_ServiceDesc, srv)
}

func _RegionSslCertificates_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionSslCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslCertificatesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslCertificates_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslCertificatesServer).Delete(ctx, req.(*DeleteRegionSslCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslCertificates_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionSslCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslCertificatesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslCertificates_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslCertificatesServer).Get(ctx, req.(*GetRegionSslCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslCertificates_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionSslCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslCertificatesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslCertificates_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslCertificatesServer).Insert(ctx, req.(*InsertRegionSslCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslCertificates_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionSslCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslCertificatesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslCertificates_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslCertificatesServer).List(ctx, req.(*ListRegionSslCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionSslCertificates_ServiceDesc is the grpc.ServiceDesc for RegionSslCertificates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionSslCertificates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionSslCertificates",
	HandlerType: (*RegionSslCertificatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionSslCertificates_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionSslCertificates_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionSslCertificates_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionSslCertificates_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionSslPolicies_Delete_FullMethodName                = "/google.cloud.compute.v1.RegionSslPolicies/Delete"
	RegionSslPolicies_Get_FullMethodName                   = "/google.cloud.compute.v1.RegionSslPolicies/Get"
	RegionSslPolicies_Insert_FullMethodName                = "/google.cloud.compute.v1.RegionSslPolicies/Insert"
	RegionSslPolicies_List_FullMethodName                  = "/google.cloud.compute.v1.RegionSslPolicies/List"
	RegionSslPolicies_ListAvailableFeatures_FullMethodName = "/google.cloud.compute.v1.RegionSslPolicies/ListAvailableFeatures"
	RegionSslPolicies_Patch_FullMethodName                 = "/google.cloud.compute.v1.RegionSslPolicies/Patch"
)

// RegionSslPoliciesClient is the client API for RegionSslPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionSslPoliciesClient interface {
	// Deletes the specified SSL policy. The SSL policy resource can be deleted
	// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
	// resources.
	Delete(ctx context.Context, in *DeleteRegionSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all of the ordered rules present in a single specified policy.
	Get(ctx context.Context, in *GetRegionSslPolicyRequest, opts ...grpc.CallOption) (*SslPolicy, error)
	// Creates a new policy in the specified project and region using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertRegionSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all the SSL policies that have been configured for the specified
	// project and region.
	List(ctx context.Context, in *ListRegionSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesList, error)
	// Lists all features that can be specified in the SSL policy when using
	// custom profile.
	ListAvailableFeatures(ctx context.Context, in *ListAvailableFeaturesRegionSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesListAvailableFeaturesResponse, error)
	// Patches the specified SSL policy with the data included in the request.
	Patch(ctx context.Context, in *PatchRegionSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionSslPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionSslPoliciesClient(cc grpc.ClientConnInterface) RegionSslPoliciesClient {
	return &regionSslPoliciesClient{cc}
}

func (c *regionSslPoliciesClient) Delete(ctx context.Context, in *DeleteRegionSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSslPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslPoliciesClient) Get(ctx context.Context, in *GetRegionSslPolicyRequest, opts ...grpc.CallOption) (*SslPolicy, error) {
	out := new(SslPolicy)
	err := c.cc.Invoke(ctx, RegionSslPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslPoliciesClient) Insert(ctx context.Context, in *InsertRegionSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSslPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslPoliciesClient) List(ctx context.Context, in *ListRegionSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesList, error) {
	out := new(SslPoliciesList)
	err := c.cc.Invoke(ctx, RegionSslPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslPoliciesClient) ListAvailableFeatures(ctx context.Context, in *ListAvailableFeaturesRegionSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesListAvailableFeaturesResponse, error) {
	out := new(SslPoliciesListAvailableFeaturesResponse)
	err := c.cc.Invoke(ctx, RegionSslPolicies_ListAvailableFeatures_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionSslPoliciesClient) Patch(ctx context.Context, in *PatchRegionSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionSslPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionSslPoliciesServer is the server API for RegionSslPolicies service.
// All implementations should embed UnimplementedRegionSslPoliciesServer
// for forward compatibility
type RegionSslPoliciesServer interface {
	// Deletes the specified SSL policy. The SSL policy resource can be deleted
	// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
	// resources.
	Delete(context.Context, *DeleteRegionSslPolicyRequest) (*Operation, error)
	// Lists all of the ordered rules present in a single specified policy.
	Get(context.Context, *GetRegionSslPolicyRequest) (*SslPolicy, error)
	// Creates a new policy in the specified project and region using the data
	// included in the request.
	Insert(context.Context, *InsertRegionSslPolicyRequest) (*Operation, error)
	// Lists all the SSL policies that have been configured for the specified
	// project and region.
	List(context.Context, *ListRegionSslPoliciesRequest) (*SslPoliciesList, error)
	// Lists all features that can be specified in the SSL policy when using
	// custom profile.
	ListAvailableFeatures(context.Context, *ListAvailableFeaturesRegionSslPoliciesRequest) (*SslPoliciesListAvailableFeaturesResponse, error)
	// Patches the specified SSL policy with the data included in the request.
	Patch(context.Context, *PatchRegionSslPolicyRequest) (*Operation, error)
}

// UnimplementedRegionSslPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionSslPoliciesServer struct {
}

func (UnimplementedRegionSslPoliciesServer) Delete(context.Context, *DeleteRegionSslPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionSslPoliciesServer) Get(context.Context, *GetRegionSslPolicyRequest) (*SslPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionSslPoliciesServer) Insert(context.Context, *InsertRegionSslPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionSslPoliciesServer) List(context.Context, *ListRegionSslPoliciesRequest) (*SslPoliciesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionSslPoliciesServer) ListAvailableFeatures(context.Context, *ListAvailableFeaturesRegionSslPoliciesRequest) (*SslPoliciesListAvailableFeaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableFeatures not implemented")
}
func (UnimplementedRegionSslPoliciesServer) Patch(context.Context, *PatchRegionSslPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeRegionSslPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionSslPoliciesServer will
// result in compilation errors.
type UnsafeRegionSslPoliciesServer interface {
	mustEmbedUnimplementedRegionSslPoliciesServer()
}

func RegisterRegionSslPoliciesServer(s grpc.ServiceRegistrar, srv RegionSslPoliciesServer) {
	s.RegisterService(&RegionSslPolicies_ServiceDesc, srv)
}

func _RegionSslPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslPoliciesServer).Delete(ctx, req.(*DeleteRegionSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslPoliciesServer).Get(ctx, req.(*GetRegionSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslPoliciesServer).Insert(ctx, req.(*InsertRegionSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionSslPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslPoliciesServer).List(ctx, req.(*ListRegionSslPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslPolicies_ListAvailableFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableFeaturesRegionSslPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslPoliciesServer).ListAvailableFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslPolicies_ListAvailableFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslPoliciesServer).ListAvailableFeatures(ctx, req.(*ListAvailableFeaturesRegionSslPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionSslPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionSslPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionSslPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionSslPoliciesServer).Patch(ctx, req.(*PatchRegionSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionSslPolicies_ServiceDesc is the grpc.ServiceDesc for RegionSslPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionSslPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionSslPolicies",
	HandlerType: (*RegionSslPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionSslPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionSslPolicies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionSslPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionSslPolicies_List_Handler,
		},
		{
			MethodName: "ListAvailableFeatures",
			Handler:    _RegionSslPolicies_ListAvailableFeatures_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionSslPolicies_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionTargetHttpProxies_Delete_FullMethodName    = "/google.cloud.compute.v1.RegionTargetHttpProxies/Delete"
	RegionTargetHttpProxies_Get_FullMethodName       = "/google.cloud.compute.v1.RegionTargetHttpProxies/Get"
	RegionTargetHttpProxies_Insert_FullMethodName    = "/google.cloud.compute.v1.RegionTargetHttpProxies/Insert"
	RegionTargetHttpProxies_List_FullMethodName      = "/google.cloud.compute.v1.RegionTargetHttpProxies/List"
	RegionTargetHttpProxies_SetUrlMap_FullMethodName = "/google.cloud.compute.v1.RegionTargetHttpProxies/SetUrlMap"
)

// RegionTargetHttpProxiesClient is the client API for RegionTargetHttpProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionTargetHttpProxiesClient interface {
	// Deletes the specified TargetHttpProxy resource.
	Delete(ctx context.Context, in *DeleteRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetHttpProxy resource in the specified region.
	Get(ctx context.Context, in *GetRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*TargetHttpProxy, error)
	// Creates a TargetHttpProxy resource in the specified project and region
	// using the data included in the request.
	Insert(ctx context.Context, in *InsertRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of TargetHttpProxy resources available
	// to the specified project in the specified region.
	List(ctx context.Context, in *ListRegionTargetHttpProxiesRequest, opts ...grpc.CallOption) (*TargetHttpProxyList, error)
	// Changes the URL map for TargetHttpProxy.
	SetUrlMap(ctx context.Context, in *SetUrlMapRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionTargetHttpProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionTargetHttpProxiesClient(cc grpc.ClientConnInterface) RegionTargetHttpProxiesClient {
	return &regionTargetHttpProxiesClient{cc}
}

func (c *regionTargetHttpProxiesClient) Delete(ctx context.Context, in *DeleteRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpProxiesClient) Get(ctx context.Context, in *GetRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*TargetHttpProxy, error) {
	out := new(TargetHttpProxy)
	err := c.cc.Invoke(ctx, RegionTargetHttpProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpProxiesClient) Insert(ctx context.Context, in *InsertRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpProxiesClient) List(ctx context.Context, in *ListRegionTargetHttpProxiesRequest, opts ...grpc.CallOption) (*TargetHttpProxyList, error) {
	out := new(TargetHttpProxyList)
	err := c.cc.Invoke(ctx, RegionTargetHttpProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpProxiesClient) SetUrlMap(ctx context.Context, in *SetUrlMapRegionTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpProxies_SetUrlMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionTargetHttpProxiesServer is the server API for RegionTargetHttpProxies service.
// All implementations should embed UnimplementedRegionTargetHttpProxiesServer
// for forward compatibility
type RegionTargetHttpProxiesServer interface {
	// Deletes the specified TargetHttpProxy resource.
	Delete(context.Context, *DeleteRegionTargetHttpProxyRequest) (*Operation, error)
	// Returns the specified TargetHttpProxy resource in the specified region.
	Get(context.Context, *GetRegionTargetHttpProxyRequest) (*TargetHttpProxy, error)
	// Creates a TargetHttpProxy resource in the specified project and region
	// using the data included in the request.
	Insert(context.Context, *InsertRegionTargetHttpProxyRequest) (*Operation, error)
	// Retrieves the list of TargetHttpProxy resources available
	// to the specified project in the specified region.
	List(context.Context, *ListRegionTargetHttpProxiesRequest) (*TargetHttpProxyList, error)
	// Changes the URL map for TargetHttpProxy.
	SetUrlMap(context.Context, *SetUrlMapRegionTargetHttpProxyRequest) (*Operation, error)
}

// UnimplementedRegionTargetHttpProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionTargetHttpProxiesServer struct {
}

func (UnimplementedRegionTargetHttpProxiesServer) Delete(context.Context, *DeleteRegionTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionTargetHttpProxiesServer) Get(context.Context, *GetRegionTargetHttpProxyRequest) (*TargetHttpProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionTargetHttpProxiesServer) Insert(context.Context, *InsertRegionTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionTargetHttpProxiesServer) List(context.Context, *ListRegionTargetHttpProxiesRequest) (*TargetHttpProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionTargetHttpProxiesServer) SetUrlMap(context.Context, *SetUrlMapRegionTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUrlMap not implemented")
}

// UnsafeRegionTargetHttpProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionTargetHttpProxiesServer will
// result in compilation errors.
type UnsafeRegionTargetHttpProxiesServer interface {
	mustEmbedUnimplementedRegionTargetHttpProxiesServer()
}

func RegisterRegionTargetHttpProxiesServer(s grpc.ServiceRegistrar, srv RegionTargetHttpProxiesServer) {
	s.RegisterService(&RegionTargetHttpProxies_ServiceDesc, srv)
}

func _RegionTargetHttpProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpProxiesServer).Delete(ctx, req.(*DeleteRegionTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpProxiesServer).Get(ctx, req.(*GetRegionTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpProxiesServer).Insert(ctx, req.(*InsertRegionTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionTargetHttpProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpProxiesServer).List(ctx, req.(*ListRegionTargetHttpProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpProxies_SetUrlMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUrlMapRegionTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpProxiesServer).SetUrlMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpProxies_SetUrlMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpProxiesServer).SetUrlMap(ctx, req.(*SetUrlMapRegionTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionTargetHttpProxies_ServiceDesc is the grpc.ServiceDesc for RegionTargetHttpProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionTargetHttpProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionTargetHttpProxies",
	HandlerType: (*RegionTargetHttpProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionTargetHttpProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionTargetHttpProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionTargetHttpProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionTargetHttpProxies_List_Handler,
		},
		{
			MethodName: "SetUrlMap",
			Handler:    _RegionTargetHttpProxies_SetUrlMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionTargetHttpsProxies_Delete_FullMethodName             = "/google.cloud.compute.v1.RegionTargetHttpsProxies/Delete"
	RegionTargetHttpsProxies_Get_FullMethodName                = "/google.cloud.compute.v1.RegionTargetHttpsProxies/Get"
	RegionTargetHttpsProxies_Insert_FullMethodName             = "/google.cloud.compute.v1.RegionTargetHttpsProxies/Insert"
	RegionTargetHttpsProxies_List_FullMethodName               = "/google.cloud.compute.v1.RegionTargetHttpsProxies/List"
	RegionTargetHttpsProxies_Patch_FullMethodName              = "/google.cloud.compute.v1.RegionTargetHttpsProxies/Patch"
	RegionTargetHttpsProxies_SetSslCertificates_FullMethodName = "/google.cloud.compute.v1.RegionTargetHttpsProxies/SetSslCertificates"
	RegionTargetHttpsProxies_SetUrlMap_FullMethodName          = "/google.cloud.compute.v1.RegionTargetHttpsProxies/SetUrlMap"
)

// RegionTargetHttpsProxiesClient is the client API for RegionTargetHttpsProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionTargetHttpsProxiesClient interface {
	// Deletes the specified TargetHttpsProxy resource.
	Delete(ctx context.Context, in *DeleteRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetHttpsProxy resource in the specified region.
	Get(ctx context.Context, in *GetRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*TargetHttpsProxy, error)
	// Creates a TargetHttpsProxy resource in the specified project and region
	// using the data included in the request.
	Insert(ctx context.Context, in *InsertRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of TargetHttpsProxy resources available
	// to the specified project in the specified region.
	List(ctx context.Context, in *ListRegionTargetHttpsProxiesRequest, opts ...grpc.CallOption) (*TargetHttpsProxyList, error)
	// Patches the specified regional TargetHttpsProxy resource with the data
	// included in the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Replaces SslCertificates for TargetHttpsProxy.
	SetSslCertificates(ctx context.Context, in *SetSslCertificatesRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the URL map for TargetHttpsProxy.
	SetUrlMap(ctx context.Context, in *SetUrlMapRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type regionTargetHttpsProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionTargetHttpsProxiesClient(cc grpc.ClientConnInterface) RegionTargetHttpsProxiesClient {
	return &regionTargetHttpsProxiesClient{cc}
}

func (c *regionTargetHttpsProxiesClient) Delete(ctx context.Context, in *DeleteRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpsProxiesClient) Get(ctx context.Context, in *GetRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*TargetHttpsProxy, error) {
	out := new(TargetHttpsProxy)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpsProxiesClient) Insert(ctx context.Context, in *InsertRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpsProxiesClient) List(ctx context.Context, in *ListRegionTargetHttpsProxiesRequest, opts ...grpc.CallOption) (*TargetHttpsProxyList, error) {
	out := new(TargetHttpsProxyList)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpsProxiesClient) Patch(ctx context.Context, in *PatchRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpsProxiesClient) SetSslCertificates(ctx context.Context, in *SetSslCertificatesRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_SetSslCertificates_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetHttpsProxiesClient) SetUrlMap(ctx context.Context, in *SetUrlMapRegionTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetHttpsProxies_SetUrlMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionTargetHttpsProxiesServer is the server API for RegionTargetHttpsProxies service.
// All implementations should embed UnimplementedRegionTargetHttpsProxiesServer
// for forward compatibility
type RegionTargetHttpsProxiesServer interface {
	// Deletes the specified TargetHttpsProxy resource.
	Delete(context.Context, *DeleteRegionTargetHttpsProxyRequest) (*Operation, error)
	// Returns the specified TargetHttpsProxy resource in the specified region.
	Get(context.Context, *GetRegionTargetHttpsProxyRequest) (*TargetHttpsProxy, error)
	// Creates a TargetHttpsProxy resource in the specified project and region
	// using the data included in the request.
	Insert(context.Context, *InsertRegionTargetHttpsProxyRequest) (*Operation, error)
	// Retrieves the list of TargetHttpsProxy resources available
	// to the specified project in the specified region.
	List(context.Context, *ListRegionTargetHttpsProxiesRequest) (*TargetHttpsProxyList, error)
	// Patches the specified regional TargetHttpsProxy resource with the data
	// included in the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRegionTargetHttpsProxyRequest) (*Operation, error)
	// Replaces SslCertificates for TargetHttpsProxy.
	SetSslCertificates(context.Context, *SetSslCertificatesRegionTargetHttpsProxyRequest) (*Operation, error)
	// Changes the URL map for TargetHttpsProxy.
	SetUrlMap(context.Context, *SetUrlMapRegionTargetHttpsProxyRequest) (*Operation, error)
}

// UnimplementedRegionTargetHttpsProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionTargetHttpsProxiesServer struct {
}

func (UnimplementedRegionTargetHttpsProxiesServer) Delete(context.Context, *DeleteRegionTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionTargetHttpsProxiesServer) Get(context.Context, *GetRegionTargetHttpsProxyRequest) (*TargetHttpsProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionTargetHttpsProxiesServer) Insert(context.Context, *InsertRegionTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionTargetHttpsProxiesServer) List(context.Context, *ListRegionTargetHttpsProxiesRequest) (*TargetHttpsProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionTargetHttpsProxiesServer) Patch(context.Context, *PatchRegionTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionTargetHttpsProxiesServer) SetSslCertificates(context.Context, *SetSslCertificatesRegionTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSslCertificates not implemented")
}
func (UnimplementedRegionTargetHttpsProxiesServer) SetUrlMap(context.Context, *SetUrlMapRegionTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUrlMap not implemented")
}

// UnsafeRegionTargetHttpsProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionTargetHttpsProxiesServer will
// result in compilation errors.
type UnsafeRegionTargetHttpsProxiesServer interface {
	mustEmbedUnimplementedRegionTargetHttpsProxiesServer()
}

func RegisterRegionTargetHttpsProxiesServer(s grpc.ServiceRegistrar, srv RegionTargetHttpsProxiesServer) {
	s.RegisterService(&RegionTargetHttpsProxies_ServiceDesc, srv)
}

func _RegionTargetHttpsProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).Delete(ctx, req.(*DeleteRegionTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpsProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).Get(ctx, req.(*GetRegionTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpsProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).Insert(ctx, req.(*InsertRegionTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpsProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionTargetHttpsProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).List(ctx, req.(*ListRegionTargetHttpsProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpsProxies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).Patch(ctx, req.(*PatchRegionTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpsProxies_SetSslCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSslCertificatesRegionTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).SetSslCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_SetSslCertificates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).SetSslCertificates(ctx, req.(*SetSslCertificatesRegionTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetHttpsProxies_SetUrlMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUrlMapRegionTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetHttpsProxiesServer).SetUrlMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetHttpsProxies_SetUrlMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetHttpsProxiesServer).SetUrlMap(ctx, req.(*SetUrlMapRegionTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionTargetHttpsProxies_ServiceDesc is the grpc.ServiceDesc for RegionTargetHttpsProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionTargetHttpsProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionTargetHttpsProxies",
	HandlerType: (*RegionTargetHttpsProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionTargetHttpsProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionTargetHttpsProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionTargetHttpsProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionTargetHttpsProxies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionTargetHttpsProxies_Patch_Handler,
		},
		{
			MethodName: "SetSslCertificates",
			Handler:    _RegionTargetHttpsProxies_SetSslCertificates_Handler,
		},
		{
			MethodName: "SetUrlMap",
			Handler:    _RegionTargetHttpsProxies_SetUrlMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionTargetTcpProxies_Delete_FullMethodName = "/google.cloud.compute.v1.RegionTargetTcpProxies/Delete"
	RegionTargetTcpProxies_Get_FullMethodName    = "/google.cloud.compute.v1.RegionTargetTcpProxies/Get"
	RegionTargetTcpProxies_Insert_FullMethodName = "/google.cloud.compute.v1.RegionTargetTcpProxies/Insert"
	RegionTargetTcpProxies_List_FullMethodName   = "/google.cloud.compute.v1.RegionTargetTcpProxies/List"
)

// RegionTargetTcpProxiesClient is the client API for RegionTargetTcpProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionTargetTcpProxiesClient interface {
	// Deletes the specified TargetTcpProxy resource.
	Delete(ctx context.Context, in *DeleteRegionTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetTcpProxy resource.
	Get(ctx context.Context, in *GetRegionTargetTcpProxyRequest, opts ...grpc.CallOption) (*TargetTcpProxy, error)
	// Creates a TargetTcpProxy resource in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertRegionTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of TargetTcpProxy resources
	// available to the specified project in a given region.
	List(ctx context.Context, in *ListRegionTargetTcpProxiesRequest, opts ...grpc.CallOption) (*TargetTcpProxyList, error)
}

type regionTargetTcpProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionTargetTcpProxiesClient(cc grpc.ClientConnInterface) RegionTargetTcpProxiesClient {
	return &regionTargetTcpProxiesClient{cc}
}

func (c *regionTargetTcpProxiesClient) Delete(ctx context.Context, in *DeleteRegionTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetTcpProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetTcpProxiesClient) Get(ctx context.Context, in *GetRegionTargetTcpProxyRequest, opts ...grpc.CallOption) (*TargetTcpProxy, error) {
	out := new(TargetTcpProxy)
	err := c.cc.Invoke(ctx, RegionTargetTcpProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetTcpProxiesClient) Insert(ctx context.Context, in *InsertRegionTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionTargetTcpProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionTargetTcpProxiesClient) List(ctx context.Context, in *ListRegionTargetTcpProxiesRequest, opts ...grpc.CallOption) (*TargetTcpProxyList, error) {
	out := new(TargetTcpProxyList)
	err := c.cc.Invoke(ctx, RegionTargetTcpProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionTargetTcpProxiesServer is the server API for RegionTargetTcpProxies service.
// All implementations should embed UnimplementedRegionTargetTcpProxiesServer
// for forward compatibility
type RegionTargetTcpProxiesServer interface {
	// Deletes the specified TargetTcpProxy resource.
	Delete(context.Context, *DeleteRegionTargetTcpProxyRequest) (*Operation, error)
	// Returns the specified TargetTcpProxy resource.
	Get(context.Context, *GetRegionTargetTcpProxyRequest) (*TargetTcpProxy, error)
	// Creates a TargetTcpProxy resource in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertRegionTargetTcpProxyRequest) (*Operation, error)
	// Retrieves a list of TargetTcpProxy resources
	// available to the specified project in a given region.
	List(context.Context, *ListRegionTargetTcpProxiesRequest) (*TargetTcpProxyList, error)
}

// UnimplementedRegionTargetTcpProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionTargetTcpProxiesServer struct {
}

func (UnimplementedRegionTargetTcpProxiesServer) Delete(context.Context, *DeleteRegionTargetTcpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionTargetTcpProxiesServer) Get(context.Context, *GetRegionTargetTcpProxyRequest) (*TargetTcpProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionTargetTcpProxiesServer) Insert(context.Context, *InsertRegionTargetTcpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionTargetTcpProxiesServer) List(context.Context, *ListRegionTargetTcpProxiesRequest) (*TargetTcpProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeRegionTargetTcpProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionTargetTcpProxiesServer will
// result in compilation errors.
type UnsafeRegionTargetTcpProxiesServer interface {
	mustEmbedUnimplementedRegionTargetTcpProxiesServer()
}

func RegisterRegionTargetTcpProxiesServer(s grpc.ServiceRegistrar, srv RegionTargetTcpProxiesServer) {
	s.RegisterService(&RegionTargetTcpProxies_ServiceDesc, srv)
}

func _RegionTargetTcpProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetTcpProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetTcpProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetTcpProxiesServer).Delete(ctx, req.(*DeleteRegionTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetTcpProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetTcpProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetTcpProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetTcpProxiesServer).Get(ctx, req.(*GetRegionTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetTcpProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetTcpProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetTcpProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetTcpProxiesServer).Insert(ctx, req.(*InsertRegionTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionTargetTcpProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionTargetTcpProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionTargetTcpProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionTargetTcpProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionTargetTcpProxiesServer).List(ctx, req.(*ListRegionTargetTcpProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionTargetTcpProxies_ServiceDesc is the grpc.ServiceDesc for RegionTargetTcpProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionTargetTcpProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionTargetTcpProxies",
	HandlerType: (*RegionTargetTcpProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionTargetTcpProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionTargetTcpProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionTargetTcpProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionTargetTcpProxies_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionUrlMaps_Delete_FullMethodName   = "/google.cloud.compute.v1.RegionUrlMaps/Delete"
	RegionUrlMaps_Get_FullMethodName      = "/google.cloud.compute.v1.RegionUrlMaps/Get"
	RegionUrlMaps_Insert_FullMethodName   = "/google.cloud.compute.v1.RegionUrlMaps/Insert"
	RegionUrlMaps_List_FullMethodName     = "/google.cloud.compute.v1.RegionUrlMaps/List"
	RegionUrlMaps_Patch_FullMethodName    = "/google.cloud.compute.v1.RegionUrlMaps/Patch"
	RegionUrlMaps_Update_FullMethodName   = "/google.cloud.compute.v1.RegionUrlMaps/Update"
	RegionUrlMaps_Validate_FullMethodName = "/google.cloud.compute.v1.RegionUrlMaps/Validate"
)

// RegionUrlMapsClient is the client API for RegionUrlMaps service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionUrlMapsClient interface {
	// Deletes the specified UrlMap resource.
	Delete(ctx context.Context, in *DeleteRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified UrlMap resource.
	Get(ctx context.Context, in *GetRegionUrlMapRequest, opts ...grpc.CallOption) (*UrlMap, error)
	// Creates a UrlMap resource in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of UrlMap resources available to the specified
	// project in the specified region.
	List(ctx context.Context, in *ListRegionUrlMapsRequest, opts ...grpc.CallOption) (*UrlMapList, error)
	// Patches the specified UrlMap resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates the specified UrlMap resource with the data included in the
	// request.
	Update(ctx context.Context, in *UpdateRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Runs static validation for the UrlMap. In particular, the tests of the
	// provided UrlMap will be run. Calling this method does NOT create the
	// UrlMap.
	Validate(ctx context.Context, in *ValidateRegionUrlMapRequest, opts ...grpc.CallOption) (*UrlMapsValidateResponse, error)
}

type regionUrlMapsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionUrlMapsClient(cc grpc.ClientConnInterface) RegionUrlMapsClient {
	return &regionUrlMapsClient{cc}
}

func (c *regionUrlMapsClient) Delete(ctx context.Context, in *DeleteRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionUrlMaps_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionUrlMapsClient) Get(ctx context.Context, in *GetRegionUrlMapRequest, opts ...grpc.CallOption) (*UrlMap, error) {
	out := new(UrlMap)
	err := c.cc.Invoke(ctx, RegionUrlMaps_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionUrlMapsClient) Insert(ctx context.Context, in *InsertRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionUrlMaps_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionUrlMapsClient) List(ctx context.Context, in *ListRegionUrlMapsRequest, opts ...grpc.CallOption) (*UrlMapList, error) {
	out := new(UrlMapList)
	err := c.cc.Invoke(ctx, RegionUrlMaps_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionUrlMapsClient) Patch(ctx context.Context, in *PatchRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionUrlMaps_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionUrlMapsClient) Update(ctx context.Context, in *UpdateRegionUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, RegionUrlMaps_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionUrlMapsClient) Validate(ctx context.Context, in *ValidateRegionUrlMapRequest, opts ...grpc.CallOption) (*UrlMapsValidateResponse, error) {
	out := new(UrlMapsValidateResponse)
	err := c.cc.Invoke(ctx, RegionUrlMaps_Validate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionUrlMapsServer is the server API for RegionUrlMaps service.
// All implementations should embed UnimplementedRegionUrlMapsServer
// for forward compatibility
type RegionUrlMapsServer interface {
	// Deletes the specified UrlMap resource.
	Delete(context.Context, *DeleteRegionUrlMapRequest) (*Operation, error)
	// Returns the specified UrlMap resource.
	Get(context.Context, *GetRegionUrlMapRequest) (*UrlMap, error)
	// Creates a UrlMap resource in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertRegionUrlMapRequest) (*Operation, error)
	// Retrieves the list of UrlMap resources available to the specified
	// project in the specified region.
	List(context.Context, *ListRegionUrlMapsRequest) (*UrlMapList, error)
	// Patches the specified UrlMap resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRegionUrlMapRequest) (*Operation, error)
	// Updates the specified UrlMap resource with the data included in the
	// request.
	Update(context.Context, *UpdateRegionUrlMapRequest) (*Operation, error)
	// Runs static validation for the UrlMap. In particular, the tests of the
	// provided UrlMap will be run. Calling this method does NOT create the
	// UrlMap.
	Validate(context.Context, *ValidateRegionUrlMapRequest) (*UrlMapsValidateResponse, error)
}

// UnimplementedRegionUrlMapsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionUrlMapsServer struct {
}

func (UnimplementedRegionUrlMapsServer) Delete(context.Context, *DeleteRegionUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRegionUrlMapsServer) Get(context.Context, *GetRegionUrlMapRequest) (*UrlMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionUrlMapsServer) Insert(context.Context, *InsertRegionUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRegionUrlMapsServer) List(context.Context, *ListRegionUrlMapsRequest) (*UrlMapList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRegionUrlMapsServer) Patch(context.Context, *PatchRegionUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRegionUrlMapsServer) Update(context.Context, *UpdateRegionUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedRegionUrlMapsServer) Validate(context.Context, *ValidateRegionUrlMapRequest) (*UrlMapsValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}

// UnsafeRegionUrlMapsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionUrlMapsServer will
// result in compilation errors.
type UnsafeRegionUrlMapsServer interface {
	mustEmbedUnimplementedRegionUrlMapsServer()
}

func RegisterRegionUrlMapsServer(s grpc.ServiceRegistrar, srv RegionUrlMapsServer) {
	s.RegisterService(&RegionUrlMaps_ServiceDesc, srv)
}

func _RegionUrlMaps_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRegionUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).Delete(ctx, req.(*DeleteRegionUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionUrlMaps_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).Get(ctx, req.(*GetRegionUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionUrlMaps_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRegionUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).Insert(ctx, req.(*InsertRegionUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionUrlMaps_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionUrlMapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).List(ctx, req.(*ListRegionUrlMapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionUrlMaps_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRegionUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).Patch(ctx, req.(*PatchRegionUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionUrlMaps_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRegionUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).Update(ctx, req.(*UpdateRegionUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RegionUrlMaps_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateRegionUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionUrlMapsServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionUrlMaps_Validate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionUrlMapsServer).Validate(ctx, req.(*ValidateRegionUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionUrlMaps_ServiceDesc is the grpc.ServiceDesc for RegionUrlMaps service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionUrlMaps_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionUrlMaps",
	HandlerType: (*RegionUrlMapsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _RegionUrlMaps_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _RegionUrlMaps_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _RegionUrlMaps_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _RegionUrlMaps_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _RegionUrlMaps_Patch_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _RegionUrlMaps_Update_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _RegionUrlMaps_Validate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	RegionZones_List_FullMethodName = "/google.cloud.compute.v1.RegionZones/List"
)

// RegionZonesClient is the client API for RegionZones service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionZonesClient interface {
	// Retrieves the list of Zone resources under the specific region available to
	// the specified project.
	List(ctx context.Context, in *ListRegionZonesRequest, opts ...grpc.CallOption) (*ZoneList, error)
}

type regionZonesClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionZonesClient(cc grpc.ClientConnInterface) RegionZonesClient {
	return &regionZonesClient{cc}
}

func (c *regionZonesClient) List(ctx context.Context, in *ListRegionZonesRequest, opts ...grpc.CallOption) (*ZoneList, error) {
	out := new(ZoneList)
	err := c.cc.Invoke(ctx, RegionZones_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionZonesServer is the server API for RegionZones service.
// All implementations should embed UnimplementedRegionZonesServer
// for forward compatibility
type RegionZonesServer interface {
	// Retrieves the list of Zone resources under the specific region available to
	// the specified project.
	List(context.Context, *ListRegionZonesRequest) (*ZoneList, error)
}

// UnimplementedRegionZonesServer should be embedded to have forward compatible implementations.
type UnimplementedRegionZonesServer struct {
}

func (UnimplementedRegionZonesServer) List(context.Context, *ListRegionZonesRequest) (*ZoneList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeRegionZonesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionZonesServer will
// result in compilation errors.
type UnsafeRegionZonesServer interface {
	mustEmbedUnimplementedRegionZonesServer()
}

func RegisterRegionZonesServer(s grpc.ServiceRegistrar, srv RegionZonesServer) {
	s.RegisterService(&RegionZones_ServiceDesc, srv)
}

func _RegionZones_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionZonesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionZonesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RegionZones_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionZonesServer).List(ctx, req.(*ListRegionZonesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RegionZones_ServiceDesc is the grpc.ServiceDesc for RegionZones service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RegionZones_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.RegionZones",
	HandlerType: (*RegionZonesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "List",
			Handler:    _RegionZones_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Regions_Get_FullMethodName  = "/google.cloud.compute.v1.Regions/Get"
	Regions_List_FullMethodName = "/google.cloud.compute.v1.Regions/List"
)

// RegionsClient is the client API for Regions service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RegionsClient interface {
	// Returns the specified Region resource.
	//
	// To decrease latency for this method, you can optionally omit any unneeded
	// information from the response by using a field mask. This practice is
	// especially recommended for unused quota information (the `quotas` field).
	// To exclude one or more fields, set your request's `fields` query parameter
	// to only include the fields you need. For example, to only include the `id`
	// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
	// your request.
	//
	// This method fails if the quota information is unavailable for the region
	// and if the organization policy constraint
	// compute.requireBasicQuotaInResponse is enforced. This
	// constraint, when enforced, disables the fail-open behaviour when quota
	// information (the `items.quotas` field) is unavailable for the region.
	// It is recommended to use the default setting
	// for the constraint unless your application requires the fail-closed
	// behaviour for this method.
	Get(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*Region, error)
	// Retrieves the list of region resources available to the specified project.
	//
	// To decrease latency for this method, you can optionally omit any unneeded
	// information from the response by using a field mask. This practice is
	// especially recommended for unused quota information
	// (the `items.quotas` field).
	// To exclude one or more fields, set your request's `fields` query parameter
	// to only include the fields you need. For example, to only include the `id`
	// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
	// your request.
	//
	// This method fails if the quota information is unavailable for the region
	// and if the organization policy constraint
	// compute.requireBasicQuotaInResponse is enforced. This
	// constraint, when enforced, disables the fail-open behaviour when quota
	// information (the `items.quotas` field) is unavailable for the region.
	// It is recommended to use the default setting
	// for the constraint unless your application requires the fail-closed
	// behaviour for this method.
	List(ctx context.Context, in *ListRegionsRequest, opts ...grpc.CallOption) (*RegionList, error)
}

type regionsClient struct {
	cc grpc.ClientConnInterface
}

func NewRegionsClient(cc grpc.ClientConnInterface) RegionsClient {
	return &regionsClient{cc}
}

func (c *regionsClient) Get(ctx context.Context, in *GetRegionRequest, opts ...grpc.CallOption) (*Region, error) {
	out := new(Region)
	err := c.cc.Invoke(ctx, Regions_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *regionsClient) List(ctx context.Context, in *ListRegionsRequest, opts ...grpc.CallOption) (*RegionList, error) {
	out := new(RegionList)
	err := c.cc.Invoke(ctx, Regions_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RegionsServer is the server API for Regions service.
// All implementations should embed UnimplementedRegionsServer
// for forward compatibility
type RegionsServer interface {
	// Returns the specified Region resource.
	//
	// To decrease latency for this method, you can optionally omit any unneeded
	// information from the response by using a field mask. This practice is
	// especially recommended for unused quota information (the `quotas` field).
	// To exclude one or more fields, set your request's `fields` query parameter
	// to only include the fields you need. For example, to only include the `id`
	// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
	// your request.
	//
	// This method fails if the quota information is unavailable for the region
	// and if the organization policy constraint
	// compute.requireBasicQuotaInResponse is enforced. This
	// constraint, when enforced, disables the fail-open behaviour when quota
	// information (the `items.quotas` field) is unavailable for the region.
	// It is recommended to use the default setting
	// for the constraint unless your application requires the fail-closed
	// behaviour for this method.
	Get(context.Context, *GetRegionRequest) (*Region, error)
	// Retrieves the list of region resources available to the specified project.
	//
	// To decrease latency for this method, you can optionally omit any unneeded
	// information from the response by using a field mask. This practice is
	// especially recommended for unused quota information
	// (the `items.quotas` field).
	// To exclude one or more fields, set your request's `fields` query parameter
	// to only include the fields you need. For example, to only include the `id`
	// and `selfLink` fields, add the query parameter `?fields=id,selfLink` to
	// your request.
	//
	// This method fails if the quota information is unavailable for the region
	// and if the organization policy constraint
	// compute.requireBasicQuotaInResponse is enforced. This
	// constraint, when enforced, disables the fail-open behaviour when quota
	// information (the `items.quotas` field) is unavailable for the region.
	// It is recommended to use the default setting
	// for the constraint unless your application requires the fail-closed
	// behaviour for this method.
	List(context.Context, *ListRegionsRequest) (*RegionList, error)
}

// UnimplementedRegionsServer should be embedded to have forward compatible implementations.
type UnimplementedRegionsServer struct {
}

func (UnimplementedRegionsServer) Get(context.Context, *GetRegionRequest) (*Region, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRegionsServer) List(context.Context, *ListRegionsRequest) (*RegionList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeRegionsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RegionsServer will
// result in compilation errors.
type UnsafeRegionsServer interface {
	mustEmbedUnimplementedRegionsServer()
}

func RegisterRegionsServer(s grpc.ServiceRegistrar, srv RegionsServer) {
	s.RegisterService(&Regions_ServiceDesc, srv)
}

func _Regions_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRegionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Regions_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionsServer).Get(ctx, req.(*GetRegionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Regions_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRegionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RegionsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Regions_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RegionsServer).List(ctx, req.(*ListRegionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Regions_ServiceDesc is the grpc.ServiceDesc for Regions service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Regions_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Regions",
	HandlerType: (*RegionsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Regions_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Regions_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ReservationBlocks_Get_FullMethodName                = "/google.cloud.compute.v1.ReservationBlocks/Get"
	ReservationBlocks_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ReservationBlocks/GetIamPolicy"
	ReservationBlocks_List_FullMethodName               = "/google.cloud.compute.v1.ReservationBlocks/List"
	ReservationBlocks_PerformMaintenance_FullMethodName = "/google.cloud.compute.v1.ReservationBlocks/PerformMaintenance"
	ReservationBlocks_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ReservationBlocks/SetIamPolicy"
	ReservationBlocks_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.ReservationBlocks/TestIamPermissions"
)

// ReservationBlocksClient is the client API for ReservationBlocks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationBlocksClient interface {
	// Retrieves information about the specified reservation block.
	Get(ctx context.Context, in *GetReservationBlockRequest, opts ...grpc.CallOption) (*ReservationBlocksGetResponse, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyReservationBlockRequest, opts ...grpc.CallOption) (*Policy, error)
	// Retrieves a list of reservation blocks under a single reservation.
	List(ctx context.Context, in *ListReservationBlocksRequest, opts ...grpc.CallOption) (*ReservationBlocksListResponse, error)
	// Allows customers to perform maintenance on a reservation block
	PerformMaintenance(ctx context.Context, in *PerformMaintenanceReservationBlockRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyReservationBlockRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsReservationBlockRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type reservationBlocksClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationBlocksClient(cc grpc.ClientConnInterface) ReservationBlocksClient {
	return &reservationBlocksClient{cc}
}

func (c *reservationBlocksClient) Get(ctx context.Context, in *GetReservationBlockRequest, opts ...grpc.CallOption) (*ReservationBlocksGetResponse, error) {
	out := new(ReservationBlocksGetResponse)
	err := c.cc.Invoke(ctx, ReservationBlocks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationBlocksClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyReservationBlockRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ReservationBlocks_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationBlocksClient) List(ctx context.Context, in *ListReservationBlocksRequest, opts ...grpc.CallOption) (*ReservationBlocksListResponse, error) {
	out := new(ReservationBlocksListResponse)
	err := c.cc.Invoke(ctx, ReservationBlocks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationBlocksClient) PerformMaintenance(ctx context.Context, in *PerformMaintenanceReservationBlockRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ReservationBlocks_PerformMaintenance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationBlocksClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyReservationBlockRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ReservationBlocks_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationBlocksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsReservationBlockRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, ReservationBlocks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationBlocksServer is the server API for ReservationBlocks service.
// All implementations should embed UnimplementedReservationBlocksServer
// for forward compatibility
type ReservationBlocksServer interface {
	// Retrieves information about the specified reservation block.
	Get(context.Context, *GetReservationBlockRequest) (*ReservationBlocksGetResponse, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyReservationBlockRequest) (*Policy, error)
	// Retrieves a list of reservation blocks under a single reservation.
	List(context.Context, *ListReservationBlocksRequest) (*ReservationBlocksListResponse, error)
	// Allows customers to perform maintenance on a reservation block
	PerformMaintenance(context.Context, *PerformMaintenanceReservationBlockRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyReservationBlockRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsReservationBlockRequest) (*TestPermissionsResponse, error)
}

// UnimplementedReservationBlocksServer should be embedded to have forward compatible implementations.
type UnimplementedReservationBlocksServer struct {
}

func (UnimplementedReservationBlocksServer) Get(context.Context, *GetReservationBlockRequest) (*ReservationBlocksGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedReservationBlocksServer) GetIamPolicy(context.Context, *GetIamPolicyReservationBlockRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedReservationBlocksServer) List(context.Context, *ListReservationBlocksRequest) (*ReservationBlocksListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedReservationBlocksServer) PerformMaintenance(context.Context, *PerformMaintenanceReservationBlockRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerformMaintenance not implemented")
}
func (UnimplementedReservationBlocksServer) SetIamPolicy(context.Context, *SetIamPolicyReservationBlockRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedReservationBlocksServer) TestIamPermissions(context.Context, *TestIamPermissionsReservationBlockRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeReservationBlocksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationBlocksServer will
// result in compilation errors.
type UnsafeReservationBlocksServer interface {
	mustEmbedUnimplementedReservationBlocksServer()
}

func RegisterReservationBlocksServer(s grpc.ServiceRegistrar, srv ReservationBlocksServer) {
	s.RegisterService(&ReservationBlocks_ServiceDesc, srv)
}

func _ReservationBlocks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationBlocksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationBlocks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationBlocksServer).Get(ctx, req.(*GetReservationBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationBlocks_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyReservationBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationBlocksServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationBlocks_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationBlocksServer).GetIamPolicy(ctx, req.(*GetIamPolicyReservationBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationBlocks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReservationBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationBlocksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationBlocks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationBlocksServer).List(ctx, req.(*ListReservationBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationBlocks_PerformMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PerformMaintenanceReservationBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationBlocksServer).PerformMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationBlocks_PerformMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationBlocksServer).PerformMaintenance(ctx, req.(*PerformMaintenanceReservationBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationBlocks_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyReservationBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationBlocksServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationBlocks_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationBlocksServer).SetIamPolicy(ctx, req.(*SetIamPolicyReservationBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationBlocks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsReservationBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationBlocksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationBlocks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationBlocksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsReservationBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationBlocks_ServiceDesc is the grpc.ServiceDesc for ReservationBlocks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationBlocks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ReservationBlocks",
	HandlerType: (*ReservationBlocksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ReservationBlocks_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _ReservationBlocks_GetIamPolicy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ReservationBlocks_List_Handler,
		},
		{
			MethodName: "PerformMaintenance",
			Handler:    _ReservationBlocks_PerformMaintenance_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _ReservationBlocks_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _ReservationBlocks_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ReservationSubBlocks_Get_FullMethodName                = "/google.cloud.compute.v1.ReservationSubBlocks/Get"
	ReservationSubBlocks_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ReservationSubBlocks/GetIamPolicy"
	ReservationSubBlocks_List_FullMethodName               = "/google.cloud.compute.v1.ReservationSubBlocks/List"
	ReservationSubBlocks_PerformMaintenance_FullMethodName = "/google.cloud.compute.v1.ReservationSubBlocks/PerformMaintenance"
	ReservationSubBlocks_ReportFaulty_FullMethodName       = "/google.cloud.compute.v1.ReservationSubBlocks/ReportFaulty"
	ReservationSubBlocks_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ReservationSubBlocks/SetIamPolicy"
	ReservationSubBlocks_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.ReservationSubBlocks/TestIamPermissions"
)

// ReservationSubBlocksClient is the client API for ReservationSubBlocks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationSubBlocksClient interface {
	// Retrieves information about the specified reservation subBlock.
	Get(ctx context.Context, in *GetReservationSubBlockRequest, opts ...grpc.CallOption) (*ReservationSubBlocksGetResponse, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyReservationSubBlockRequest, opts ...grpc.CallOption) (*Policy, error)
	// Retrieves a list of reservation subBlocks under a single reservation.
	List(ctx context.Context, in *ListReservationSubBlocksRequest, opts ...grpc.CallOption) (*ReservationSubBlocksListResponse, error)
	// Allows customers to perform maintenance on a reservation subBlock
	PerformMaintenance(ctx context.Context, in *PerformMaintenanceReservationSubBlockRequest, opts ...grpc.CallOption) (*Operation, error)
	// Allows customers to report a faulty subBlock.
	ReportFaulty(ctx context.Context, in *ReportFaultyReservationSubBlockRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyReservationSubBlockRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsReservationSubBlockRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type reservationSubBlocksClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationSubBlocksClient(cc grpc.ClientConnInterface) ReservationSubBlocksClient {
	return &reservationSubBlocksClient{cc}
}

func (c *reservationSubBlocksClient) Get(ctx context.Context, in *GetReservationSubBlockRequest, opts ...grpc.CallOption) (*ReservationSubBlocksGetResponse, error) {
	out := new(ReservationSubBlocksGetResponse)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSubBlocksClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyReservationSubBlockRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSubBlocksClient) List(ctx context.Context, in *ListReservationSubBlocksRequest, opts ...grpc.CallOption) (*ReservationSubBlocksListResponse, error) {
	out := new(ReservationSubBlocksListResponse)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSubBlocksClient) PerformMaintenance(ctx context.Context, in *PerformMaintenanceReservationSubBlockRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_PerformMaintenance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSubBlocksClient) ReportFaulty(ctx context.Context, in *ReportFaultyReservationSubBlockRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_ReportFaulty_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSubBlocksClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyReservationSubBlockRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationSubBlocksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsReservationSubBlockRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, ReservationSubBlocks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationSubBlocksServer is the server API for ReservationSubBlocks service.
// All implementations should embed UnimplementedReservationSubBlocksServer
// for forward compatibility
type ReservationSubBlocksServer interface {
	// Retrieves information about the specified reservation subBlock.
	Get(context.Context, *GetReservationSubBlockRequest) (*ReservationSubBlocksGetResponse, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyReservationSubBlockRequest) (*Policy, error)
	// Retrieves a list of reservation subBlocks under a single reservation.
	List(context.Context, *ListReservationSubBlocksRequest) (*ReservationSubBlocksListResponse, error)
	// Allows customers to perform maintenance on a reservation subBlock
	PerformMaintenance(context.Context, *PerformMaintenanceReservationSubBlockRequest) (*Operation, error)
	// Allows customers to report a faulty subBlock.
	ReportFaulty(context.Context, *ReportFaultyReservationSubBlockRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyReservationSubBlockRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsReservationSubBlockRequest) (*TestPermissionsResponse, error)
}

// UnimplementedReservationSubBlocksServer should be embedded to have forward compatible implementations.
type UnimplementedReservationSubBlocksServer struct {
}

func (UnimplementedReservationSubBlocksServer) Get(context.Context, *GetReservationSubBlockRequest) (*ReservationSubBlocksGetResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedReservationSubBlocksServer) GetIamPolicy(context.Context, *GetIamPolicyReservationSubBlockRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedReservationSubBlocksServer) List(context.Context, *ListReservationSubBlocksRequest) (*ReservationSubBlocksListResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedReservationSubBlocksServer) PerformMaintenance(context.Context, *PerformMaintenanceReservationSubBlockRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerformMaintenance not implemented")
}
func (UnimplementedReservationSubBlocksServer) ReportFaulty(context.Context, *ReportFaultyReservationSubBlockRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReportFaulty not implemented")
}
func (UnimplementedReservationSubBlocksServer) SetIamPolicy(context.Context, *SetIamPolicyReservationSubBlockRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedReservationSubBlocksServer) TestIamPermissions(context.Context, *TestIamPermissionsReservationSubBlockRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeReservationSubBlocksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationSubBlocksServer will
// result in compilation errors.
type UnsafeReservationSubBlocksServer interface {
	mustEmbedUnimplementedReservationSubBlocksServer()
}

func RegisterReservationSubBlocksServer(s grpc.ServiceRegistrar, srv ReservationSubBlocksServer) {
	s.RegisterService(&ReservationSubBlocks_ServiceDesc, srv)
}

func _ReservationSubBlocks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationSubBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).Get(ctx, req.(*GetReservationSubBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSubBlocks_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyReservationSubBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).GetIamPolicy(ctx, req.(*GetIamPolicyReservationSubBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSubBlocks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReservationSubBlocksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).List(ctx, req.(*ListReservationSubBlocksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSubBlocks_PerformMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PerformMaintenanceReservationSubBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).PerformMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_PerformMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).PerformMaintenance(ctx, req.(*PerformMaintenanceReservationSubBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSubBlocks_ReportFaulty_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReportFaultyReservationSubBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).ReportFaulty(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_ReportFaulty_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).ReportFaulty(ctx, req.(*ReportFaultyReservationSubBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSubBlocks_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyReservationSubBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).SetIamPolicy(ctx, req.(*SetIamPolicyReservationSubBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReservationSubBlocks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsReservationSubBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationSubBlocksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReservationSubBlocks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationSubBlocksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsReservationSubBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ReservationSubBlocks_ServiceDesc is the grpc.ServiceDesc for ReservationSubBlocks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReservationSubBlocks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ReservationSubBlocks",
	HandlerType: (*ReservationSubBlocksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _ReservationSubBlocks_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _ReservationSubBlocks_GetIamPolicy_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ReservationSubBlocks_List_Handler,
		},
		{
			MethodName: "PerformMaintenance",
			Handler:    _ReservationSubBlocks_PerformMaintenance_Handler,
		},
		{
			MethodName: "ReportFaulty",
			Handler:    _ReservationSubBlocks_ReportFaulty_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _ReservationSubBlocks_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _ReservationSubBlocks_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Reservations_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.Reservations/AggregatedList"
	Reservations_Delete_FullMethodName             = "/google.cloud.compute.v1.Reservations/Delete"
	Reservations_Get_FullMethodName                = "/google.cloud.compute.v1.Reservations/Get"
	Reservations_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Reservations/GetIamPolicy"
	Reservations_Insert_FullMethodName             = "/google.cloud.compute.v1.Reservations/Insert"
	Reservations_List_FullMethodName               = "/google.cloud.compute.v1.Reservations/List"
	Reservations_PerformMaintenance_FullMethodName = "/google.cloud.compute.v1.Reservations/PerformMaintenance"
	Reservations_Resize_FullMethodName             = "/google.cloud.compute.v1.Reservations/Resize"
	Reservations_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Reservations/SetIamPolicy"
	Reservations_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Reservations/TestIamPermissions"
	Reservations_Update_FullMethodName             = "/google.cloud.compute.v1.Reservations/Update"
)

// ReservationsClient is the client API for Reservations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReservationsClient interface {
	// Retrieves an aggregated list of reservations.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListReservationsRequest, opts ...grpc.CallOption) (*ReservationAggregatedList, error)
	// Deletes the specified reservation.
	Delete(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves information about the specified reservation.
	Get(ctx context.Context, in *GetReservationRequest, opts ...grpc.CallOption) (*Reservation, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyReservationRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a new reservation. For more information, readReserving zonal
	// resources.
	Insert(ctx context.Context, in *InsertReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// A list of all the reservations that have been configured for the
	// specified project in specified zone.
	List(ctx context.Context, in *ListReservationsRequest, opts ...grpc.CallOption) (*ReservationList, error)
	// Perform maintenance on an extended reservation
	PerformMaintenance(ctx context.Context, in *PerformMaintenanceReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Resizes the reservation (applicable to standalone reservations only). For
	// more information, readModifying
	// reservations.
	Resize(ctx context.Context, in *ResizeReservationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyReservationRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsReservationRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Update share settings of the reservation.
	Update(ctx context.Context, in *UpdateReservationRequest, opts ...grpc.CallOption) (*Operation, error)
}

type reservationsClient struct {
	cc grpc.ClientConnInterface
}

func NewReservationsClient(cc grpc.ClientConnInterface) ReservationsClient {
	return &reservationsClient{cc}
}

func (c *reservationsClient) AggregatedList(ctx context.Context, in *AggregatedListReservationsRequest, opts ...grpc.CallOption) (*ReservationAggregatedList, error) {
	out := new(ReservationAggregatedList)
	err := c.cc.Invoke(ctx, Reservations_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) Delete(ctx context.Context, in *DeleteReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Reservations_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) Get(ctx context.Context, in *GetReservationRequest, opts ...grpc.CallOption) (*Reservation, error) {
	out := new(Reservation)
	err := c.cc.Invoke(ctx, Reservations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyReservationRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Reservations_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) Insert(ctx context.Context, in *InsertReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Reservations_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) List(ctx context.Context, in *ListReservationsRequest, opts ...grpc.CallOption) (*ReservationList, error) {
	out := new(ReservationList)
	err := c.cc.Invoke(ctx, Reservations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) PerformMaintenance(ctx context.Context, in *PerformMaintenanceReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Reservations_PerformMaintenance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) Resize(ctx context.Context, in *ResizeReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Reservations_Resize_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyReservationRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Reservations_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsReservationRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Reservations_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *reservationsClient) Update(ctx context.Context, in *UpdateReservationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Reservations_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ReservationsServer is the server API for Reservations service.
// All implementations should embed UnimplementedReservationsServer
// for forward compatibility
type ReservationsServer interface {
	// Retrieves an aggregated list of reservations.
	//
	// To prevent failure, it is recommended that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListReservationsRequest) (*ReservationAggregatedList, error)
	// Deletes the specified reservation.
	Delete(context.Context, *DeleteReservationRequest) (*Operation, error)
	// Retrieves information about the specified reservation.
	Get(context.Context, *GetReservationRequest) (*Reservation, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyReservationRequest) (*Policy, error)
	// Creates a new reservation. For more information, readReserving zonal
	// resources.
	Insert(context.Context, *InsertReservationRequest) (*Operation, error)
	// A list of all the reservations that have been configured for the
	// specified project in specified zone.
	List(context.Context, *ListReservationsRequest) (*ReservationList, error)
	// Perform maintenance on an extended reservation
	PerformMaintenance(context.Context, *PerformMaintenanceReservationRequest) (*Operation, error)
	// Resizes the reservation (applicable to standalone reservations only). For
	// more information, readModifying
	// reservations.
	Resize(context.Context, *ResizeReservationRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyReservationRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsReservationRequest) (*TestPermissionsResponse, error)
	// Update share settings of the reservation.
	Update(context.Context, *UpdateReservationRequest) (*Operation, error)
}

// UnimplementedReservationsServer should be embedded to have forward compatible implementations.
type UnimplementedReservationsServer struct {
}

func (UnimplementedReservationsServer) AggregatedList(context.Context, *AggregatedListReservationsRequest) (*ReservationAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedReservationsServer) Delete(context.Context, *DeleteReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedReservationsServer) Get(context.Context, *GetReservationRequest) (*Reservation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedReservationsServer) GetIamPolicy(context.Context, *GetIamPolicyReservationRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedReservationsServer) Insert(context.Context, *InsertReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedReservationsServer) List(context.Context, *ListReservationsRequest) (*ReservationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedReservationsServer) PerformMaintenance(context.Context, *PerformMaintenanceReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PerformMaintenance not implemented")
}
func (UnimplementedReservationsServer) Resize(context.Context, *ResizeReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Resize not implemented")
}
func (UnimplementedReservationsServer) SetIamPolicy(context.Context, *SetIamPolicyReservationRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedReservationsServer) TestIamPermissions(context.Context, *TestIamPermissionsReservationRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedReservationsServer) Update(context.Context, *UpdateReservationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeReservationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReservationsServer will
// result in compilation errors.
type UnsafeReservationsServer interface {
	mustEmbedUnimplementedReservationsServer()
}

func RegisterReservationsServer(s grpc.ServiceRegistrar, srv ReservationsServer) {
	s.RegisterService(&Reservations_ServiceDesc, srv)
}

func _Reservations_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).AggregatedList(ctx, req.(*AggregatedListReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).Delete(ctx, req.(*DeleteReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).Get(ctx, req.(*GetReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).GetIamPolicy(ctx, req.(*GetIamPolicyReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).Insert(ctx, req.(*InsertReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReservationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).List(ctx, req.(*ListReservationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_PerformMaintenance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PerformMaintenanceReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).PerformMaintenance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_PerformMaintenance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).PerformMaintenance(ctx, req.(*PerformMaintenanceReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_Resize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResizeReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).Resize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_Resize_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).Resize(ctx, req.(*ResizeReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).SetIamPolicy(ctx, req.(*SetIamPolicyReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Reservations_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateReservationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReservationsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Reservations_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReservationsServer).Update(ctx, req.(*UpdateReservationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Reservations_ServiceDesc is the grpc.ServiceDesc for Reservations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Reservations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Reservations",
	HandlerType: (*ReservationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _Reservations_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Reservations_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Reservations_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Reservations_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Reservations_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Reservations_List_Handler,
		},
		{
			MethodName: "PerformMaintenance",
			Handler:    _Reservations_PerformMaintenance_Handler,
		},
		{
			MethodName: "Resize",
			Handler:    _Reservations_Resize_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Reservations_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Reservations_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Reservations_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ResourcePolicies_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.ResourcePolicies/AggregatedList"
	ResourcePolicies_Delete_FullMethodName             = "/google.cloud.compute.v1.ResourcePolicies/Delete"
	ResourcePolicies_Get_FullMethodName                = "/google.cloud.compute.v1.ResourcePolicies/Get"
	ResourcePolicies_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ResourcePolicies/GetIamPolicy"
	ResourcePolicies_Insert_FullMethodName             = "/google.cloud.compute.v1.ResourcePolicies/Insert"
	ResourcePolicies_List_FullMethodName               = "/google.cloud.compute.v1.ResourcePolicies/List"
	ResourcePolicies_Patch_FullMethodName              = "/google.cloud.compute.v1.ResourcePolicies/Patch"
	ResourcePolicies_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ResourcePolicies/SetIamPolicy"
	ResourcePolicies_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.ResourcePolicies/TestIamPermissions"
)

// ResourcePoliciesClient is the client API for ResourcePolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ResourcePoliciesClient interface {
	// Retrieves an aggregated list of resource policies.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListResourcePoliciesRequest, opts ...grpc.CallOption) (*ResourcePolicyAggregatedList, error)
	// Deletes the specified resource policy.
	Delete(ctx context.Context, in *DeleteResourcePolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves all information of the specified resource policy.
	Get(ctx context.Context, in *GetResourcePolicyRequest, opts ...grpc.CallOption) (*ResourcePolicy, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyResourcePolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a new resource policy.
	Insert(ctx context.Context, in *InsertResourcePolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// A list all the resource policies that have been configured for the
	// specified project in specified region.
	List(ctx context.Context, in *ListResourcePoliciesRequest, opts ...grpc.CallOption) (*ResourcePolicyList, error)
	// Modify the specified resource policy.
	Patch(ctx context.Context, in *PatchResourcePolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyResourcePolicyRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsResourcePolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type resourcePoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewResourcePoliciesClient(cc grpc.ClientConnInterface) ResourcePoliciesClient {
	return &resourcePoliciesClient{cc}
}

func (c *resourcePoliciesClient) AggregatedList(ctx context.Context, in *AggregatedListResourcePoliciesRequest, opts ...grpc.CallOption) (*ResourcePolicyAggregatedList, error) {
	out := new(ResourcePolicyAggregatedList)
	err := c.cc.Invoke(ctx, ResourcePolicies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) Delete(ctx context.Context, in *DeleteResourcePolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ResourcePolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) Get(ctx context.Context, in *GetResourcePolicyRequest, opts ...grpc.CallOption) (*ResourcePolicy, error) {
	out := new(ResourcePolicy)
	err := c.cc.Invoke(ctx, ResourcePolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyResourcePolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ResourcePolicies_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) Insert(ctx context.Context, in *InsertResourcePolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ResourcePolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) List(ctx context.Context, in *ListResourcePoliciesRequest, opts ...grpc.CallOption) (*ResourcePolicyList, error) {
	out := new(ResourcePolicyList)
	err := c.cc.Invoke(ctx, ResourcePolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) Patch(ctx context.Context, in *PatchResourcePolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ResourcePolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyResourcePolicyRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ResourcePolicies_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *resourcePoliciesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsResourcePolicyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, ResourcePolicies_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ResourcePoliciesServer is the server API for ResourcePolicies service.
// All implementations should embed UnimplementedResourcePoliciesServer
// for forward compatibility
type ResourcePoliciesServer interface {
	// Retrieves an aggregated list of resource policies.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListResourcePoliciesRequest) (*ResourcePolicyAggregatedList, error)
	// Deletes the specified resource policy.
	Delete(context.Context, *DeleteResourcePolicyRequest) (*Operation, error)
	// Retrieves all information of the specified resource policy.
	Get(context.Context, *GetResourcePolicyRequest) (*ResourcePolicy, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyResourcePolicyRequest) (*Policy, error)
	// Creates a new resource policy.
	Insert(context.Context, *InsertResourcePolicyRequest) (*Operation, error)
	// A list all the resource policies that have been configured for the
	// specified project in specified region.
	List(context.Context, *ListResourcePoliciesRequest) (*ResourcePolicyList, error)
	// Modify the specified resource policy.
	Patch(context.Context, *PatchResourcePolicyRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyResourcePolicyRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsResourcePolicyRequest) (*TestPermissionsResponse, error)
}

// UnimplementedResourcePoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedResourcePoliciesServer struct {
}

func (UnimplementedResourcePoliciesServer) AggregatedList(context.Context, *AggregatedListResourcePoliciesRequest) (*ResourcePolicyAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedResourcePoliciesServer) Delete(context.Context, *DeleteResourcePolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedResourcePoliciesServer) Get(context.Context, *GetResourcePolicyRequest) (*ResourcePolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedResourcePoliciesServer) GetIamPolicy(context.Context, *GetIamPolicyResourcePolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedResourcePoliciesServer) Insert(context.Context, *InsertResourcePolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedResourcePoliciesServer) List(context.Context, *ListResourcePoliciesRequest) (*ResourcePolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedResourcePoliciesServer) Patch(context.Context, *PatchResourcePolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedResourcePoliciesServer) SetIamPolicy(context.Context, *SetIamPolicyResourcePolicyRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedResourcePoliciesServer) TestIamPermissions(context.Context, *TestIamPermissionsResourcePolicyRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeResourcePoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ResourcePoliciesServer will
// result in compilation errors.
type UnsafeResourcePoliciesServer interface {
	mustEmbedUnimplementedResourcePoliciesServer()
}

func RegisterResourcePoliciesServer(s grpc.ServiceRegistrar, srv ResourcePoliciesServer) {
	s.RegisterService(&ResourcePolicies_ServiceDesc, srv)
}

func _ResourcePolicies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListResourcePoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).AggregatedList(ctx, req.(*AggregatedListResourcePoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).Delete(ctx, req.(*DeleteResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).Get(ctx, req.(*GetResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).GetIamPolicy(ctx, req.(*GetIamPolicyResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).Insert(ctx, req.(*InsertResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListResourcePoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).List(ctx, req.(*ListResourcePoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).Patch(ctx, req.(*PatchResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).SetIamPolicy(ctx, req.(*SetIamPolicyResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ResourcePolicies_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsResourcePolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ResourcePoliciesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ResourcePolicies_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ResourcePoliciesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsResourcePolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ResourcePolicies_ServiceDesc is the grpc.ServiceDesc for ResourcePolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ResourcePolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ResourcePolicies",
	HandlerType: (*ResourcePoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _ResourcePolicies_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ResourcePolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ResourcePolicies_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _ResourcePolicies_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _ResourcePolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ResourcePolicies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _ResourcePolicies_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _ResourcePolicies_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _ResourcePolicies_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Routers_AggregatedList_FullMethodName    = "/google.cloud.compute.v1.Routers/AggregatedList"
	Routers_Delete_FullMethodName            = "/google.cloud.compute.v1.Routers/Delete"
	Routers_DeleteRoutePolicy_FullMethodName = "/google.cloud.compute.v1.Routers/DeleteRoutePolicy"
	Routers_Get_FullMethodName               = "/google.cloud.compute.v1.Routers/Get"
	Routers_GetNatIpInfo_FullMethodName      = "/google.cloud.compute.v1.Routers/GetNatIpInfo"
	Routers_GetNatMappingInfo_FullMethodName = "/google.cloud.compute.v1.Routers/GetNatMappingInfo"
	Routers_GetRoutePolicy_FullMethodName    = "/google.cloud.compute.v1.Routers/GetRoutePolicy"
	Routers_GetRouterStatus_FullMethodName   = "/google.cloud.compute.v1.Routers/GetRouterStatus"
	Routers_Insert_FullMethodName            = "/google.cloud.compute.v1.Routers/Insert"
	Routers_List_FullMethodName              = "/google.cloud.compute.v1.Routers/List"
	Routers_ListBgpRoutes_FullMethodName     = "/google.cloud.compute.v1.Routers/ListBgpRoutes"
	Routers_ListRoutePolicies_FullMethodName = "/google.cloud.compute.v1.Routers/ListRoutePolicies"
	Routers_Patch_FullMethodName             = "/google.cloud.compute.v1.Routers/Patch"
	Routers_PatchRoutePolicy_FullMethodName  = "/google.cloud.compute.v1.Routers/PatchRoutePolicy"
	Routers_Preview_FullMethodName           = "/google.cloud.compute.v1.Routers/Preview"
	Routers_Update_FullMethodName            = "/google.cloud.compute.v1.Routers/Update"
	Routers_UpdateRoutePolicy_FullMethodName = "/google.cloud.compute.v1.Routers/UpdateRoutePolicy"
)

// RoutersClient is the client API for Routers service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutersClient interface {
	// Retrieves an aggregated list of routers.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListRoutersRequest, opts ...grpc.CallOption) (*RouterAggregatedList, error)
	// Deletes the specified Router resource.
	Delete(ctx context.Context, in *DeleteRouterRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes Route Policy
	DeleteRoutePolicy(ctx context.Context, in *DeleteRoutePolicyRouterRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified Router resource.
	Get(ctx context.Context, in *GetRouterRequest, opts ...grpc.CallOption) (*Router, error)
	// Retrieves runtime NAT IP information.
	GetNatIpInfo(ctx context.Context, in *GetNatIpInfoRouterRequest, opts ...grpc.CallOption) (*NatIpInfoResponse, error)
	// Retrieves runtime Nat mapping information of VM endpoints.
	GetNatMappingInfo(ctx context.Context, in *GetNatMappingInfoRoutersRequest, opts ...grpc.CallOption) (*VmEndpointNatMappingsList, error)
	// Returns specified Route Policy
	GetRoutePolicy(ctx context.Context, in *GetRoutePolicyRouterRequest, opts ...grpc.CallOption) (*RoutersGetRoutePolicyResponse, error)
	// Retrieves runtime information of the specified router.
	GetRouterStatus(ctx context.Context, in *GetRouterStatusRouterRequest, opts ...grpc.CallOption) (*RouterStatusResponse, error)
	// Creates a Router resource in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertRouterRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of Router resources available to the specified project.
	List(ctx context.Context, in *ListRoutersRequest, opts ...grpc.CallOption) (*RouterList, error)
	// Retrieves a list of router bgp routes available to the specified project.
	ListBgpRoutes(ctx context.Context, in *ListBgpRoutesRoutersRequest, opts ...grpc.CallOption) (*RoutersListBgpRoutes, error)
	// Retrieves a list of router route policy subresources available to the
	// specified project.
	ListRoutePolicies(ctx context.Context, in *ListRoutePoliciesRoutersRequest, opts ...grpc.CallOption) (*RoutersListRoutePolicies, error)
	// Patches the specified Router resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchRouterRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches Route Policy
	PatchRoutePolicy(ctx context.Context, in *PatchRoutePolicyRouterRequest, opts ...grpc.CallOption) (*Operation, error)
	// Preview fields auto-generated during router create andupdate operations.
	// Calling this method does NOT create or update the router.
	Preview(ctx context.Context, in *PreviewRouterRequest, opts ...grpc.CallOption) (*RoutersPreviewResponse, error)
	// Updates the specified Router resource with the data included in the
	// request.  This method conforms toPUT semantics, which requests that the state of the
	// target resource be created or replaced with the state defined by the
	// representation enclosed in the request message payload.
	Update(ctx context.Context, in *UpdateRouterRequest, opts ...grpc.CallOption) (*Operation, error)
	// Updates or creates new Route Policy
	UpdateRoutePolicy(ctx context.Context, in *UpdateRoutePolicyRouterRequest, opts ...grpc.CallOption) (*Operation, error)
}

type routersClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutersClient(cc grpc.ClientConnInterface) RoutersClient {
	return &routersClient{cc}
}

func (c *routersClient) AggregatedList(ctx context.Context, in *AggregatedListRoutersRequest, opts ...grpc.CallOption) (*RouterAggregatedList, error) {
	out := new(RouterAggregatedList)
	err := c.cc.Invoke(ctx, Routers_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) Delete(ctx context.Context, in *DeleteRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) DeleteRoutePolicy(ctx context.Context, in *DeleteRoutePolicyRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_DeleteRoutePolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) Get(ctx context.Context, in *GetRouterRequest, opts ...grpc.CallOption) (*Router, error) {
	out := new(Router)
	err := c.cc.Invoke(ctx, Routers_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) GetNatIpInfo(ctx context.Context, in *GetNatIpInfoRouterRequest, opts ...grpc.CallOption) (*NatIpInfoResponse, error) {
	out := new(NatIpInfoResponse)
	err := c.cc.Invoke(ctx, Routers_GetNatIpInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) GetNatMappingInfo(ctx context.Context, in *GetNatMappingInfoRoutersRequest, opts ...grpc.CallOption) (*VmEndpointNatMappingsList, error) {
	out := new(VmEndpointNatMappingsList)
	err := c.cc.Invoke(ctx, Routers_GetNatMappingInfo_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) GetRoutePolicy(ctx context.Context, in *GetRoutePolicyRouterRequest, opts ...grpc.CallOption) (*RoutersGetRoutePolicyResponse, error) {
	out := new(RoutersGetRoutePolicyResponse)
	err := c.cc.Invoke(ctx, Routers_GetRoutePolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) GetRouterStatus(ctx context.Context, in *GetRouterStatusRouterRequest, opts ...grpc.CallOption) (*RouterStatusResponse, error) {
	out := new(RouterStatusResponse)
	err := c.cc.Invoke(ctx, Routers_GetRouterStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) Insert(ctx context.Context, in *InsertRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) List(ctx context.Context, in *ListRoutersRequest, opts ...grpc.CallOption) (*RouterList, error) {
	out := new(RouterList)
	err := c.cc.Invoke(ctx, Routers_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) ListBgpRoutes(ctx context.Context, in *ListBgpRoutesRoutersRequest, opts ...grpc.CallOption) (*RoutersListBgpRoutes, error) {
	out := new(RoutersListBgpRoutes)
	err := c.cc.Invoke(ctx, Routers_ListBgpRoutes_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) ListRoutePolicies(ctx context.Context, in *ListRoutePoliciesRoutersRequest, opts ...grpc.CallOption) (*RoutersListRoutePolicies, error) {
	out := new(RoutersListRoutePolicies)
	err := c.cc.Invoke(ctx, Routers_ListRoutePolicies_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) Patch(ctx context.Context, in *PatchRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) PatchRoutePolicy(ctx context.Context, in *PatchRoutePolicyRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_PatchRoutePolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) Preview(ctx context.Context, in *PreviewRouterRequest, opts ...grpc.CallOption) (*RoutersPreviewResponse, error) {
	out := new(RoutersPreviewResponse)
	err := c.cc.Invoke(ctx, Routers_Preview_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) Update(ctx context.Context, in *UpdateRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routersClient) UpdateRoutePolicy(ctx context.Context, in *UpdateRoutePolicyRouterRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routers_UpdateRoutePolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutersServer is the server API for Routers service.
// All implementations should embed UnimplementedRoutersServer
// for forward compatibility
type RoutersServer interface {
	// Retrieves an aggregated list of routers.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListRoutersRequest) (*RouterAggregatedList, error)
	// Deletes the specified Router resource.
	Delete(context.Context, *DeleteRouterRequest) (*Operation, error)
	// Deletes Route Policy
	DeleteRoutePolicy(context.Context, *DeleteRoutePolicyRouterRequest) (*Operation, error)
	// Returns the specified Router resource.
	Get(context.Context, *GetRouterRequest) (*Router, error)
	// Retrieves runtime NAT IP information.
	GetNatIpInfo(context.Context, *GetNatIpInfoRouterRequest) (*NatIpInfoResponse, error)
	// Retrieves runtime Nat mapping information of VM endpoints.
	GetNatMappingInfo(context.Context, *GetNatMappingInfoRoutersRequest) (*VmEndpointNatMappingsList, error)
	// Returns specified Route Policy
	GetRoutePolicy(context.Context, *GetRoutePolicyRouterRequest) (*RoutersGetRoutePolicyResponse, error)
	// Retrieves runtime information of the specified router.
	GetRouterStatus(context.Context, *GetRouterStatusRouterRequest) (*RouterStatusResponse, error)
	// Creates a Router resource in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertRouterRequest) (*Operation, error)
	// Retrieves a list of Router resources available to the specified project.
	List(context.Context, *ListRoutersRequest) (*RouterList, error)
	// Retrieves a list of router bgp routes available to the specified project.
	ListBgpRoutes(context.Context, *ListBgpRoutesRoutersRequest) (*RoutersListBgpRoutes, error)
	// Retrieves a list of router route policy subresources available to the
	// specified project.
	ListRoutePolicies(context.Context, *ListRoutePoliciesRoutersRequest) (*RoutersListRoutePolicies, error)
	// Patches the specified Router resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchRouterRequest) (*Operation, error)
	// Patches Route Policy
	PatchRoutePolicy(context.Context, *PatchRoutePolicyRouterRequest) (*Operation, error)
	// Preview fields auto-generated during router create andupdate operations.
	// Calling this method does NOT create or update the router.
	Preview(context.Context, *PreviewRouterRequest) (*RoutersPreviewResponse, error)
	// Updates the specified Router resource with the data included in the
	// request.  This method conforms toPUT semantics, which requests that the state of the
	// target resource be created or replaced with the state defined by the
	// representation enclosed in the request message payload.
	Update(context.Context, *UpdateRouterRequest) (*Operation, error)
	// Updates or creates new Route Policy
	UpdateRoutePolicy(context.Context, *UpdateRoutePolicyRouterRequest) (*Operation, error)
}

// UnimplementedRoutersServer should be embedded to have forward compatible implementations.
type UnimplementedRoutersServer struct {
}

func (UnimplementedRoutersServer) AggregatedList(context.Context, *AggregatedListRoutersRequest) (*RouterAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedRoutersServer) Delete(context.Context, *DeleteRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRoutersServer) DeleteRoutePolicy(context.Context, *DeleteRoutePolicyRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteRoutePolicy not implemented")
}
func (UnimplementedRoutersServer) Get(context.Context, *GetRouterRequest) (*Router, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRoutersServer) GetNatIpInfo(context.Context, *GetNatIpInfoRouterRequest) (*NatIpInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNatIpInfo not implemented")
}
func (UnimplementedRoutersServer) GetNatMappingInfo(context.Context, *GetNatMappingInfoRoutersRequest) (*VmEndpointNatMappingsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetNatMappingInfo not implemented")
}
func (UnimplementedRoutersServer) GetRoutePolicy(context.Context, *GetRoutePolicyRouterRequest) (*RoutersGetRoutePolicyResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRoutePolicy not implemented")
}
func (UnimplementedRoutersServer) GetRouterStatus(context.Context, *GetRouterStatusRouterRequest) (*RouterStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRouterStatus not implemented")
}
func (UnimplementedRoutersServer) Insert(context.Context, *InsertRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRoutersServer) List(context.Context, *ListRoutersRequest) (*RouterList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRoutersServer) ListBgpRoutes(context.Context, *ListBgpRoutesRoutersRequest) (*RoutersListBgpRoutes, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListBgpRoutes not implemented")
}
func (UnimplementedRoutersServer) ListRoutePolicies(context.Context, *ListRoutePoliciesRoutersRequest) (*RoutersListRoutePolicies, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListRoutePolicies not implemented")
}
func (UnimplementedRoutersServer) Patch(context.Context, *PatchRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedRoutersServer) PatchRoutePolicy(context.Context, *PatchRoutePolicyRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRoutePolicy not implemented")
}
func (UnimplementedRoutersServer) Preview(context.Context, *PreviewRouterRequest) (*RoutersPreviewResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Preview not implemented")
}
func (UnimplementedRoutersServer) Update(context.Context, *UpdateRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedRoutersServer) UpdateRoutePolicy(context.Context, *UpdateRoutePolicyRouterRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateRoutePolicy not implemented")
}

// UnsafeRoutersServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutersServer will
// result in compilation errors.
type UnsafeRoutersServer interface {
	mustEmbedUnimplementedRoutersServer()
}

func RegisterRoutersServer(s grpc.ServiceRegistrar, srv RoutersServer) {
	s.RegisterService(&Routers_ServiceDesc, srv)
}

func _Routers_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListRoutersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).AggregatedList(ctx, req.(*AggregatedListRoutersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).Delete(ctx, req.(*DeleteRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_DeleteRoutePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRoutePolicyRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).DeleteRoutePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_DeleteRoutePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).DeleteRoutePolicy(ctx, req.(*DeleteRoutePolicyRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).Get(ctx, req.(*GetRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_GetNatIpInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNatIpInfoRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).GetNatIpInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_GetNatIpInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).GetNatIpInfo(ctx, req.(*GetNatIpInfoRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_GetNatMappingInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetNatMappingInfoRoutersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).GetNatMappingInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_GetNatMappingInfo_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).GetNatMappingInfo(ctx, req.(*GetNatMappingInfoRoutersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_GetRoutePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRoutePolicyRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).GetRoutePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_GetRoutePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).GetRoutePolicy(ctx, req.(*GetRoutePolicyRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_GetRouterStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRouterStatusRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).GetRouterStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_GetRouterStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).GetRouterStatus(ctx, req.(*GetRouterStatusRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).Insert(ctx, req.(*InsertRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoutersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).List(ctx, req.(*ListRoutersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_ListBgpRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBgpRoutesRoutersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).ListBgpRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_ListBgpRoutes_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).ListBgpRoutes(ctx, req.(*ListBgpRoutesRoutersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_ListRoutePolicies_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoutePoliciesRoutersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).ListRoutePolicies(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_ListRoutePolicies_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).ListRoutePolicies(ctx, req.(*ListRoutePoliciesRoutersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).Patch(ctx, req.(*PatchRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_PatchRoutePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRoutePolicyRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).PatchRoutePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_PatchRoutePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).PatchRoutePolicy(ctx, req.(*PatchRoutePolicyRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_Preview_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PreviewRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).Preview(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_Preview_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).Preview(ctx, req.(*PreviewRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).Update(ctx, req.(*UpdateRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routers_UpdateRoutePolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRoutePolicyRouterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutersServer).UpdateRoutePolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routers_UpdateRoutePolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutersServer).UpdateRoutePolicy(ctx, req.(*UpdateRoutePolicyRouterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Routers_ServiceDesc is the grpc.ServiceDesc for Routers service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Routers_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Routers",
	HandlerType: (*RoutersServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _Routers_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Routers_Delete_Handler,
		},
		{
			MethodName: "DeleteRoutePolicy",
			Handler:    _Routers_DeleteRoutePolicy_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Routers_Get_Handler,
		},
		{
			MethodName: "GetNatIpInfo",
			Handler:    _Routers_GetNatIpInfo_Handler,
		},
		{
			MethodName: "GetNatMappingInfo",
			Handler:    _Routers_GetNatMappingInfo_Handler,
		},
		{
			MethodName: "GetRoutePolicy",
			Handler:    _Routers_GetRoutePolicy_Handler,
		},
		{
			MethodName: "GetRouterStatus",
			Handler:    _Routers_GetRouterStatus_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Routers_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Routers_List_Handler,
		},
		{
			MethodName: "ListBgpRoutes",
			Handler:    _Routers_ListBgpRoutes_Handler,
		},
		{
			MethodName: "ListRoutePolicies",
			Handler:    _Routers_ListRoutePolicies_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Routers_Patch_Handler,
		},
		{
			MethodName: "PatchRoutePolicy",
			Handler:    _Routers_PatchRoutePolicy_Handler,
		},
		{
			MethodName: "Preview",
			Handler:    _Routers_Preview_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _Routers_Update_Handler,
		},
		{
			MethodName: "UpdateRoutePolicy",
			Handler:    _Routers_UpdateRoutePolicy_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Routes_Delete_FullMethodName             = "/google.cloud.compute.v1.Routes/Delete"
	Routes_Get_FullMethodName                = "/google.cloud.compute.v1.Routes/Get"
	Routes_Insert_FullMethodName             = "/google.cloud.compute.v1.Routes/Insert"
	Routes_List_FullMethodName               = "/google.cloud.compute.v1.Routes/List"
	Routes_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Routes/TestIamPermissions"
)

// RoutesClient is the client API for Routes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RoutesClient interface {
	// Deletes the specified Route resource.
	Delete(ctx context.Context, in *DeleteRouteRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified Route resource.
	Get(ctx context.Context, in *GetRouteRequest, opts ...grpc.CallOption) (*Route, error)
	// Creates a Route resource in the specified project using the data included
	// in the request.
	Insert(ctx context.Context, in *InsertRouteRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of Route resources available to the specified project.
	List(ctx context.Context, in *ListRoutesRequest, opts ...grpc.CallOption) (*RouteList, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsRouteRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type routesClient struct {
	cc grpc.ClientConnInterface
}

func NewRoutesClient(cc grpc.ClientConnInterface) RoutesClient {
	return &routesClient{cc}
}

func (c *routesClient) Delete(ctx context.Context, in *DeleteRouteRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routes_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routesClient) Get(ctx context.Context, in *GetRouteRequest, opts ...grpc.CallOption) (*Route, error) {
	out := new(Route)
	err := c.cc.Invoke(ctx, Routes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routesClient) Insert(ctx context.Context, in *InsertRouteRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Routes_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routesClient) List(ctx context.Context, in *ListRoutesRequest, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := c.cc.Invoke(ctx, Routes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *routesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsRouteRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Routes_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RoutesServer is the server API for Routes service.
// All implementations should embed UnimplementedRoutesServer
// for forward compatibility
type RoutesServer interface {
	// Deletes the specified Route resource.
	Delete(context.Context, *DeleteRouteRequest) (*Operation, error)
	// Returns the specified Route resource.
	Get(context.Context, *GetRouteRequest) (*Route, error)
	// Creates a Route resource in the specified project using the data included
	// in the request.
	Insert(context.Context, *InsertRouteRequest) (*Operation, error)
	// Retrieves the list of Route resources available to the specified project.
	List(context.Context, *ListRoutesRequest) (*RouteList, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsRouteRequest) (*TestPermissionsResponse, error)
}

// UnimplementedRoutesServer should be embedded to have forward compatible implementations.
type UnimplementedRoutesServer struct {
}

func (UnimplementedRoutesServer) Delete(context.Context, *DeleteRouteRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedRoutesServer) Get(context.Context, *GetRouteRequest) (*Route, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedRoutesServer) Insert(context.Context, *InsertRouteRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedRoutesServer) List(context.Context, *ListRoutesRequest) (*RouteList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedRoutesServer) TestIamPermissions(context.Context, *TestIamPermissionsRouteRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeRoutesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RoutesServer will
// result in compilation errors.
type UnsafeRoutesServer interface {
	mustEmbedUnimplementedRoutesServer()
}

func RegisterRoutesServer(s grpc.ServiceRegistrar, srv RoutesServer) {
	s.RegisterService(&Routes_ServiceDesc, srv)
}

func _Routes_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routes_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutesServer).Delete(ctx, req.(*DeleteRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutesServer).Get(ctx, req.(*GetRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routes_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routes_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutesServer).Insert(ctx, req.(*InsertRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListRoutesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutesServer).List(ctx, req.(*ListRoutesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Routes_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RoutesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Routes_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RoutesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Routes_ServiceDesc is the grpc.ServiceDesc for Routes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Routes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Routes",
	HandlerType: (*RoutesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Routes_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Routes_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Routes_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Routes_List_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Routes_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	SecurityPolicies_AddRule_FullMethodName                         = "/google.cloud.compute.v1.SecurityPolicies/AddRule"
	SecurityPolicies_AggregatedList_FullMethodName                  = "/google.cloud.compute.v1.SecurityPolicies/AggregatedList"
	SecurityPolicies_Delete_FullMethodName                          = "/google.cloud.compute.v1.SecurityPolicies/Delete"
	SecurityPolicies_Get_FullMethodName                             = "/google.cloud.compute.v1.SecurityPolicies/Get"
	SecurityPolicies_GetRule_FullMethodName                         = "/google.cloud.compute.v1.SecurityPolicies/GetRule"
	SecurityPolicies_Insert_FullMethodName                          = "/google.cloud.compute.v1.SecurityPolicies/Insert"
	SecurityPolicies_List_FullMethodName                            = "/google.cloud.compute.v1.SecurityPolicies/List"
	SecurityPolicies_ListPreconfiguredExpressionSets_FullMethodName = "/google.cloud.compute.v1.SecurityPolicies/ListPreconfiguredExpressionSets"
	SecurityPolicies_Patch_FullMethodName                           = "/google.cloud.compute.v1.SecurityPolicies/Patch"
	SecurityPolicies_PatchRule_FullMethodName                       = "/google.cloud.compute.v1.SecurityPolicies/PatchRule"
	SecurityPolicies_RemoveRule_FullMethodName                      = "/google.cloud.compute.v1.SecurityPolicies/RemoveRule"
	SecurityPolicies_SetLabels_FullMethodName                       = "/google.cloud.compute.v1.SecurityPolicies/SetLabels"
)

// SecurityPoliciesClient is the client API for SecurityPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SecurityPoliciesClient interface {
	// Inserts a rule into a security policy.
	AddRule(ctx context.Context, in *AddRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of all SecurityPolicy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPoliciesAggregatedList, error)
	// Deletes the specified policy.
	Delete(ctx context.Context, in *DeleteSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// List all of the ordered rules present in a single specified policy.
	Get(ctx context.Context, in *GetSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicy, error)
	// Gets a rule at the specified priority.
	GetRule(ctx context.Context, in *GetRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(ctx context.Context, in *InsertSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// List all the policies that have been configured for the specified project.
	List(ctx context.Context, in *ListSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPolicyList, error)
	// Gets the current list of preconfigured Web Application Firewall (WAF)
	// expressions.
	ListPreconfiguredExpressionSets(ctx context.Context, in *ListPreconfiguredExpressionSetsSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error)
	// Patches the specified policy with the data included in the request. To
	// clear fields in the policy, leave the fields empty and specify them in the
	// updateMask. This cannot be used to be update the rules in the policy.
	// Please use the per rule methods like addRule, patchRule, and removeRule
	// instead.
	Patch(ctx context.Context, in *PatchSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Patches a rule at the specified priority. To clear fields in the rule,
	// leave the fields empty and specify them in the updateMask.
	PatchRule(ctx context.Context, in *PatchRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Deletes a rule at the specified priority.
	RemoveRule(ctx context.Context, in *RemoveRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the labels on a security policy. To learn more about labels,
	// read the Labeling Resources
	// documentation.
	SetLabels(ctx context.Context, in *SetLabelsSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type securityPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewSecurityPoliciesClient(cc grpc.ClientConnInterface) SecurityPoliciesClient {
	return &securityPoliciesClient{cc}
}

func (c *securityPoliciesClient) AddRule(ctx context.Context, in *AddRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_AddRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) AggregatedList(ctx context.Context, in *AggregatedListSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPoliciesAggregatedList, error) {
	out := new(SecurityPoliciesAggregatedList)
	err := c.cc.Invoke(ctx, SecurityPolicies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) Delete(ctx context.Context, in *DeleteSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) Get(ctx context.Context, in *GetSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicy, error) {
	out := new(SecurityPolicy)
	err := c.cc.Invoke(ctx, SecurityPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) GetRule(ctx context.Context, in *GetRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*SecurityPolicyRule, error) {
	out := new(SecurityPolicyRule)
	err := c.cc.Invoke(ctx, SecurityPolicies_GetRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) Insert(ctx context.Context, in *InsertSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) List(ctx context.Context, in *ListSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPolicyList, error) {
	out := new(SecurityPolicyList)
	err := c.cc.Invoke(ctx, SecurityPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) ListPreconfiguredExpressionSets(ctx context.Context, in *ListPreconfiguredExpressionSetsSecurityPoliciesRequest, opts ...grpc.CallOption) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error) {
	out := new(SecurityPoliciesListPreconfiguredExpressionSetsResponse)
	err := c.cc.Invoke(ctx, SecurityPolicies_ListPreconfiguredExpressionSets_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) Patch(ctx context.Context, in *PatchSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) PatchRule(ctx context.Context, in *PatchRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_PatchRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) RemoveRule(ctx context.Context, in *RemoveRuleSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_RemoveRule_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *securityPoliciesClient) SetLabels(ctx context.Context, in *SetLabelsSecurityPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SecurityPolicies_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SecurityPoliciesServer is the server API for SecurityPolicies service.
// All implementations should embed UnimplementedSecurityPoliciesServer
// for forward compatibility
type SecurityPoliciesServer interface {
	// Inserts a rule into a security policy.
	AddRule(context.Context, *AddRuleSecurityPolicyRequest) (*Operation, error)
	// Retrieves the list of all SecurityPolicy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListSecurityPoliciesRequest) (*SecurityPoliciesAggregatedList, error)
	// Deletes the specified policy.
	Delete(context.Context, *DeleteSecurityPolicyRequest) (*Operation, error)
	// List all of the ordered rules present in a single specified policy.
	Get(context.Context, *GetSecurityPolicyRequest) (*SecurityPolicy, error)
	// Gets a rule at the specified priority.
	GetRule(context.Context, *GetRuleSecurityPolicyRequest) (*SecurityPolicyRule, error)
	// Creates a new policy in the specified project using the data included in
	// the request.
	Insert(context.Context, *InsertSecurityPolicyRequest) (*Operation, error)
	// List all the policies that have been configured for the specified project.
	List(context.Context, *ListSecurityPoliciesRequest) (*SecurityPolicyList, error)
	// Gets the current list of preconfigured Web Application Firewall (WAF)
	// expressions.
	ListPreconfiguredExpressionSets(context.Context, *ListPreconfiguredExpressionSetsSecurityPoliciesRequest) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error)
	// Patches the specified policy with the data included in the request. To
	// clear fields in the policy, leave the fields empty and specify them in the
	// updateMask. This cannot be used to be update the rules in the policy.
	// Please use the per rule methods like addRule, patchRule, and removeRule
	// instead.
	Patch(context.Context, *PatchSecurityPolicyRequest) (*Operation, error)
	// Patches a rule at the specified priority. To clear fields in the rule,
	// leave the fields empty and specify them in the updateMask.
	PatchRule(context.Context, *PatchRuleSecurityPolicyRequest) (*Operation, error)
	// Deletes a rule at the specified priority.
	RemoveRule(context.Context, *RemoveRuleSecurityPolicyRequest) (*Operation, error)
	// Sets the labels on a security policy. To learn more about labels,
	// read the Labeling Resources
	// documentation.
	SetLabels(context.Context, *SetLabelsSecurityPolicyRequest) (*Operation, error)
}

// UnimplementedSecurityPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedSecurityPoliciesServer struct {
}

func (UnimplementedSecurityPoliciesServer) AddRule(context.Context, *AddRuleSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddRule not implemented")
}
func (UnimplementedSecurityPoliciesServer) AggregatedList(context.Context, *AggregatedListSecurityPoliciesRequest) (*SecurityPoliciesAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedSecurityPoliciesServer) Delete(context.Context, *DeleteSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSecurityPoliciesServer) Get(context.Context, *GetSecurityPolicyRequest) (*SecurityPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSecurityPoliciesServer) GetRule(context.Context, *GetRuleSecurityPolicyRequest) (*SecurityPolicyRule, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetRule not implemented")
}
func (UnimplementedSecurityPoliciesServer) Insert(context.Context, *InsertSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedSecurityPoliciesServer) List(context.Context, *ListSecurityPoliciesRequest) (*SecurityPolicyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSecurityPoliciesServer) ListPreconfiguredExpressionSets(context.Context, *ListPreconfiguredExpressionSetsSecurityPoliciesRequest) (*SecurityPoliciesListPreconfiguredExpressionSetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPreconfiguredExpressionSets not implemented")
}
func (UnimplementedSecurityPoliciesServer) Patch(context.Context, *PatchSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedSecurityPoliciesServer) PatchRule(context.Context, *PatchRuleSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PatchRule not implemented")
}
func (UnimplementedSecurityPoliciesServer) RemoveRule(context.Context, *RemoveRuleSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveRule not implemented")
}
func (UnimplementedSecurityPoliciesServer) SetLabels(context.Context, *SetLabelsSecurityPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}

// UnsafeSecurityPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SecurityPoliciesServer will
// result in compilation errors.
type UnsafeSecurityPoliciesServer interface {
	mustEmbedUnimplementedSecurityPoliciesServer()
}

func RegisterSecurityPoliciesServer(s grpc.ServiceRegistrar, srv SecurityPoliciesServer) {
	s.RegisterService(&SecurityPolicies_ServiceDesc, srv)
}

func _SecurityPolicies_AddRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddRuleSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).AddRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_AddRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).AddRule(ctx, req.(*AddRuleSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListSecurityPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).AggregatedList(ctx, req.(*AggregatedListSecurityPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).Delete(ctx, req.(*DeleteSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).Get(ctx, req.(*GetSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_GetRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRuleSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).GetRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_GetRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).GetRule(ctx, req.(*GetRuleSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).Insert(ctx, req.(*InsertSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSecurityPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).List(ctx, req.(*ListSecurityPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_ListPreconfiguredExpressionSets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPreconfiguredExpressionSetsSecurityPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).ListPreconfiguredExpressionSets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_ListPreconfiguredExpressionSets_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).ListPreconfiguredExpressionSets(ctx, req.(*ListPreconfiguredExpressionSetsSecurityPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).Patch(ctx, req.(*PatchSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_PatchRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchRuleSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).PatchRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_PatchRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).PatchRule(ctx, req.(*PatchRuleSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_RemoveRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveRuleSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).RemoveRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_RemoveRule_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).RemoveRule(ctx, req.(*RemoveRuleSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SecurityPolicies_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsSecurityPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SecurityPoliciesServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SecurityPolicies_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SecurityPoliciesServer).SetLabels(ctx, req.(*SetLabelsSecurityPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SecurityPolicies_ServiceDesc is the grpc.ServiceDesc for SecurityPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SecurityPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.SecurityPolicies",
	HandlerType: (*SecurityPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddRule",
			Handler:    _SecurityPolicies_AddRule_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _SecurityPolicies_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SecurityPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _SecurityPolicies_Get_Handler,
		},
		{
			MethodName: "GetRule",
			Handler:    _SecurityPolicies_GetRule_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _SecurityPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _SecurityPolicies_List_Handler,
		},
		{
			MethodName: "ListPreconfiguredExpressionSets",
			Handler:    _SecurityPolicies_ListPreconfiguredExpressionSets_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _SecurityPolicies_Patch_Handler,
		},
		{
			MethodName: "PatchRule",
			Handler:    _SecurityPolicies_PatchRule_Handler,
		},
		{
			MethodName: "RemoveRule",
			Handler:    _SecurityPolicies_RemoveRule_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _SecurityPolicies_SetLabels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ServiceAttachments_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.ServiceAttachments/AggregatedList"
	ServiceAttachments_Delete_FullMethodName             = "/google.cloud.compute.v1.ServiceAttachments/Delete"
	ServiceAttachments_Get_FullMethodName                = "/google.cloud.compute.v1.ServiceAttachments/Get"
	ServiceAttachments_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ServiceAttachments/GetIamPolicy"
	ServiceAttachments_Insert_FullMethodName             = "/google.cloud.compute.v1.ServiceAttachments/Insert"
	ServiceAttachments_List_FullMethodName               = "/google.cloud.compute.v1.ServiceAttachments/List"
	ServiceAttachments_Patch_FullMethodName              = "/google.cloud.compute.v1.ServiceAttachments/Patch"
	ServiceAttachments_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.ServiceAttachments/SetIamPolicy"
	ServiceAttachments_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.ServiceAttachments/TestIamPermissions"
)

// ServiceAttachmentsClient is the client API for ServiceAttachments service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceAttachmentsClient interface {
	// Retrieves the list of all ServiceAttachment resources,
	// regional and global, available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListServiceAttachmentsRequest, opts ...grpc.CallOption) (*ServiceAttachmentAggregatedList, error)
	// Deletes the specified ServiceAttachment in the given scope
	Delete(ctx context.Context, in *DeleteServiceAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified ServiceAttachment resource in the given scope.
	Get(ctx context.Context, in *GetServiceAttachmentRequest, opts ...grpc.CallOption) (*ServiceAttachment, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyServiceAttachmentRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a ServiceAttachment in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertServiceAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the ServiceAttachments for a project in the given scope.
	List(ctx context.Context, in *ListServiceAttachmentsRequest, opts ...grpc.CallOption) (*ServiceAttachmentList, error)
	// Patches the specified ServiceAttachment resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchServiceAttachmentRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyServiceAttachmentRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsServiceAttachmentRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type serviceAttachmentsClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceAttachmentsClient(cc grpc.ClientConnInterface) ServiceAttachmentsClient {
	return &serviceAttachmentsClient{cc}
}

func (c *serviceAttachmentsClient) AggregatedList(ctx context.Context, in *AggregatedListServiceAttachmentsRequest, opts ...grpc.CallOption) (*ServiceAttachmentAggregatedList, error) {
	out := new(ServiceAttachmentAggregatedList)
	err := c.cc.Invoke(ctx, ServiceAttachments_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) Delete(ctx context.Context, in *DeleteServiceAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ServiceAttachments_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) Get(ctx context.Context, in *GetServiceAttachmentRequest, opts ...grpc.CallOption) (*ServiceAttachment, error) {
	out := new(ServiceAttachment)
	err := c.cc.Invoke(ctx, ServiceAttachments_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyServiceAttachmentRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ServiceAttachments_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) Insert(ctx context.Context, in *InsertServiceAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ServiceAttachments_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) List(ctx context.Context, in *ListServiceAttachmentsRequest, opts ...grpc.CallOption) (*ServiceAttachmentList, error) {
	out := new(ServiceAttachmentList)
	err := c.cc.Invoke(ctx, ServiceAttachments_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) Patch(ctx context.Context, in *PatchServiceAttachmentRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ServiceAttachments_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyServiceAttachmentRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, ServiceAttachments_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceAttachmentsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsServiceAttachmentRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, ServiceAttachments_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceAttachmentsServer is the server API for ServiceAttachments service.
// All implementations should embed UnimplementedServiceAttachmentsServer
// for forward compatibility
type ServiceAttachmentsServer interface {
	// Retrieves the list of all ServiceAttachment resources,
	// regional and global, available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListServiceAttachmentsRequest) (*ServiceAttachmentAggregatedList, error)
	// Deletes the specified ServiceAttachment in the given scope
	Delete(context.Context, *DeleteServiceAttachmentRequest) (*Operation, error)
	// Returns the specified ServiceAttachment resource in the given scope.
	Get(context.Context, *GetServiceAttachmentRequest) (*ServiceAttachment, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyServiceAttachmentRequest) (*Policy, error)
	// Creates a ServiceAttachment in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertServiceAttachmentRequest) (*Operation, error)
	// Lists the ServiceAttachments for a project in the given scope.
	List(context.Context, *ListServiceAttachmentsRequest) (*ServiceAttachmentList, error)
	// Patches the specified ServiceAttachment resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchServiceAttachmentRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyServiceAttachmentRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsServiceAttachmentRequest) (*TestPermissionsResponse, error)
}

// UnimplementedServiceAttachmentsServer should be embedded to have forward compatible implementations.
type UnimplementedServiceAttachmentsServer struct {
}

func (UnimplementedServiceAttachmentsServer) AggregatedList(context.Context, *AggregatedListServiceAttachmentsRequest) (*ServiceAttachmentAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedServiceAttachmentsServer) Delete(context.Context, *DeleteServiceAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedServiceAttachmentsServer) Get(context.Context, *GetServiceAttachmentRequest) (*ServiceAttachment, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedServiceAttachmentsServer) GetIamPolicy(context.Context, *GetIamPolicyServiceAttachmentRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedServiceAttachmentsServer) Insert(context.Context, *InsertServiceAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedServiceAttachmentsServer) List(context.Context, *ListServiceAttachmentsRequest) (*ServiceAttachmentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedServiceAttachmentsServer) Patch(context.Context, *PatchServiceAttachmentRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedServiceAttachmentsServer) SetIamPolicy(context.Context, *SetIamPolicyServiceAttachmentRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedServiceAttachmentsServer) TestIamPermissions(context.Context, *TestIamPermissionsServiceAttachmentRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeServiceAttachmentsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceAttachmentsServer will
// result in compilation errors.
type UnsafeServiceAttachmentsServer interface {
	mustEmbedUnimplementedServiceAttachmentsServer()
}

func RegisterServiceAttachmentsServer(s grpc.ServiceRegistrar, srv ServiceAttachmentsServer) {
	s.RegisterService(&ServiceAttachments_ServiceDesc, srv)
}

func _ServiceAttachments_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListServiceAttachmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).AggregatedList(ctx, req.(*AggregatedListServiceAttachmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).Delete(ctx, req.(*DeleteServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).Get(ctx, req.(*GetServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).GetIamPolicy(ctx, req.(*GetIamPolicyServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).Insert(ctx, req.(*InsertServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServiceAttachmentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).List(ctx, req.(*ListServiceAttachmentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).Patch(ctx, req.(*PatchServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).SetIamPolicy(ctx, req.(*SetIamPolicyServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceAttachments_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsServiceAttachmentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceAttachmentsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceAttachments_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceAttachmentsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsServiceAttachmentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServiceAttachments_ServiceDesc is the grpc.ServiceDesc for ServiceAttachments service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceAttachments_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ServiceAttachments",
	HandlerType: (*ServiceAttachmentsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _ServiceAttachments_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _ServiceAttachments_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ServiceAttachments_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _ServiceAttachments_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _ServiceAttachments_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ServiceAttachments_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _ServiceAttachments_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _ServiceAttachments_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _ServiceAttachments_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	SnapshotSettingsService_Get_FullMethodName   = "/google.cloud.compute.v1.SnapshotSettingsService/Get"
	SnapshotSettingsService_Patch_FullMethodName = "/google.cloud.compute.v1.SnapshotSettingsService/Patch"
)

// SnapshotSettingsServiceClient is the client API for SnapshotSettingsService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SnapshotSettingsServiceClient interface {
	// Get snapshot settings.
	Get(ctx context.Context, in *GetSnapshotSettingRequest, opts ...grpc.CallOption) (*SnapshotSettings, error)
	// Patch snapshot settings.
	Patch(ctx context.Context, in *PatchSnapshotSettingRequest, opts ...grpc.CallOption) (*Operation, error)
}

type snapshotSettingsServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewSnapshotSettingsServiceClient(cc grpc.ClientConnInterface) SnapshotSettingsServiceClient {
	return &snapshotSettingsServiceClient{cc}
}

func (c *snapshotSettingsServiceClient) Get(ctx context.Context, in *GetSnapshotSettingRequest, opts ...grpc.CallOption) (*SnapshotSettings, error) {
	out := new(SnapshotSettings)
	err := c.cc.Invoke(ctx, SnapshotSettingsService_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotSettingsServiceClient) Patch(ctx context.Context, in *PatchSnapshotSettingRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SnapshotSettingsService_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SnapshotSettingsServiceServer is the server API for SnapshotSettingsService service.
// All implementations should embed UnimplementedSnapshotSettingsServiceServer
// for forward compatibility
type SnapshotSettingsServiceServer interface {
	// Get snapshot settings.
	Get(context.Context, *GetSnapshotSettingRequest) (*SnapshotSettings, error)
	// Patch snapshot settings.
	Patch(context.Context, *PatchSnapshotSettingRequest) (*Operation, error)
}

// UnimplementedSnapshotSettingsServiceServer should be embedded to have forward compatible implementations.
type UnimplementedSnapshotSettingsServiceServer struct {
}

func (UnimplementedSnapshotSettingsServiceServer) Get(context.Context, *GetSnapshotSettingRequest) (*SnapshotSettings, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSnapshotSettingsServiceServer) Patch(context.Context, *PatchSnapshotSettingRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeSnapshotSettingsServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SnapshotSettingsServiceServer will
// result in compilation errors.
type UnsafeSnapshotSettingsServiceServer interface {
	mustEmbedUnimplementedSnapshotSettingsServiceServer()
}

func RegisterSnapshotSettingsServiceServer(s grpc.ServiceRegistrar, srv SnapshotSettingsServiceServer) {
	s.RegisterService(&SnapshotSettingsService_ServiceDesc, srv)
}

func _SnapshotSettingsService_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSnapshotSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotSettingsServiceServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnapshotSettingsService_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotSettingsServiceServer).Get(ctx, req.(*GetSnapshotSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SnapshotSettingsService_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchSnapshotSettingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotSettingsServiceServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SnapshotSettingsService_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotSettingsServiceServer).Patch(ctx, req.(*PatchSnapshotSettingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SnapshotSettingsService_ServiceDesc is the grpc.ServiceDesc for SnapshotSettingsService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SnapshotSettingsService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.SnapshotSettingsService",
	HandlerType: (*SnapshotSettingsServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _SnapshotSettingsService_Get_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _SnapshotSettingsService_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Snapshots_Delete_FullMethodName             = "/google.cloud.compute.v1.Snapshots/Delete"
	Snapshots_Get_FullMethodName                = "/google.cloud.compute.v1.Snapshots/Get"
	Snapshots_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Snapshots/GetIamPolicy"
	Snapshots_Insert_FullMethodName             = "/google.cloud.compute.v1.Snapshots/Insert"
	Snapshots_List_FullMethodName               = "/google.cloud.compute.v1.Snapshots/List"
	Snapshots_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.Snapshots/SetIamPolicy"
	Snapshots_SetLabels_FullMethodName          = "/google.cloud.compute.v1.Snapshots/SetLabels"
	Snapshots_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.Snapshots/TestIamPermissions"
)

// SnapshotsClient is the client API for Snapshots service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SnapshotsClient interface {
	// Deletes the specified Snapshot resource. Keep in mind that deleting
	// a single snapshot might not necessarily delete all the data on that
	// snapshot. If any data on the snapshot that is marked for deletion is
	// needed for subsequent snapshots, the data will be moved to the next
	// corresponding snapshot.
	//
	// For more information, seeDeleting
	// snapshots.
	Delete(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified Snapshot resource.
	Get(ctx context.Context, in *GetSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicySnapshotRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a snapshot in the specified project using the data included
	// in the request. For regular snapshot creation, consider using this method
	// instead of disks.createSnapshot,
	// as this method supports more features, such as creating snapshots in a
	// project different from the source disk project.
	Insert(ctx context.Context, in *InsertSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of Snapshot resources contained within
	// the specified project.
	List(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*SnapshotList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicySnapshotRequest, opts ...grpc.CallOption) (*Policy, error)
	// Sets the labels on a snapshot. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsSnapshotRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsSnapshotRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type snapshotsClient struct {
	cc grpc.ClientConnInterface
}

func NewSnapshotsClient(cc grpc.ClientConnInterface) SnapshotsClient {
	return &snapshotsClient{cc}
}

func (c *snapshotsClient) Delete(ctx context.Context, in *DeleteSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Snapshots_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) Get(ctx context.Context, in *GetSnapshotRequest, opts ...grpc.CallOption) (*Snapshot, error) {
	out := new(Snapshot)
	err := c.cc.Invoke(ctx, Snapshots_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicySnapshotRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Snapshots_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) Insert(ctx context.Context, in *InsertSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Snapshots_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) List(ctx context.Context, in *ListSnapshotsRequest, opts ...grpc.CallOption) (*SnapshotList, error) {
	out := new(SnapshotList)
	err := c.cc.Invoke(ctx, Snapshots_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicySnapshotRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Snapshots_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) SetLabels(ctx context.Context, in *SetLabelsSnapshotRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Snapshots_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *snapshotsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsSnapshotRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Snapshots_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SnapshotsServer is the server API for Snapshots service.
// All implementations should embed UnimplementedSnapshotsServer
// for forward compatibility
type SnapshotsServer interface {
	// Deletes the specified Snapshot resource. Keep in mind that deleting
	// a single snapshot might not necessarily delete all the data on that
	// snapshot. If any data on the snapshot that is marked for deletion is
	// needed for subsequent snapshots, the data will be moved to the next
	// corresponding snapshot.
	//
	// For more information, seeDeleting
	// snapshots.
	Delete(context.Context, *DeleteSnapshotRequest) (*Operation, error)
	// Returns the specified Snapshot resource.
	Get(context.Context, *GetSnapshotRequest) (*Snapshot, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicySnapshotRequest) (*Policy, error)
	// Creates a snapshot in the specified project using the data included
	// in the request. For regular snapshot creation, consider using this method
	// instead of disks.createSnapshot,
	// as this method supports more features, such as creating snapshots in a
	// project different from the source disk project.
	Insert(context.Context, *InsertSnapshotRequest) (*Operation, error)
	// Retrieves the list of Snapshot resources contained within
	// the specified project.
	List(context.Context, *ListSnapshotsRequest) (*SnapshotList, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicySnapshotRequest) (*Policy, error)
	// Sets the labels on a snapshot. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsSnapshotRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsSnapshotRequest) (*TestPermissionsResponse, error)
}

// UnimplementedSnapshotsServer should be embedded to have forward compatible implementations.
type UnimplementedSnapshotsServer struct {
}

func (UnimplementedSnapshotsServer) Delete(context.Context, *DeleteSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSnapshotsServer) Get(context.Context, *GetSnapshotRequest) (*Snapshot, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSnapshotsServer) GetIamPolicy(context.Context, *GetIamPolicySnapshotRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedSnapshotsServer) Insert(context.Context, *InsertSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedSnapshotsServer) List(context.Context, *ListSnapshotsRequest) (*SnapshotList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSnapshotsServer) SetIamPolicy(context.Context, *SetIamPolicySnapshotRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedSnapshotsServer) SetLabels(context.Context, *SetLabelsSnapshotRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedSnapshotsServer) TestIamPermissions(context.Context, *TestIamPermissionsSnapshotRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeSnapshotsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SnapshotsServer will
// result in compilation errors.
type UnsafeSnapshotsServer interface {
	mustEmbedUnimplementedSnapshotsServer()
}

func RegisterSnapshotsServer(s grpc.ServiceRegistrar, srv SnapshotsServer) {
	s.RegisterService(&Snapshots_ServiceDesc, srv)
}

func _Snapshots_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).Delete(ctx, req.(*DeleteSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).Get(ctx, req.(*GetSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicySnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).GetIamPolicy(ctx, req.(*GetIamPolicySnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).Insert(ctx, req.(*InsertSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSnapshotsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).List(ctx, req.(*ListSnapshotsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicySnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).SetIamPolicy(ctx, req.(*SetIamPolicySnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).SetLabels(ctx, req.(*SetLabelsSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Snapshots_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsSnapshotRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SnapshotsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Snapshots_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SnapshotsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsSnapshotRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Snapshots_ServiceDesc is the grpc.ServiceDesc for Snapshots service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Snapshots_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Snapshots",
	HandlerType: (*SnapshotsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _Snapshots_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Snapshots_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Snapshots_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Snapshots_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Snapshots_List_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Snapshots_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _Snapshots_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Snapshots_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	SslCertificates_AggregatedList_FullMethodName = "/google.cloud.compute.v1.SslCertificates/AggregatedList"
	SslCertificates_Delete_FullMethodName         = "/google.cloud.compute.v1.SslCertificates/Delete"
	SslCertificates_Get_FullMethodName            = "/google.cloud.compute.v1.SslCertificates/Get"
	SslCertificates_Insert_FullMethodName         = "/google.cloud.compute.v1.SslCertificates/Insert"
	SslCertificates_List_FullMethodName           = "/google.cloud.compute.v1.SslCertificates/List"
)

// SslCertificatesClient is the client API for SslCertificates service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SslCertificatesClient interface {
	// Retrieves the list of all SslCertificate resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListSslCertificatesRequest, opts ...grpc.CallOption) (*SslCertificateAggregatedList, error)
	// Deletes the specified SslCertificate resource.
	Delete(ctx context.Context, in *DeleteSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified SslCertificate resource.
	Get(ctx context.Context, in *GetSslCertificateRequest, opts ...grpc.CallOption) (*SslCertificate, error)
	// Creates a SslCertificate resource in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of SslCertificate resources available to the specified
	// project.
	List(ctx context.Context, in *ListSslCertificatesRequest, opts ...grpc.CallOption) (*SslCertificateList, error)
}

type sslCertificatesClient struct {
	cc grpc.ClientConnInterface
}

func NewSslCertificatesClient(cc grpc.ClientConnInterface) SslCertificatesClient {
	return &sslCertificatesClient{cc}
}

func (c *sslCertificatesClient) AggregatedList(ctx context.Context, in *AggregatedListSslCertificatesRequest, opts ...grpc.CallOption) (*SslCertificateAggregatedList, error) {
	out := new(SslCertificateAggregatedList)
	err := c.cc.Invoke(ctx, SslCertificates_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslCertificatesClient) Delete(ctx context.Context, in *DeleteSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SslCertificates_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslCertificatesClient) Get(ctx context.Context, in *GetSslCertificateRequest, opts ...grpc.CallOption) (*SslCertificate, error) {
	out := new(SslCertificate)
	err := c.cc.Invoke(ctx, SslCertificates_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslCertificatesClient) Insert(ctx context.Context, in *InsertSslCertificateRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SslCertificates_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslCertificatesClient) List(ctx context.Context, in *ListSslCertificatesRequest, opts ...grpc.CallOption) (*SslCertificateList, error) {
	out := new(SslCertificateList)
	err := c.cc.Invoke(ctx, SslCertificates_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SslCertificatesServer is the server API for SslCertificates service.
// All implementations should embed UnimplementedSslCertificatesServer
// for forward compatibility
type SslCertificatesServer interface {
	// Retrieves the list of all SslCertificate resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListSslCertificatesRequest) (*SslCertificateAggregatedList, error)
	// Deletes the specified SslCertificate resource.
	Delete(context.Context, *DeleteSslCertificateRequest) (*Operation, error)
	// Returns the specified SslCertificate resource.
	Get(context.Context, *GetSslCertificateRequest) (*SslCertificate, error)
	// Creates a SslCertificate resource in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertSslCertificateRequest) (*Operation, error)
	// Retrieves the list of SslCertificate resources available to the specified
	// project.
	List(context.Context, *ListSslCertificatesRequest) (*SslCertificateList, error)
}

// UnimplementedSslCertificatesServer should be embedded to have forward compatible implementations.
type UnimplementedSslCertificatesServer struct {
}

func (UnimplementedSslCertificatesServer) AggregatedList(context.Context, *AggregatedListSslCertificatesRequest) (*SslCertificateAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedSslCertificatesServer) Delete(context.Context, *DeleteSslCertificateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSslCertificatesServer) Get(context.Context, *GetSslCertificateRequest) (*SslCertificate, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSslCertificatesServer) Insert(context.Context, *InsertSslCertificateRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedSslCertificatesServer) List(context.Context, *ListSslCertificatesRequest) (*SslCertificateList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeSslCertificatesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SslCertificatesServer will
// result in compilation errors.
type UnsafeSslCertificatesServer interface {
	mustEmbedUnimplementedSslCertificatesServer()
}

func RegisterSslCertificatesServer(s grpc.ServiceRegistrar, srv SslCertificatesServer) {
	s.RegisterService(&SslCertificates_ServiceDesc, srv)
}

func _SslCertificates_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListSslCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslCertificatesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslCertificates_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslCertificatesServer).AggregatedList(ctx, req.(*AggregatedListSslCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslCertificates_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSslCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslCertificatesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslCertificates_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslCertificatesServer).Delete(ctx, req.(*DeleteSslCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslCertificates_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSslCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslCertificatesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslCertificates_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslCertificatesServer).Get(ctx, req.(*GetSslCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslCertificates_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertSslCertificateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslCertificatesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslCertificates_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslCertificatesServer).Insert(ctx, req.(*InsertSslCertificateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslCertificates_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSslCertificatesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslCertificatesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslCertificates_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslCertificatesServer).List(ctx, req.(*ListSslCertificatesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SslCertificates_ServiceDesc is the grpc.ServiceDesc for SslCertificates service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SslCertificates_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.SslCertificates",
	HandlerType: (*SslCertificatesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _SslCertificates_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SslCertificates_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _SslCertificates_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _SslCertificates_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _SslCertificates_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	SslPolicies_AggregatedList_FullMethodName        = "/google.cloud.compute.v1.SslPolicies/AggregatedList"
	SslPolicies_Delete_FullMethodName                = "/google.cloud.compute.v1.SslPolicies/Delete"
	SslPolicies_Get_FullMethodName                   = "/google.cloud.compute.v1.SslPolicies/Get"
	SslPolicies_Insert_FullMethodName                = "/google.cloud.compute.v1.SslPolicies/Insert"
	SslPolicies_List_FullMethodName                  = "/google.cloud.compute.v1.SslPolicies/List"
	SslPolicies_ListAvailableFeatures_FullMethodName = "/google.cloud.compute.v1.SslPolicies/ListAvailableFeatures"
	SslPolicies_Patch_FullMethodName                 = "/google.cloud.compute.v1.SslPolicies/Patch"
)

// SslPoliciesClient is the client API for SslPolicies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SslPoliciesClient interface {
	// Retrieves the list of all SslPolicy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesAggregatedList, error)
	// Deletes the specified SSL policy. The SSL policy resource can be deleted
	// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
	// resources.
	Delete(ctx context.Context, in *DeleteSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all of the ordered rules present in a single specified policy.
	Get(ctx context.Context, in *GetSslPolicyRequest, opts ...grpc.CallOption) (*SslPolicy, error)
	// Returns the specified SSL policy resource.
	Insert(ctx context.Context, in *InsertSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists all the SSL policies that have been configured for the specified
	// project.
	List(ctx context.Context, in *ListSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesList, error)
	// Lists all features that can be specified in the SSL policy when using
	// custom profile.
	ListAvailableFeatures(ctx context.Context, in *ListAvailableFeaturesSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesListAvailableFeaturesResponse, error)
	// Patches the specified SSL policy with the data included in the request.
	Patch(ctx context.Context, in *PatchSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type sslPoliciesClient struct {
	cc grpc.ClientConnInterface
}

func NewSslPoliciesClient(cc grpc.ClientConnInterface) SslPoliciesClient {
	return &sslPoliciesClient{cc}
}

func (c *sslPoliciesClient) AggregatedList(ctx context.Context, in *AggregatedListSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesAggregatedList, error) {
	out := new(SslPoliciesAggregatedList)
	err := c.cc.Invoke(ctx, SslPolicies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslPoliciesClient) Delete(ctx context.Context, in *DeleteSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SslPolicies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslPoliciesClient) Get(ctx context.Context, in *GetSslPolicyRequest, opts ...grpc.CallOption) (*SslPolicy, error) {
	out := new(SslPolicy)
	err := c.cc.Invoke(ctx, SslPolicies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslPoliciesClient) Insert(ctx context.Context, in *InsertSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SslPolicies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslPoliciesClient) List(ctx context.Context, in *ListSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesList, error) {
	out := new(SslPoliciesList)
	err := c.cc.Invoke(ctx, SslPolicies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslPoliciesClient) ListAvailableFeatures(ctx context.Context, in *ListAvailableFeaturesSslPoliciesRequest, opts ...grpc.CallOption) (*SslPoliciesListAvailableFeaturesResponse, error) {
	out := new(SslPoliciesListAvailableFeaturesResponse)
	err := c.cc.Invoke(ctx, SslPolicies_ListAvailableFeatures_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sslPoliciesClient) Patch(ctx context.Context, in *PatchSslPolicyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, SslPolicies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SslPoliciesServer is the server API for SslPolicies service.
// All implementations should embed UnimplementedSslPoliciesServer
// for forward compatibility
type SslPoliciesServer interface {
	// Retrieves the list of all SslPolicy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListSslPoliciesRequest) (*SslPoliciesAggregatedList, error)
	// Deletes the specified SSL policy. The SSL policy resource can be deleted
	// only if it is not in use by any TargetHttpsProxy or TargetSslProxy
	// resources.
	Delete(context.Context, *DeleteSslPolicyRequest) (*Operation, error)
	// Lists all of the ordered rules present in a single specified policy.
	Get(context.Context, *GetSslPolicyRequest) (*SslPolicy, error)
	// Returns the specified SSL policy resource.
	Insert(context.Context, *InsertSslPolicyRequest) (*Operation, error)
	// Lists all the SSL policies that have been configured for the specified
	// project.
	List(context.Context, *ListSslPoliciesRequest) (*SslPoliciesList, error)
	// Lists all features that can be specified in the SSL policy when using
	// custom profile.
	ListAvailableFeatures(context.Context, *ListAvailableFeaturesSslPoliciesRequest) (*SslPoliciesListAvailableFeaturesResponse, error)
	// Patches the specified SSL policy with the data included in the request.
	Patch(context.Context, *PatchSslPolicyRequest) (*Operation, error)
}

// UnimplementedSslPoliciesServer should be embedded to have forward compatible implementations.
type UnimplementedSslPoliciesServer struct {
}

func (UnimplementedSslPoliciesServer) AggregatedList(context.Context, *AggregatedListSslPoliciesRequest) (*SslPoliciesAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedSslPoliciesServer) Delete(context.Context, *DeleteSslPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSslPoliciesServer) Get(context.Context, *GetSslPolicyRequest) (*SslPolicy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSslPoliciesServer) Insert(context.Context, *InsertSslPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedSslPoliciesServer) List(context.Context, *ListSslPoliciesRequest) (*SslPoliciesList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSslPoliciesServer) ListAvailableFeatures(context.Context, *ListAvailableFeaturesSslPoliciesRequest) (*SslPoliciesListAvailableFeaturesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListAvailableFeatures not implemented")
}
func (UnimplementedSslPoliciesServer) Patch(context.Context, *PatchSslPolicyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeSslPoliciesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SslPoliciesServer will
// result in compilation errors.
type UnsafeSslPoliciesServer interface {
	mustEmbedUnimplementedSslPoliciesServer()
}

func RegisterSslPoliciesServer(s grpc.ServiceRegistrar, srv SslPoliciesServer) {
	s.RegisterService(&SslPolicies_ServiceDesc, srv)
}

func _SslPolicies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListSslPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).AggregatedList(ctx, req.(*AggregatedListSslPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslPolicies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).Delete(ctx, req.(*DeleteSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslPolicies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).Get(ctx, req.(*GetSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslPolicies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).Insert(ctx, req.(*InsertSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslPolicies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSslPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).List(ctx, req.(*ListSslPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslPolicies_ListAvailableFeatures_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListAvailableFeaturesSslPoliciesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).ListAvailableFeatures(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_ListAvailableFeatures_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).ListAvailableFeatures(ctx, req.(*ListAvailableFeaturesSslPoliciesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SslPolicies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchSslPolicyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SslPoliciesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: SslPolicies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SslPoliciesServer).Patch(ctx, req.(*PatchSslPolicyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// SslPolicies_ServiceDesc is the grpc.ServiceDesc for SslPolicies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var SslPolicies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.SslPolicies",
	HandlerType: (*SslPoliciesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _SslPolicies_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _SslPolicies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _SslPolicies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _SslPolicies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _SslPolicies_List_Handler,
		},
		{
			MethodName: "ListAvailableFeatures",
			Handler:    _SslPolicies_ListAvailableFeatures_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _SslPolicies_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	StoragePoolTypes_AggregatedList_FullMethodName = "/google.cloud.compute.v1.StoragePoolTypes/AggregatedList"
	StoragePoolTypes_Get_FullMethodName            = "/google.cloud.compute.v1.StoragePoolTypes/Get"
	StoragePoolTypes_List_FullMethodName           = "/google.cloud.compute.v1.StoragePoolTypes/List"
)

// StoragePoolTypesClient is the client API for StoragePoolTypes service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StoragePoolTypesClient interface {
	// Retrieves an aggregated list of storage pool types.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListStoragePoolTypesRequest, opts ...grpc.CallOption) (*StoragePoolTypeAggregatedList, error)
	// Returns the specified storage pool type.
	Get(ctx context.Context, in *GetStoragePoolTypeRequest, opts ...grpc.CallOption) (*StoragePoolType, error)
	// Retrieves a list of storage pool types available to the specified
	// project.
	List(ctx context.Context, in *ListStoragePoolTypesRequest, opts ...grpc.CallOption) (*StoragePoolTypeList, error)
}

type storagePoolTypesClient struct {
	cc grpc.ClientConnInterface
}

func NewStoragePoolTypesClient(cc grpc.ClientConnInterface) StoragePoolTypesClient {
	return &storagePoolTypesClient{cc}
}

func (c *storagePoolTypesClient) AggregatedList(ctx context.Context, in *AggregatedListStoragePoolTypesRequest, opts ...grpc.CallOption) (*StoragePoolTypeAggregatedList, error) {
	out := new(StoragePoolTypeAggregatedList)
	err := c.cc.Invoke(ctx, StoragePoolTypes_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolTypesClient) Get(ctx context.Context, in *GetStoragePoolTypeRequest, opts ...grpc.CallOption) (*StoragePoolType, error) {
	out := new(StoragePoolType)
	err := c.cc.Invoke(ctx, StoragePoolTypes_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolTypesClient) List(ctx context.Context, in *ListStoragePoolTypesRequest, opts ...grpc.CallOption) (*StoragePoolTypeList, error) {
	out := new(StoragePoolTypeList)
	err := c.cc.Invoke(ctx, StoragePoolTypes_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoragePoolTypesServer is the server API for StoragePoolTypes service.
// All implementations should embed UnimplementedStoragePoolTypesServer
// for forward compatibility
type StoragePoolTypesServer interface {
	// Retrieves an aggregated list of storage pool types.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListStoragePoolTypesRequest) (*StoragePoolTypeAggregatedList, error)
	// Returns the specified storage pool type.
	Get(context.Context, *GetStoragePoolTypeRequest) (*StoragePoolType, error)
	// Retrieves a list of storage pool types available to the specified
	// project.
	List(context.Context, *ListStoragePoolTypesRequest) (*StoragePoolTypeList, error)
}

// UnimplementedStoragePoolTypesServer should be embedded to have forward compatible implementations.
type UnimplementedStoragePoolTypesServer struct {
}

func (UnimplementedStoragePoolTypesServer) AggregatedList(context.Context, *AggregatedListStoragePoolTypesRequest) (*StoragePoolTypeAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedStoragePoolTypesServer) Get(context.Context, *GetStoragePoolTypeRequest) (*StoragePoolType, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStoragePoolTypesServer) List(context.Context, *ListStoragePoolTypesRequest) (*StoragePoolTypeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeStoragePoolTypesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StoragePoolTypesServer will
// result in compilation errors.
type UnsafeStoragePoolTypesServer interface {
	mustEmbedUnimplementedStoragePoolTypesServer()
}

func RegisterStoragePoolTypesServer(s grpc.ServiceRegistrar, srv StoragePoolTypesServer) {
	s.RegisterService(&StoragePoolTypes_ServiceDesc, srv)
}

func _StoragePoolTypes_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListStoragePoolTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolTypesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePoolTypes_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolTypesServer).AggregatedList(ctx, req.(*AggregatedListStoragePoolTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePoolTypes_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoragePoolTypeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolTypesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePoolTypes_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolTypesServer).Get(ctx, req.(*GetStoragePoolTypeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePoolTypes_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStoragePoolTypesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolTypesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePoolTypes_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolTypesServer).List(ctx, req.(*ListStoragePoolTypesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StoragePoolTypes_ServiceDesc is the grpc.ServiceDesc for StoragePoolTypes service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StoragePoolTypes_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.StoragePoolTypes",
	HandlerType: (*StoragePoolTypesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _StoragePoolTypes_AggregatedList_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _StoragePoolTypes_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _StoragePoolTypes_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	StoragePools_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.StoragePools/AggregatedList"
	StoragePools_Delete_FullMethodName             = "/google.cloud.compute.v1.StoragePools/Delete"
	StoragePools_Get_FullMethodName                = "/google.cloud.compute.v1.StoragePools/Get"
	StoragePools_GetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.StoragePools/GetIamPolicy"
	StoragePools_Insert_FullMethodName             = "/google.cloud.compute.v1.StoragePools/Insert"
	StoragePools_List_FullMethodName               = "/google.cloud.compute.v1.StoragePools/List"
	StoragePools_ListDisks_FullMethodName          = "/google.cloud.compute.v1.StoragePools/ListDisks"
	StoragePools_SetIamPolicy_FullMethodName       = "/google.cloud.compute.v1.StoragePools/SetIamPolicy"
	StoragePools_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.StoragePools/TestIamPermissions"
	StoragePools_Update_FullMethodName             = "/google.cloud.compute.v1.StoragePools/Update"
)

// StoragePoolsClient is the client API for StoragePools service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type StoragePoolsClient interface {
	// Retrieves an aggregated list of storage pools.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListStoragePoolsRequest, opts ...grpc.CallOption) (*StoragePoolAggregatedList, error)
	// Deletes the specified storage pool. Deleting a storagePool
	// removes its data permanently and is irreversible. However, deleting a
	// storagePool does not delete any snapshots previously
	// made from the storagePool. You must separately delete
	// snapshots.
	Delete(ctx context.Context, in *DeleteStoragePoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns a specified storage pool. Gets a list of available
	// storage pools by making a list() request.
	Get(ctx context.Context, in *GetStoragePoolRequest, opts ...grpc.CallOption) (*StoragePool, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicyStoragePoolRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a storage pool in the specified project using the data
	// in the request.
	Insert(ctx context.Context, in *InsertStoragePoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of storage pools contained within
	// the specified zone.
	List(ctx context.Context, in *ListStoragePoolsRequest, opts ...grpc.CallOption) (*StoragePoolList, error)
	// Lists the disks in a specified storage pool.
	ListDisks(ctx context.Context, in *ListDisksStoragePoolsRequest, opts ...grpc.CallOption) (*StoragePoolListDisks, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicyStoragePoolRequest, opts ...grpc.CallOption) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsStoragePoolRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified storagePool with the data included in the request.
	// The update is performed only on selected fields included as part
	// of update-mask. Only the following fields can be modified:
	// pool_provisioned_capacity_gb, pool_provisioned_iops and
	// pool_provisioned_throughput.
	Update(ctx context.Context, in *UpdateStoragePoolRequest, opts ...grpc.CallOption) (*Operation, error)
}

type storagePoolsClient struct {
	cc grpc.ClientConnInterface
}

func NewStoragePoolsClient(cc grpc.ClientConnInterface) StoragePoolsClient {
	return &storagePoolsClient{cc}
}

func (c *storagePoolsClient) AggregatedList(ctx context.Context, in *AggregatedListStoragePoolsRequest, opts ...grpc.CallOption) (*StoragePoolAggregatedList, error) {
	out := new(StoragePoolAggregatedList)
	err := c.cc.Invoke(ctx, StoragePools_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) Delete(ctx context.Context, in *DeleteStoragePoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, StoragePools_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) Get(ctx context.Context, in *GetStoragePoolRequest, opts ...grpc.CallOption) (*StoragePool, error) {
	out := new(StoragePool)
	err := c.cc.Invoke(ctx, StoragePools_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) GetIamPolicy(ctx context.Context, in *GetIamPolicyStoragePoolRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, StoragePools_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) Insert(ctx context.Context, in *InsertStoragePoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, StoragePools_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) List(ctx context.Context, in *ListStoragePoolsRequest, opts ...grpc.CallOption) (*StoragePoolList, error) {
	out := new(StoragePoolList)
	err := c.cc.Invoke(ctx, StoragePools_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) ListDisks(ctx context.Context, in *ListDisksStoragePoolsRequest, opts ...grpc.CallOption) (*StoragePoolListDisks, error) {
	out := new(StoragePoolListDisks)
	err := c.cc.Invoke(ctx, StoragePools_ListDisks_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) SetIamPolicy(ctx context.Context, in *SetIamPolicyStoragePoolRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, StoragePools_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsStoragePoolRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, StoragePools_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *storagePoolsClient) Update(ctx context.Context, in *UpdateStoragePoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, StoragePools_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// StoragePoolsServer is the server API for StoragePools service.
// All implementations should embed UnimplementedStoragePoolsServer
// for forward compatibility
type StoragePoolsServer interface {
	// Retrieves an aggregated list of storage pools.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListStoragePoolsRequest) (*StoragePoolAggregatedList, error)
	// Deletes the specified storage pool. Deleting a storagePool
	// removes its data permanently and is irreversible. However, deleting a
	// storagePool does not delete any snapshots previously
	// made from the storagePool. You must separately delete
	// snapshots.
	Delete(context.Context, *DeleteStoragePoolRequest) (*Operation, error)
	// Returns a specified storage pool. Gets a list of available
	// storage pools by making a list() request.
	Get(context.Context, *GetStoragePoolRequest) (*StoragePool, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicyStoragePoolRequest) (*Policy, error)
	// Creates a storage pool in the specified project using the data
	// in the request.
	Insert(context.Context, *InsertStoragePoolRequest) (*Operation, error)
	// Retrieves a list of storage pools contained within
	// the specified zone.
	List(context.Context, *ListStoragePoolsRequest) (*StoragePoolList, error)
	// Lists the disks in a specified storage pool.
	ListDisks(context.Context, *ListDisksStoragePoolsRequest) (*StoragePoolListDisks, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicyStoragePoolRequest) (*Policy, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsStoragePoolRequest) (*TestPermissionsResponse, error)
	// Updates the specified storagePool with the data included in the request.
	// The update is performed only on selected fields included as part
	// of update-mask. Only the following fields can be modified:
	// pool_provisioned_capacity_gb, pool_provisioned_iops and
	// pool_provisioned_throughput.
	Update(context.Context, *UpdateStoragePoolRequest) (*Operation, error)
}

// UnimplementedStoragePoolsServer should be embedded to have forward compatible implementations.
type UnimplementedStoragePoolsServer struct {
}

func (UnimplementedStoragePoolsServer) AggregatedList(context.Context, *AggregatedListStoragePoolsRequest) (*StoragePoolAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedStoragePoolsServer) Delete(context.Context, *DeleteStoragePoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedStoragePoolsServer) Get(context.Context, *GetStoragePoolRequest) (*StoragePool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedStoragePoolsServer) GetIamPolicy(context.Context, *GetIamPolicyStoragePoolRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedStoragePoolsServer) Insert(context.Context, *InsertStoragePoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedStoragePoolsServer) List(context.Context, *ListStoragePoolsRequest) (*StoragePoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedStoragePoolsServer) ListDisks(context.Context, *ListDisksStoragePoolsRequest) (*StoragePoolListDisks, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDisks not implemented")
}
func (UnimplementedStoragePoolsServer) SetIamPolicy(context.Context, *SetIamPolicyStoragePoolRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedStoragePoolsServer) TestIamPermissions(context.Context, *TestIamPermissionsStoragePoolRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedStoragePoolsServer) Update(context.Context, *UpdateStoragePoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}

// UnsafeStoragePoolsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to StoragePoolsServer will
// result in compilation errors.
type UnsafeStoragePoolsServer interface {
	mustEmbedUnimplementedStoragePoolsServer()
}

func RegisterStoragePoolsServer(s grpc.ServiceRegistrar, srv StoragePoolsServer) {
	s.RegisterService(&StoragePools_ServiceDesc, srv)
}

func _StoragePools_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListStoragePoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).AggregatedList(ctx, req.(*AggregatedListStoragePoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).Delete(ctx, req.(*DeleteStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).Get(ctx, req.(*GetStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicyStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).GetIamPolicy(ctx, req.(*GetIamPolicyStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).Insert(ctx, req.(*InsertStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListStoragePoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).List(ctx, req.(*ListStoragePoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_ListDisks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDisksStoragePoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).ListDisks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_ListDisks_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).ListDisks(ctx, req.(*ListDisksStoragePoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicyStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).SetIamPolicy(ctx, req.(*SetIamPolicyStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _StoragePools_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStoragePoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(StoragePoolsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: StoragePools_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(StoragePoolsServer).Update(ctx, req.(*UpdateStoragePoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// StoragePools_ServiceDesc is the grpc.ServiceDesc for StoragePools service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var StoragePools_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.StoragePools",
	HandlerType: (*StoragePoolsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _StoragePools_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _StoragePools_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _StoragePools_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _StoragePools_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _StoragePools_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _StoragePools_List_Handler,
		},
		{
			MethodName: "ListDisks",
			Handler:    _StoragePools_ListDisks_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _StoragePools_SetIamPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _StoragePools_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _StoragePools_Update_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Subnetworks_AggregatedList_FullMethodName           = "/google.cloud.compute.v1.Subnetworks/AggregatedList"
	Subnetworks_Delete_FullMethodName                   = "/google.cloud.compute.v1.Subnetworks/Delete"
	Subnetworks_ExpandIpCidrRange_FullMethodName        = "/google.cloud.compute.v1.Subnetworks/ExpandIpCidrRange"
	Subnetworks_Get_FullMethodName                      = "/google.cloud.compute.v1.Subnetworks/Get"
	Subnetworks_GetIamPolicy_FullMethodName             = "/google.cloud.compute.v1.Subnetworks/GetIamPolicy"
	Subnetworks_Insert_FullMethodName                   = "/google.cloud.compute.v1.Subnetworks/Insert"
	Subnetworks_List_FullMethodName                     = "/google.cloud.compute.v1.Subnetworks/List"
	Subnetworks_ListUsable_FullMethodName               = "/google.cloud.compute.v1.Subnetworks/ListUsable"
	Subnetworks_Patch_FullMethodName                    = "/google.cloud.compute.v1.Subnetworks/Patch"
	Subnetworks_SetIamPolicy_FullMethodName             = "/google.cloud.compute.v1.Subnetworks/SetIamPolicy"
	Subnetworks_SetPrivateIpGoogleAccess_FullMethodName = "/google.cloud.compute.v1.Subnetworks/SetPrivateIpGoogleAccess"
	Subnetworks_TestIamPermissions_FullMethodName       = "/google.cloud.compute.v1.Subnetworks/TestIamPermissions"
)

// SubnetworksClient is the client API for Subnetworks service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type SubnetworksClient interface {
	// Retrieves an aggregated list of subnetworks.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListSubnetworksRequest, opts ...grpc.CallOption) (*SubnetworkAggregatedList, error)
	// Deletes the specified subnetwork.
	Delete(ctx context.Context, in *DeleteSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Expands the IP CIDR range of the subnetwork to a specified value.
	ExpandIpCidrRange(ctx context.Context, in *ExpandIpCidrRangeSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified subnetwork.
	Get(ctx context.Context, in *GetSubnetworkRequest, opts ...grpc.CallOption) (*Subnetwork, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(ctx context.Context, in *GetIamPolicySubnetworkRequest, opts ...grpc.CallOption) (*Policy, error)
	// Creates a subnetwork in the specified project using the data
	// included in the request.
	Insert(ctx context.Context, in *InsertSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of subnetworks available to the specified
	// project.
	List(ctx context.Context, in *ListSubnetworksRequest, opts ...grpc.CallOption) (*SubnetworkList, error)
	// Retrieves an aggregated list of all usable subnetworks in the project.
	ListUsable(ctx context.Context, in *ListUsableSubnetworksRequest, opts ...grpc.CallOption) (*UsableSubnetworksAggregatedList, error)
	// Patches the specified subnetwork with the data included in the request.
	// Only certain fields can be updated with a patch request
	// as indicated in the field descriptions.
	// You must specify the current fingerprint of the
	// subnetwork resource being patched.
	Patch(ctx context.Context, in *PatchSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(ctx context.Context, in *SetIamPolicySubnetworkRequest, opts ...grpc.CallOption) (*Policy, error)
	// Set whether VMs in this subnet can access Google services without assigning
	// external IP addresses through Private Google Access.
	SetPrivateIpGoogleAccess(ctx context.Context, in *SetPrivateIpGoogleAccessSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsSubnetworkRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type subnetworksClient struct {
	cc grpc.ClientConnInterface
}

func NewSubnetworksClient(cc grpc.ClientConnInterface) SubnetworksClient {
	return &subnetworksClient{cc}
}

func (c *subnetworksClient) AggregatedList(ctx context.Context, in *AggregatedListSubnetworksRequest, opts ...grpc.CallOption) (*SubnetworkAggregatedList, error) {
	out := new(SubnetworkAggregatedList)
	err := c.cc.Invoke(ctx, Subnetworks_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) Delete(ctx context.Context, in *DeleteSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Subnetworks_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) ExpandIpCidrRange(ctx context.Context, in *ExpandIpCidrRangeSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Subnetworks_ExpandIpCidrRange_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) Get(ctx context.Context, in *GetSubnetworkRequest, opts ...grpc.CallOption) (*Subnetwork, error) {
	out := new(Subnetwork)
	err := c.cc.Invoke(ctx, Subnetworks_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) GetIamPolicy(ctx context.Context, in *GetIamPolicySubnetworkRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Subnetworks_GetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) Insert(ctx context.Context, in *InsertSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Subnetworks_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) List(ctx context.Context, in *ListSubnetworksRequest, opts ...grpc.CallOption) (*SubnetworkList, error) {
	out := new(SubnetworkList)
	err := c.cc.Invoke(ctx, Subnetworks_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) ListUsable(ctx context.Context, in *ListUsableSubnetworksRequest, opts ...grpc.CallOption) (*UsableSubnetworksAggregatedList, error) {
	out := new(UsableSubnetworksAggregatedList)
	err := c.cc.Invoke(ctx, Subnetworks_ListUsable_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) Patch(ctx context.Context, in *PatchSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Subnetworks_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) SetIamPolicy(ctx context.Context, in *SetIamPolicySubnetworkRequest, opts ...grpc.CallOption) (*Policy, error) {
	out := new(Policy)
	err := c.cc.Invoke(ctx, Subnetworks_SetIamPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) SetPrivateIpGoogleAccess(ctx context.Context, in *SetPrivateIpGoogleAccessSubnetworkRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, Subnetworks_SetPrivateIpGoogleAccess_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *subnetworksClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsSubnetworkRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, Subnetworks_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// SubnetworksServer is the server API for Subnetworks service.
// All implementations should embed UnimplementedSubnetworksServer
// for forward compatibility
type SubnetworksServer interface {
	// Retrieves an aggregated list of subnetworks.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListSubnetworksRequest) (*SubnetworkAggregatedList, error)
	// Deletes the specified subnetwork.
	Delete(context.Context, *DeleteSubnetworkRequest) (*Operation, error)
	// Expands the IP CIDR range of the subnetwork to a specified value.
	ExpandIpCidrRange(context.Context, *ExpandIpCidrRangeSubnetworkRequest) (*Operation, error)
	// Returns the specified subnetwork.
	Get(context.Context, *GetSubnetworkRequest) (*Subnetwork, error)
	// Gets the access control policy for a resource. May be empty if no such
	// policy or resource exists.
	GetIamPolicy(context.Context, *GetIamPolicySubnetworkRequest) (*Policy, error)
	// Creates a subnetwork in the specified project using the data
	// included in the request.
	Insert(context.Context, *InsertSubnetworkRequest) (*Operation, error)
	// Retrieves a list of subnetworks available to the specified
	// project.
	List(context.Context, *ListSubnetworksRequest) (*SubnetworkList, error)
	// Retrieves an aggregated list of all usable subnetworks in the project.
	ListUsable(context.Context, *ListUsableSubnetworksRequest) (*UsableSubnetworksAggregatedList, error)
	// Patches the specified subnetwork with the data included in the request.
	// Only certain fields can be updated with a patch request
	// as indicated in the field descriptions.
	// You must specify the current fingerprint of the
	// subnetwork resource being patched.
	Patch(context.Context, *PatchSubnetworkRequest) (*Operation, error)
	// Sets the access control policy on the specified resource.
	// Replaces any existing policy.
	SetIamPolicy(context.Context, *SetIamPolicySubnetworkRequest) (*Policy, error)
	// Set whether VMs in this subnet can access Google services without assigning
	// external IP addresses through Private Google Access.
	SetPrivateIpGoogleAccess(context.Context, *SetPrivateIpGoogleAccessSubnetworkRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsSubnetworkRequest) (*TestPermissionsResponse, error)
}

// UnimplementedSubnetworksServer should be embedded to have forward compatible implementations.
type UnimplementedSubnetworksServer struct {
}

func (UnimplementedSubnetworksServer) AggregatedList(context.Context, *AggregatedListSubnetworksRequest) (*SubnetworkAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedSubnetworksServer) Delete(context.Context, *DeleteSubnetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedSubnetworksServer) ExpandIpCidrRange(context.Context, *ExpandIpCidrRangeSubnetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExpandIpCidrRange not implemented")
}
func (UnimplementedSubnetworksServer) Get(context.Context, *GetSubnetworkRequest) (*Subnetwork, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedSubnetworksServer) GetIamPolicy(context.Context, *GetIamPolicySubnetworkRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetIamPolicy not implemented")
}
func (UnimplementedSubnetworksServer) Insert(context.Context, *InsertSubnetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedSubnetworksServer) List(context.Context, *ListSubnetworksRequest) (*SubnetworkList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedSubnetworksServer) ListUsable(context.Context, *ListUsableSubnetworksRequest) (*UsableSubnetworksAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListUsable not implemented")
}
func (UnimplementedSubnetworksServer) Patch(context.Context, *PatchSubnetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedSubnetworksServer) SetIamPolicy(context.Context, *SetIamPolicySubnetworkRequest) (*Policy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetIamPolicy not implemented")
}
func (UnimplementedSubnetworksServer) SetPrivateIpGoogleAccess(context.Context, *SetPrivateIpGoogleAccessSubnetworkRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetPrivateIpGoogleAccess not implemented")
}
func (UnimplementedSubnetworksServer) TestIamPermissions(context.Context, *TestIamPermissionsSubnetworkRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeSubnetworksServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to SubnetworksServer will
// result in compilation errors.
type UnsafeSubnetworksServer interface {
	mustEmbedUnimplementedSubnetworksServer()
}

func RegisterSubnetworksServer(s grpc.ServiceRegistrar, srv SubnetworksServer) {
	s.RegisterService(&Subnetworks_ServiceDesc, srv)
}

func _Subnetworks_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListSubnetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).AggregatedList(ctx, req.(*AggregatedListSubnetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).Delete(ctx, req.(*DeleteSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_ExpandIpCidrRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExpandIpCidrRangeSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).ExpandIpCidrRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_ExpandIpCidrRange_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).ExpandIpCidrRange(ctx, req.(*ExpandIpCidrRangeSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).Get(ctx, req.(*GetSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_GetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetIamPolicySubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).GetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_GetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).GetIamPolicy(ctx, req.(*GetIamPolicySubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).Insert(ctx, req.(*InsertSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListSubnetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).List(ctx, req.(*ListSubnetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_ListUsable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUsableSubnetworksRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).ListUsable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_ListUsable_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).ListUsable(ctx, req.(*ListUsableSubnetworksRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).Patch(ctx, req.(*PatchSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_SetIamPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetIamPolicySubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).SetIamPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_SetIamPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).SetIamPolicy(ctx, req.(*SetIamPolicySubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_SetPrivateIpGoogleAccess_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetPrivateIpGoogleAccessSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).SetPrivateIpGoogleAccess(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_SetPrivateIpGoogleAccess_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).SetPrivateIpGoogleAccess(ctx, req.(*SetPrivateIpGoogleAccessSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Subnetworks_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsSubnetworkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SubnetworksServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Subnetworks_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SubnetworksServer).TestIamPermissions(ctx, req.(*TestIamPermissionsSubnetworkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Subnetworks_ServiceDesc is the grpc.ServiceDesc for Subnetworks service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Subnetworks_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Subnetworks",
	HandlerType: (*SubnetworksServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _Subnetworks_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _Subnetworks_Delete_Handler,
		},
		{
			MethodName: "ExpandIpCidrRange",
			Handler:    _Subnetworks_ExpandIpCidrRange_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _Subnetworks_Get_Handler,
		},
		{
			MethodName: "GetIamPolicy",
			Handler:    _Subnetworks_GetIamPolicy_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _Subnetworks_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Subnetworks_List_Handler,
		},
		{
			MethodName: "ListUsable",
			Handler:    _Subnetworks_ListUsable_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _Subnetworks_Patch_Handler,
		},
		{
			MethodName: "SetIamPolicy",
			Handler:    _Subnetworks_SetIamPolicy_Handler,
		},
		{
			MethodName: "SetPrivateIpGoogleAccess",
			Handler:    _Subnetworks_SetPrivateIpGoogleAccess_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _Subnetworks_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetGrpcProxies_Delete_FullMethodName = "/google.cloud.compute.v1.TargetGrpcProxies/Delete"
	TargetGrpcProxies_Get_FullMethodName    = "/google.cloud.compute.v1.TargetGrpcProxies/Get"
	TargetGrpcProxies_Insert_FullMethodName = "/google.cloud.compute.v1.TargetGrpcProxies/Insert"
	TargetGrpcProxies_List_FullMethodName   = "/google.cloud.compute.v1.TargetGrpcProxies/List"
	TargetGrpcProxies_Patch_FullMethodName  = "/google.cloud.compute.v1.TargetGrpcProxies/Patch"
)

// TargetGrpcProxiesClient is the client API for TargetGrpcProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetGrpcProxiesClient interface {
	// Deletes the specified TargetGrpcProxy in the given scope
	Delete(ctx context.Context, in *DeleteTargetGrpcProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetGrpcProxy resource in the given scope.
	Get(ctx context.Context, in *GetTargetGrpcProxyRequest, opts ...grpc.CallOption) (*TargetGrpcProxy, error)
	// Creates a TargetGrpcProxy in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertTargetGrpcProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the TargetGrpcProxies for a project in the given scope.
	List(ctx context.Context, in *ListTargetGrpcProxiesRequest, opts ...grpc.CallOption) (*TargetGrpcProxyList, error)
	// Patches the specified TargetGrpcProxy resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchTargetGrpcProxyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type targetGrpcProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetGrpcProxiesClient(cc grpc.ClientConnInterface) TargetGrpcProxiesClient {
	return &targetGrpcProxiesClient{cc}
}

func (c *targetGrpcProxiesClient) Delete(ctx context.Context, in *DeleteTargetGrpcProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetGrpcProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetGrpcProxiesClient) Get(ctx context.Context, in *GetTargetGrpcProxyRequest, opts ...grpc.CallOption) (*TargetGrpcProxy, error) {
	out := new(TargetGrpcProxy)
	err := c.cc.Invoke(ctx, TargetGrpcProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetGrpcProxiesClient) Insert(ctx context.Context, in *InsertTargetGrpcProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetGrpcProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetGrpcProxiesClient) List(ctx context.Context, in *ListTargetGrpcProxiesRequest, opts ...grpc.CallOption) (*TargetGrpcProxyList, error) {
	out := new(TargetGrpcProxyList)
	err := c.cc.Invoke(ctx, TargetGrpcProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetGrpcProxiesClient) Patch(ctx context.Context, in *PatchTargetGrpcProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetGrpcProxies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetGrpcProxiesServer is the server API for TargetGrpcProxies service.
// All implementations should embed UnimplementedTargetGrpcProxiesServer
// for forward compatibility
type TargetGrpcProxiesServer interface {
	// Deletes the specified TargetGrpcProxy in the given scope
	Delete(context.Context, *DeleteTargetGrpcProxyRequest) (*Operation, error)
	// Returns the specified TargetGrpcProxy resource in the given scope.
	Get(context.Context, *GetTargetGrpcProxyRequest) (*TargetGrpcProxy, error)
	// Creates a TargetGrpcProxy in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertTargetGrpcProxyRequest) (*Operation, error)
	// Lists the TargetGrpcProxies for a project in the given scope.
	List(context.Context, *ListTargetGrpcProxiesRequest) (*TargetGrpcProxyList, error)
	// Patches the specified TargetGrpcProxy resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchTargetGrpcProxyRequest) (*Operation, error)
}

// UnimplementedTargetGrpcProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedTargetGrpcProxiesServer struct {
}

func (UnimplementedTargetGrpcProxiesServer) Delete(context.Context, *DeleteTargetGrpcProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetGrpcProxiesServer) Get(context.Context, *GetTargetGrpcProxyRequest) (*TargetGrpcProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetGrpcProxiesServer) Insert(context.Context, *InsertTargetGrpcProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetGrpcProxiesServer) List(context.Context, *ListTargetGrpcProxiesRequest) (*TargetGrpcProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetGrpcProxiesServer) Patch(context.Context, *PatchTargetGrpcProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeTargetGrpcProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetGrpcProxiesServer will
// result in compilation errors.
type UnsafeTargetGrpcProxiesServer interface {
	mustEmbedUnimplementedTargetGrpcProxiesServer()
}

func RegisterTargetGrpcProxiesServer(s grpc.ServiceRegistrar, srv TargetGrpcProxiesServer) {
	s.RegisterService(&TargetGrpcProxies_ServiceDesc, srv)
}

func _TargetGrpcProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetGrpcProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetGrpcProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetGrpcProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetGrpcProxiesServer).Delete(ctx, req.(*DeleteTargetGrpcProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetGrpcProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetGrpcProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetGrpcProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetGrpcProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetGrpcProxiesServer).Get(ctx, req.(*GetTargetGrpcProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetGrpcProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetGrpcProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetGrpcProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetGrpcProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetGrpcProxiesServer).Insert(ctx, req.(*InsertTargetGrpcProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetGrpcProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetGrpcProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetGrpcProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetGrpcProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetGrpcProxiesServer).List(ctx, req.(*ListTargetGrpcProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetGrpcProxies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchTargetGrpcProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetGrpcProxiesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetGrpcProxies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetGrpcProxiesServer).Patch(ctx, req.(*PatchTargetGrpcProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetGrpcProxies_ServiceDesc is the grpc.ServiceDesc for TargetGrpcProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetGrpcProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetGrpcProxies",
	HandlerType: (*TargetGrpcProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _TargetGrpcProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetGrpcProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetGrpcProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetGrpcProxies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _TargetGrpcProxies_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetHttpProxies_AggregatedList_FullMethodName = "/google.cloud.compute.v1.TargetHttpProxies/AggregatedList"
	TargetHttpProxies_Delete_FullMethodName         = "/google.cloud.compute.v1.TargetHttpProxies/Delete"
	TargetHttpProxies_Get_FullMethodName            = "/google.cloud.compute.v1.TargetHttpProxies/Get"
	TargetHttpProxies_Insert_FullMethodName         = "/google.cloud.compute.v1.TargetHttpProxies/Insert"
	TargetHttpProxies_List_FullMethodName           = "/google.cloud.compute.v1.TargetHttpProxies/List"
	TargetHttpProxies_Patch_FullMethodName          = "/google.cloud.compute.v1.TargetHttpProxies/Patch"
	TargetHttpProxies_SetUrlMap_FullMethodName      = "/google.cloud.compute.v1.TargetHttpProxies/SetUrlMap"
)

// TargetHttpProxiesClient is the client API for TargetHttpProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetHttpProxiesClient interface {
	// Retrieves the list of all TargetHttpProxy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListTargetHttpProxiesRequest, opts ...grpc.CallOption) (*TargetHttpProxyAggregatedList, error)
	// Deletes the specified TargetHttpProxy resource.
	Delete(ctx context.Context, in *DeleteTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetHttpProxy resource.
	Get(ctx context.Context, in *GetTargetHttpProxyRequest, opts ...grpc.CallOption) (*TargetHttpProxy, error)
	// Creates a TargetHttpProxy resource in the specified
	// project using the data included in the request.
	Insert(ctx context.Context, in *InsertTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of TargetHttpProxy resources available
	// to the specified project.
	List(ctx context.Context, in *ListTargetHttpProxiesRequest, opts ...grpc.CallOption) (*TargetHttpProxyList, error)
	// Patches the specified TargetHttpProxy resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the URL map for TargetHttpProxy.
	SetUrlMap(ctx context.Context, in *SetUrlMapTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type targetHttpProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetHttpProxiesClient(cc grpc.ClientConnInterface) TargetHttpProxiesClient {
	return &targetHttpProxiesClient{cc}
}

func (c *targetHttpProxiesClient) AggregatedList(ctx context.Context, in *AggregatedListTargetHttpProxiesRequest, opts ...grpc.CallOption) (*TargetHttpProxyAggregatedList, error) {
	out := new(TargetHttpProxyAggregatedList)
	err := c.cc.Invoke(ctx, TargetHttpProxies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpProxiesClient) Delete(ctx context.Context, in *DeleteTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpProxiesClient) Get(ctx context.Context, in *GetTargetHttpProxyRequest, opts ...grpc.CallOption) (*TargetHttpProxy, error) {
	out := new(TargetHttpProxy)
	err := c.cc.Invoke(ctx, TargetHttpProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpProxiesClient) Insert(ctx context.Context, in *InsertTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpProxiesClient) List(ctx context.Context, in *ListTargetHttpProxiesRequest, opts ...grpc.CallOption) (*TargetHttpProxyList, error) {
	out := new(TargetHttpProxyList)
	err := c.cc.Invoke(ctx, TargetHttpProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpProxiesClient) Patch(ctx context.Context, in *PatchTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpProxies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpProxiesClient) SetUrlMap(ctx context.Context, in *SetUrlMapTargetHttpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpProxies_SetUrlMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetHttpProxiesServer is the server API for TargetHttpProxies service.
// All implementations should embed UnimplementedTargetHttpProxiesServer
// for forward compatibility
type TargetHttpProxiesServer interface {
	// Retrieves the list of all TargetHttpProxy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListTargetHttpProxiesRequest) (*TargetHttpProxyAggregatedList, error)
	// Deletes the specified TargetHttpProxy resource.
	Delete(context.Context, *DeleteTargetHttpProxyRequest) (*Operation, error)
	// Returns the specified TargetHttpProxy resource.
	Get(context.Context, *GetTargetHttpProxyRequest) (*TargetHttpProxy, error)
	// Creates a TargetHttpProxy resource in the specified
	// project using the data included in the request.
	Insert(context.Context, *InsertTargetHttpProxyRequest) (*Operation, error)
	// Retrieves the list of TargetHttpProxy resources available
	// to the specified project.
	List(context.Context, *ListTargetHttpProxiesRequest) (*TargetHttpProxyList, error)
	// Patches the specified TargetHttpProxy resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchTargetHttpProxyRequest) (*Operation, error)
	// Changes the URL map for TargetHttpProxy.
	SetUrlMap(context.Context, *SetUrlMapTargetHttpProxyRequest) (*Operation, error)
}

// UnimplementedTargetHttpProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedTargetHttpProxiesServer struct {
}

func (UnimplementedTargetHttpProxiesServer) AggregatedList(context.Context, *AggregatedListTargetHttpProxiesRequest) (*TargetHttpProxyAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedTargetHttpProxiesServer) Delete(context.Context, *DeleteTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetHttpProxiesServer) Get(context.Context, *GetTargetHttpProxyRequest) (*TargetHttpProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetHttpProxiesServer) Insert(context.Context, *InsertTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetHttpProxiesServer) List(context.Context, *ListTargetHttpProxiesRequest) (*TargetHttpProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetHttpProxiesServer) Patch(context.Context, *PatchTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedTargetHttpProxiesServer) SetUrlMap(context.Context, *SetUrlMapTargetHttpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUrlMap not implemented")
}

// UnsafeTargetHttpProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetHttpProxiesServer will
// result in compilation errors.
type UnsafeTargetHttpProxiesServer interface {
	mustEmbedUnimplementedTargetHttpProxiesServer()
}

func RegisterTargetHttpProxiesServer(s grpc.ServiceRegistrar, srv TargetHttpProxiesServer) {
	s.RegisterService(&TargetHttpProxies_ServiceDesc, srv)
}

func _TargetHttpProxies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListTargetHttpProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).AggregatedList(ctx, req.(*AggregatedListTargetHttpProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).Delete(ctx, req.(*DeleteTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).Get(ctx, req.(*GetTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).Insert(ctx, req.(*InsertTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetHttpProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).List(ctx, req.(*ListTargetHttpProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpProxies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).Patch(ctx, req.(*PatchTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpProxies_SetUrlMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUrlMapTargetHttpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpProxiesServer).SetUrlMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpProxies_SetUrlMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpProxiesServer).SetUrlMap(ctx, req.(*SetUrlMapTargetHttpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetHttpProxies_ServiceDesc is the grpc.ServiceDesc for TargetHttpProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetHttpProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetHttpProxies",
	HandlerType: (*TargetHttpProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _TargetHttpProxies_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TargetHttpProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetHttpProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetHttpProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetHttpProxies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _TargetHttpProxies_Patch_Handler,
		},
		{
			MethodName: "SetUrlMap",
			Handler:    _TargetHttpProxies_SetUrlMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetHttpsProxies_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.TargetHttpsProxies/AggregatedList"
	TargetHttpsProxies_Delete_FullMethodName             = "/google.cloud.compute.v1.TargetHttpsProxies/Delete"
	TargetHttpsProxies_Get_FullMethodName                = "/google.cloud.compute.v1.TargetHttpsProxies/Get"
	TargetHttpsProxies_Insert_FullMethodName             = "/google.cloud.compute.v1.TargetHttpsProxies/Insert"
	TargetHttpsProxies_List_FullMethodName               = "/google.cloud.compute.v1.TargetHttpsProxies/List"
	TargetHttpsProxies_Patch_FullMethodName              = "/google.cloud.compute.v1.TargetHttpsProxies/Patch"
	TargetHttpsProxies_SetCertificateMap_FullMethodName  = "/google.cloud.compute.v1.TargetHttpsProxies/SetCertificateMap"
	TargetHttpsProxies_SetQuicOverride_FullMethodName    = "/google.cloud.compute.v1.TargetHttpsProxies/SetQuicOverride"
	TargetHttpsProxies_SetSslCertificates_FullMethodName = "/google.cloud.compute.v1.TargetHttpsProxies/SetSslCertificates"
	TargetHttpsProxies_SetSslPolicy_FullMethodName       = "/google.cloud.compute.v1.TargetHttpsProxies/SetSslPolicy"
	TargetHttpsProxies_SetUrlMap_FullMethodName          = "/google.cloud.compute.v1.TargetHttpsProxies/SetUrlMap"
)

// TargetHttpsProxiesClient is the client API for TargetHttpsProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetHttpsProxiesClient interface {
	// Retrieves the list of all TargetHttpsProxy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListTargetHttpsProxiesRequest, opts ...grpc.CallOption) (*TargetHttpsProxyAggregatedList, error)
	// Deletes the specified TargetHttpsProxy resource.
	Delete(ctx context.Context, in *DeleteTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetHttpsProxy resource.
	Get(ctx context.Context, in *GetTargetHttpsProxyRequest, opts ...grpc.CallOption) (*TargetHttpsProxy, error)
	// Creates a TargetHttpsProxy resource in the specified
	// project using the data included in the request.
	Insert(ctx context.Context, in *InsertTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of TargetHttpsProxy resources
	// available to the specified project.
	List(ctx context.Context, in *ListTargetHttpsProxiesRequest, opts ...grpc.CallOption) (*TargetHttpsProxyList, error)
	// Patches the specified TargetHttpsProxy resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the Certificate Map for TargetHttpsProxy.
	SetCertificateMap(ctx context.Context, in *SetCertificateMapTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the QUIC override policy for TargetHttpsProxy.
	SetQuicOverride(ctx context.Context, in *SetQuicOverrideTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Replaces SslCertificates for TargetHttpsProxy.
	SetSslCertificates(ctx context.Context, in *SetSslCertificatesTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
	// server-side support for SSL features. This affects connections between
	// clients and the HTTPS proxy load balancer. They do not affect the
	// connection between the load balancer and the backends.
	SetSslPolicy(ctx context.Context, in *SetSslPolicyTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the URL map for TargetHttpsProxy.
	SetUrlMap(ctx context.Context, in *SetUrlMapTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error)
}

type targetHttpsProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetHttpsProxiesClient(cc grpc.ClientConnInterface) TargetHttpsProxiesClient {
	return &targetHttpsProxiesClient{cc}
}

func (c *targetHttpsProxiesClient) AggregatedList(ctx context.Context, in *AggregatedListTargetHttpsProxiesRequest, opts ...grpc.CallOption) (*TargetHttpsProxyAggregatedList, error) {
	out := new(TargetHttpsProxyAggregatedList)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) Delete(ctx context.Context, in *DeleteTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) Get(ctx context.Context, in *GetTargetHttpsProxyRequest, opts ...grpc.CallOption) (*TargetHttpsProxy, error) {
	out := new(TargetHttpsProxy)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) Insert(ctx context.Context, in *InsertTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) List(ctx context.Context, in *ListTargetHttpsProxiesRequest, opts ...grpc.CallOption) (*TargetHttpsProxyList, error) {
	out := new(TargetHttpsProxyList)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) Patch(ctx context.Context, in *PatchTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) SetCertificateMap(ctx context.Context, in *SetCertificateMapTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_SetCertificateMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) SetQuicOverride(ctx context.Context, in *SetQuicOverrideTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_SetQuicOverride_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) SetSslCertificates(ctx context.Context, in *SetSslCertificatesTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_SetSslCertificates_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) SetSslPolicy(ctx context.Context, in *SetSslPolicyTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_SetSslPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetHttpsProxiesClient) SetUrlMap(ctx context.Context, in *SetUrlMapTargetHttpsProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetHttpsProxies_SetUrlMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetHttpsProxiesServer is the server API for TargetHttpsProxies service.
// All implementations should embed UnimplementedTargetHttpsProxiesServer
// for forward compatibility
type TargetHttpsProxiesServer interface {
	// Retrieves the list of all TargetHttpsProxy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListTargetHttpsProxiesRequest) (*TargetHttpsProxyAggregatedList, error)
	// Deletes the specified TargetHttpsProxy resource.
	Delete(context.Context, *DeleteTargetHttpsProxyRequest) (*Operation, error)
	// Returns the specified TargetHttpsProxy resource.
	Get(context.Context, *GetTargetHttpsProxyRequest) (*TargetHttpsProxy, error)
	// Creates a TargetHttpsProxy resource in the specified
	// project using the data included in the request.
	Insert(context.Context, *InsertTargetHttpsProxyRequest) (*Operation, error)
	// Retrieves the list of TargetHttpsProxy resources
	// available to the specified project.
	List(context.Context, *ListTargetHttpsProxiesRequest) (*TargetHttpsProxyList, error)
	// Patches the specified TargetHttpsProxy resource with the data included in
	// the request. This method supports PATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchTargetHttpsProxyRequest) (*Operation, error)
	// Changes the Certificate Map for TargetHttpsProxy.
	SetCertificateMap(context.Context, *SetCertificateMapTargetHttpsProxyRequest) (*Operation, error)
	// Sets the QUIC override policy for TargetHttpsProxy.
	SetQuicOverride(context.Context, *SetQuicOverrideTargetHttpsProxyRequest) (*Operation, error)
	// Replaces SslCertificates for TargetHttpsProxy.
	SetSslCertificates(context.Context, *SetSslCertificatesTargetHttpsProxyRequest) (*Operation, error)
	// Sets the SSL policy for TargetHttpsProxy. The SSL policy specifies the
	// server-side support for SSL features. This affects connections between
	// clients and the HTTPS proxy load balancer. They do not affect the
	// connection between the load balancer and the backends.
	SetSslPolicy(context.Context, *SetSslPolicyTargetHttpsProxyRequest) (*Operation, error)
	// Changes the URL map for TargetHttpsProxy.
	SetUrlMap(context.Context, *SetUrlMapTargetHttpsProxyRequest) (*Operation, error)
}

// UnimplementedTargetHttpsProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedTargetHttpsProxiesServer struct {
}

func (UnimplementedTargetHttpsProxiesServer) AggregatedList(context.Context, *AggregatedListTargetHttpsProxiesRequest) (*TargetHttpsProxyAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) Delete(context.Context, *DeleteTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) Get(context.Context, *GetTargetHttpsProxyRequest) (*TargetHttpsProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) Insert(context.Context, *InsertTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) List(context.Context, *ListTargetHttpsProxiesRequest) (*TargetHttpsProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) Patch(context.Context, *PatchTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) SetCertificateMap(context.Context, *SetCertificateMapTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCertificateMap not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) SetQuicOverride(context.Context, *SetQuicOverrideTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetQuicOverride not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) SetSslCertificates(context.Context, *SetSslCertificatesTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSslCertificates not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) SetSslPolicy(context.Context, *SetSslPolicyTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSslPolicy not implemented")
}
func (UnimplementedTargetHttpsProxiesServer) SetUrlMap(context.Context, *SetUrlMapTargetHttpsProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetUrlMap not implemented")
}

// UnsafeTargetHttpsProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetHttpsProxiesServer will
// result in compilation errors.
type UnsafeTargetHttpsProxiesServer interface {
	mustEmbedUnimplementedTargetHttpsProxiesServer()
}

func RegisterTargetHttpsProxiesServer(s grpc.ServiceRegistrar, srv TargetHttpsProxiesServer) {
	s.RegisterService(&TargetHttpsProxies_ServiceDesc, srv)
}

func _TargetHttpsProxies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListTargetHttpsProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).AggregatedList(ctx, req.(*AggregatedListTargetHttpsProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).Delete(ctx, req.(*DeleteTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).Get(ctx, req.(*GetTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).Insert(ctx, req.(*InsertTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetHttpsProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).List(ctx, req.(*ListTargetHttpsProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).Patch(ctx, req.(*PatchTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_SetCertificateMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCertificateMapTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).SetCertificateMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_SetCertificateMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).SetCertificateMap(ctx, req.(*SetCertificateMapTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_SetQuicOverride_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetQuicOverrideTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).SetQuicOverride(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_SetQuicOverride_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).SetQuicOverride(ctx, req.(*SetQuicOverrideTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_SetSslCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSslCertificatesTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).SetSslCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_SetSslCertificates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).SetSslCertificates(ctx, req.(*SetSslCertificatesTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_SetSslPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSslPolicyTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).SetSslPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_SetSslPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).SetSslPolicy(ctx, req.(*SetSslPolicyTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetHttpsProxies_SetUrlMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetUrlMapTargetHttpsProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetHttpsProxiesServer).SetUrlMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetHttpsProxies_SetUrlMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetHttpsProxiesServer).SetUrlMap(ctx, req.(*SetUrlMapTargetHttpsProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetHttpsProxies_ServiceDesc is the grpc.ServiceDesc for TargetHttpsProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetHttpsProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetHttpsProxies",
	HandlerType: (*TargetHttpsProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _TargetHttpsProxies_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TargetHttpsProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetHttpsProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetHttpsProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetHttpsProxies_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _TargetHttpsProxies_Patch_Handler,
		},
		{
			MethodName: "SetCertificateMap",
			Handler:    _TargetHttpsProxies_SetCertificateMap_Handler,
		},
		{
			MethodName: "SetQuicOverride",
			Handler:    _TargetHttpsProxies_SetQuicOverride_Handler,
		},
		{
			MethodName: "SetSslCertificates",
			Handler:    _TargetHttpsProxies_SetSslCertificates_Handler,
		},
		{
			MethodName: "SetSslPolicy",
			Handler:    _TargetHttpsProxies_SetSslPolicy_Handler,
		},
		{
			MethodName: "SetUrlMap",
			Handler:    _TargetHttpsProxies_SetUrlMap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetInstances_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.TargetInstances/AggregatedList"
	TargetInstances_Delete_FullMethodName             = "/google.cloud.compute.v1.TargetInstances/Delete"
	TargetInstances_Get_FullMethodName                = "/google.cloud.compute.v1.TargetInstances/Get"
	TargetInstances_Insert_FullMethodName             = "/google.cloud.compute.v1.TargetInstances/Insert"
	TargetInstances_List_FullMethodName               = "/google.cloud.compute.v1.TargetInstances/List"
	TargetInstances_SetSecurityPolicy_FullMethodName  = "/google.cloud.compute.v1.TargetInstances/SetSecurityPolicy"
	TargetInstances_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.TargetInstances/TestIamPermissions"
)

// TargetInstancesClient is the client API for TargetInstances service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetInstancesClient interface {
	// Retrieves an aggregated list of target instances.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListTargetInstancesRequest, opts ...grpc.CallOption) (*TargetInstanceAggregatedList, error)
	// Deletes the specified TargetInstance resource.
	Delete(ctx context.Context, in *DeleteTargetInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetInstance resource.
	Get(ctx context.Context, in *GetTargetInstanceRequest, opts ...grpc.CallOption) (*TargetInstance, error)
	// Creates a TargetInstance resource in the specified project and zone using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertTargetInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of TargetInstance resources available to the specified
	// project and zone.
	List(ctx context.Context, in *ListTargetInstancesRequest, opts ...grpc.CallOption) (*TargetInstanceList, error)
	// Sets the Google Cloud Armor security policy for the specified target
	// instance. For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyTargetInstanceRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetInstanceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type targetInstancesClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetInstancesClient(cc grpc.ClientConnInterface) TargetInstancesClient {
	return &targetInstancesClient{cc}
}

func (c *targetInstancesClient) AggregatedList(ctx context.Context, in *AggregatedListTargetInstancesRequest, opts ...grpc.CallOption) (*TargetInstanceAggregatedList, error) {
	out := new(TargetInstanceAggregatedList)
	err := c.cc.Invoke(ctx, TargetInstances_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetInstancesClient) Delete(ctx context.Context, in *DeleteTargetInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetInstances_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetInstancesClient) Get(ctx context.Context, in *GetTargetInstanceRequest, opts ...grpc.CallOption) (*TargetInstance, error) {
	out := new(TargetInstance)
	err := c.cc.Invoke(ctx, TargetInstances_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetInstancesClient) Insert(ctx context.Context, in *InsertTargetInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetInstances_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetInstancesClient) List(ctx context.Context, in *ListTargetInstancesRequest, opts ...grpc.CallOption) (*TargetInstanceList, error) {
	out := new(TargetInstanceList)
	err := c.cc.Invoke(ctx, TargetInstances_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetInstancesClient) SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyTargetInstanceRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetInstances_SetSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetInstancesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetInstanceRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, TargetInstances_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetInstancesServer is the server API for TargetInstances service.
// All implementations should embed UnimplementedTargetInstancesServer
// for forward compatibility
type TargetInstancesServer interface {
	// Retrieves an aggregated list of target instances.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListTargetInstancesRequest) (*TargetInstanceAggregatedList, error)
	// Deletes the specified TargetInstance resource.
	Delete(context.Context, *DeleteTargetInstanceRequest) (*Operation, error)
	// Returns the specified TargetInstance resource.
	Get(context.Context, *GetTargetInstanceRequest) (*TargetInstance, error)
	// Creates a TargetInstance resource in the specified project and zone using
	// the data included in the request.
	Insert(context.Context, *InsertTargetInstanceRequest) (*Operation, error)
	// Retrieves a list of TargetInstance resources available to the specified
	// project and zone.
	List(context.Context, *ListTargetInstancesRequest) (*TargetInstanceList, error)
	// Sets the Google Cloud Armor security policy for the specified target
	// instance. For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(context.Context, *SetSecurityPolicyTargetInstanceRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsTargetInstanceRequest) (*TestPermissionsResponse, error)
}

// UnimplementedTargetInstancesServer should be embedded to have forward compatible implementations.
type UnimplementedTargetInstancesServer struct {
}

func (UnimplementedTargetInstancesServer) AggregatedList(context.Context, *AggregatedListTargetInstancesRequest) (*TargetInstanceAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedTargetInstancesServer) Delete(context.Context, *DeleteTargetInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetInstancesServer) Get(context.Context, *GetTargetInstanceRequest) (*TargetInstance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetInstancesServer) Insert(context.Context, *InsertTargetInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetInstancesServer) List(context.Context, *ListTargetInstancesRequest) (*TargetInstanceList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetInstancesServer) SetSecurityPolicy(context.Context, *SetSecurityPolicyTargetInstanceRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSecurityPolicy not implemented")
}
func (UnimplementedTargetInstancesServer) TestIamPermissions(context.Context, *TestIamPermissionsTargetInstanceRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeTargetInstancesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetInstancesServer will
// result in compilation errors.
type UnsafeTargetInstancesServer interface {
	mustEmbedUnimplementedTargetInstancesServer()
}

func RegisterTargetInstancesServer(s grpc.ServiceRegistrar, srv TargetInstancesServer) {
	s.RegisterService(&TargetInstances_ServiceDesc, srv)
}

func _TargetInstances_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListTargetInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).AggregatedList(ctx, req.(*AggregatedListTargetInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetInstances_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).Delete(ctx, req.(*DeleteTargetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetInstances_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).Get(ctx, req.(*GetTargetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetInstances_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).Insert(ctx, req.(*InsertTargetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetInstances_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).List(ctx, req.(*ListTargetInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetInstances_SetSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSecurityPolicyTargetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).SetSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_SetSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).SetSecurityPolicy(ctx, req.(*SetSecurityPolicyTargetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetInstances_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsTargetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetInstancesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetInstances_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetInstancesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsTargetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetInstances_ServiceDesc is the grpc.ServiceDesc for TargetInstances service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetInstances_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetInstances",
	HandlerType: (*TargetInstancesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _TargetInstances_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TargetInstances_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetInstances_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetInstances_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetInstances_List_Handler,
		},
		{
			MethodName: "SetSecurityPolicy",
			Handler:    _TargetInstances_SetSecurityPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _TargetInstances_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetPools_AddHealthCheck_FullMethodName     = "/google.cloud.compute.v1.TargetPools/AddHealthCheck"
	TargetPools_AddInstance_FullMethodName        = "/google.cloud.compute.v1.TargetPools/AddInstance"
	TargetPools_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.TargetPools/AggregatedList"
	TargetPools_Delete_FullMethodName             = "/google.cloud.compute.v1.TargetPools/Delete"
	TargetPools_Get_FullMethodName                = "/google.cloud.compute.v1.TargetPools/Get"
	TargetPools_GetHealth_FullMethodName          = "/google.cloud.compute.v1.TargetPools/GetHealth"
	TargetPools_Insert_FullMethodName             = "/google.cloud.compute.v1.TargetPools/Insert"
	TargetPools_List_FullMethodName               = "/google.cloud.compute.v1.TargetPools/List"
	TargetPools_RemoveHealthCheck_FullMethodName  = "/google.cloud.compute.v1.TargetPools/RemoveHealthCheck"
	TargetPools_RemoveInstance_FullMethodName     = "/google.cloud.compute.v1.TargetPools/RemoveInstance"
	TargetPools_SetBackup_FullMethodName          = "/google.cloud.compute.v1.TargetPools/SetBackup"
	TargetPools_SetSecurityPolicy_FullMethodName  = "/google.cloud.compute.v1.TargetPools/SetSecurityPolicy"
	TargetPools_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.TargetPools/TestIamPermissions"
)

// TargetPoolsClient is the client API for TargetPools service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetPoolsClient interface {
	// Adds health check URLs to a target pool.
	AddHealthCheck(ctx context.Context, in *AddHealthCheckTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Adds an instance to a target pool.
	AddInstance(ctx context.Context, in *AddInstanceTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves an aggregated list of target pools.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListTargetPoolsRequest, opts ...grpc.CallOption) (*TargetPoolAggregatedList, error)
	// Deletes the specified target pool.
	Delete(ctx context.Context, in *DeleteTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified target pool.
	Get(ctx context.Context, in *GetTargetPoolRequest, opts ...grpc.CallOption) (*TargetPool, error)
	// Gets the most recent health check results for each IP for the
	// instance that is referenced by the given target pool.
	GetHealth(ctx context.Context, in *GetHealthTargetPoolRequest, opts ...grpc.CallOption) (*TargetPoolInstanceHealth, error)
	// Creates a target pool in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of target pools available to the specified
	// project and region.
	List(ctx context.Context, in *ListTargetPoolsRequest, opts ...grpc.CallOption) (*TargetPoolList, error)
	// Removes health check URL from a target pool.
	RemoveHealthCheck(ctx context.Context, in *RemoveHealthCheckTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Removes instance URL from a target pool.
	RemoveInstance(ctx context.Context, in *RemoveInstanceTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes a backup target pool's configurations.
	SetBackup(ctx context.Context, in *SetBackupTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the Google Cloud Armor security policy for the specified target pool.
	// For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetPoolRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type targetPoolsClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetPoolsClient(cc grpc.ClientConnInterface) TargetPoolsClient {
	return &targetPoolsClient{cc}
}

func (c *targetPoolsClient) AddHealthCheck(ctx context.Context, in *AddHealthCheckTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_AddHealthCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) AddInstance(ctx context.Context, in *AddInstanceTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_AddInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) AggregatedList(ctx context.Context, in *AggregatedListTargetPoolsRequest, opts ...grpc.CallOption) (*TargetPoolAggregatedList, error) {
	out := new(TargetPoolAggregatedList)
	err := c.cc.Invoke(ctx, TargetPools_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) Delete(ctx context.Context, in *DeleteTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) Get(ctx context.Context, in *GetTargetPoolRequest, opts ...grpc.CallOption) (*TargetPool, error) {
	out := new(TargetPool)
	err := c.cc.Invoke(ctx, TargetPools_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) GetHealth(ctx context.Context, in *GetHealthTargetPoolRequest, opts ...grpc.CallOption) (*TargetPoolInstanceHealth, error) {
	out := new(TargetPoolInstanceHealth)
	err := c.cc.Invoke(ctx, TargetPools_GetHealth_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) Insert(ctx context.Context, in *InsertTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) List(ctx context.Context, in *ListTargetPoolsRequest, opts ...grpc.CallOption) (*TargetPoolList, error) {
	out := new(TargetPoolList)
	err := c.cc.Invoke(ctx, TargetPools_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) RemoveHealthCheck(ctx context.Context, in *RemoveHealthCheckTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_RemoveHealthCheck_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) RemoveInstance(ctx context.Context, in *RemoveInstanceTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_RemoveInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) SetBackup(ctx context.Context, in *SetBackupTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_SetBackup_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) SetSecurityPolicy(ctx context.Context, in *SetSecurityPolicyTargetPoolRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetPools_SetSecurityPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetPoolsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetPoolRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, TargetPools_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetPoolsServer is the server API for TargetPools service.
// All implementations should embed UnimplementedTargetPoolsServer
// for forward compatibility
type TargetPoolsServer interface {
	// Adds health check URLs to a target pool.
	AddHealthCheck(context.Context, *AddHealthCheckTargetPoolRequest) (*Operation, error)
	// Adds an instance to a target pool.
	AddInstance(context.Context, *AddInstanceTargetPoolRequest) (*Operation, error)
	// Retrieves an aggregated list of target pools.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListTargetPoolsRequest) (*TargetPoolAggregatedList, error)
	// Deletes the specified target pool.
	Delete(context.Context, *DeleteTargetPoolRequest) (*Operation, error)
	// Returns the specified target pool.
	Get(context.Context, *GetTargetPoolRequest) (*TargetPool, error)
	// Gets the most recent health check results for each IP for the
	// instance that is referenced by the given target pool.
	GetHealth(context.Context, *GetHealthTargetPoolRequest) (*TargetPoolInstanceHealth, error)
	// Creates a target pool in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertTargetPoolRequest) (*Operation, error)
	// Retrieves a list of target pools available to the specified
	// project and region.
	List(context.Context, *ListTargetPoolsRequest) (*TargetPoolList, error)
	// Removes health check URL from a target pool.
	RemoveHealthCheck(context.Context, *RemoveHealthCheckTargetPoolRequest) (*Operation, error)
	// Removes instance URL from a target pool.
	RemoveInstance(context.Context, *RemoveInstanceTargetPoolRequest) (*Operation, error)
	// Changes a backup target pool's configurations.
	SetBackup(context.Context, *SetBackupTargetPoolRequest) (*Operation, error)
	// Sets the Google Cloud Armor security policy for the specified target pool.
	// For more information, seeGoogle
	// Cloud Armor Overview
	SetSecurityPolicy(context.Context, *SetSecurityPolicyTargetPoolRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsTargetPoolRequest) (*TestPermissionsResponse, error)
}

// UnimplementedTargetPoolsServer should be embedded to have forward compatible implementations.
type UnimplementedTargetPoolsServer struct {
}

func (UnimplementedTargetPoolsServer) AddHealthCheck(context.Context, *AddHealthCheckTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddHealthCheck not implemented")
}
func (UnimplementedTargetPoolsServer) AddInstance(context.Context, *AddInstanceTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddInstance not implemented")
}
func (UnimplementedTargetPoolsServer) AggregatedList(context.Context, *AggregatedListTargetPoolsRequest) (*TargetPoolAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedTargetPoolsServer) Delete(context.Context, *DeleteTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetPoolsServer) Get(context.Context, *GetTargetPoolRequest) (*TargetPool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetPoolsServer) GetHealth(context.Context, *GetHealthTargetPoolRequest) (*TargetPoolInstanceHealth, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetHealth not implemented")
}
func (UnimplementedTargetPoolsServer) Insert(context.Context, *InsertTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetPoolsServer) List(context.Context, *ListTargetPoolsRequest) (*TargetPoolList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetPoolsServer) RemoveHealthCheck(context.Context, *RemoveHealthCheckTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveHealthCheck not implemented")
}
func (UnimplementedTargetPoolsServer) RemoveInstance(context.Context, *RemoveInstanceTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RemoveInstance not implemented")
}
func (UnimplementedTargetPoolsServer) SetBackup(context.Context, *SetBackupTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBackup not implemented")
}
func (UnimplementedTargetPoolsServer) SetSecurityPolicy(context.Context, *SetSecurityPolicyTargetPoolRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSecurityPolicy not implemented")
}
func (UnimplementedTargetPoolsServer) TestIamPermissions(context.Context, *TestIamPermissionsTargetPoolRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeTargetPoolsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetPoolsServer will
// result in compilation errors.
type UnsafeTargetPoolsServer interface {
	mustEmbedUnimplementedTargetPoolsServer()
}

func RegisterTargetPoolsServer(s grpc.ServiceRegistrar, srv TargetPoolsServer) {
	s.RegisterService(&TargetPools_ServiceDesc, srv)
}

func _TargetPools_AddHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddHealthCheckTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).AddHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_AddHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).AddHealthCheck(ctx, req.(*AddHealthCheckTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_AddInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AddInstanceTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).AddInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_AddInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).AddInstance(ctx, req.(*AddInstanceTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListTargetPoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).AggregatedList(ctx, req.(*AggregatedListTargetPoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).Delete(ctx, req.(*DeleteTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).Get(ctx, req.(*GetTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_GetHealth_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetHealthTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).GetHealth(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_GetHealth_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).GetHealth(ctx, req.(*GetHealthTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).Insert(ctx, req.(*InsertTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetPoolsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).List(ctx, req.(*ListTargetPoolsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_RemoveHealthCheck_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveHealthCheckTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).RemoveHealthCheck(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_RemoveHealthCheck_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).RemoveHealthCheck(ctx, req.(*RemoveHealthCheckTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_RemoveInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RemoveInstanceTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).RemoveInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_RemoveInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).RemoveInstance(ctx, req.(*RemoveInstanceTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_SetBackup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBackupTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).SetBackup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_SetBackup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).SetBackup(ctx, req.(*SetBackupTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_SetSecurityPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSecurityPolicyTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).SetSecurityPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_SetSecurityPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).SetSecurityPolicy(ctx, req.(*SetSecurityPolicyTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetPools_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsTargetPoolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetPoolsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetPools_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetPoolsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsTargetPoolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetPools_ServiceDesc is the grpc.ServiceDesc for TargetPools service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetPools_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetPools",
	HandlerType: (*TargetPoolsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AddHealthCheck",
			Handler:    _TargetPools_AddHealthCheck_Handler,
		},
		{
			MethodName: "AddInstance",
			Handler:    _TargetPools_AddInstance_Handler,
		},
		{
			MethodName: "AggregatedList",
			Handler:    _TargetPools_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TargetPools_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetPools_Get_Handler,
		},
		{
			MethodName: "GetHealth",
			Handler:    _TargetPools_GetHealth_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetPools_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetPools_List_Handler,
		},
		{
			MethodName: "RemoveHealthCheck",
			Handler:    _TargetPools_RemoveHealthCheck_Handler,
		},
		{
			MethodName: "RemoveInstance",
			Handler:    _TargetPools_RemoveInstance_Handler,
		},
		{
			MethodName: "SetBackup",
			Handler:    _TargetPools_SetBackup_Handler,
		},
		{
			MethodName: "SetSecurityPolicy",
			Handler:    _TargetPools_SetSecurityPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _TargetPools_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetSslProxies_Delete_FullMethodName             = "/google.cloud.compute.v1.TargetSslProxies/Delete"
	TargetSslProxies_Get_FullMethodName                = "/google.cloud.compute.v1.TargetSslProxies/Get"
	TargetSslProxies_Insert_FullMethodName             = "/google.cloud.compute.v1.TargetSslProxies/Insert"
	TargetSslProxies_List_FullMethodName               = "/google.cloud.compute.v1.TargetSslProxies/List"
	TargetSslProxies_SetBackendService_FullMethodName  = "/google.cloud.compute.v1.TargetSslProxies/SetBackendService"
	TargetSslProxies_SetCertificateMap_FullMethodName  = "/google.cloud.compute.v1.TargetSslProxies/SetCertificateMap"
	TargetSslProxies_SetProxyHeader_FullMethodName     = "/google.cloud.compute.v1.TargetSslProxies/SetProxyHeader"
	TargetSslProxies_SetSslCertificates_FullMethodName = "/google.cloud.compute.v1.TargetSslProxies/SetSslCertificates"
	TargetSslProxies_SetSslPolicy_FullMethodName       = "/google.cloud.compute.v1.TargetSslProxies/SetSslPolicy"
	TargetSslProxies_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.TargetSslProxies/TestIamPermissions"
)

// TargetSslProxiesClient is the client API for TargetSslProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetSslProxiesClient interface {
	// Deletes the specified TargetSslProxy resource.
	Delete(ctx context.Context, in *DeleteTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetSslProxy resource.
	Get(ctx context.Context, in *GetTargetSslProxyRequest, opts ...grpc.CallOption) (*TargetSslProxy, error)
	// Creates a TargetSslProxy resource in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of TargetSslProxy resources
	// available to the specified project.
	List(ctx context.Context, in *ListTargetSslProxiesRequest, opts ...grpc.CallOption) (*TargetSslProxyList, error)
	// Changes the BackendService for TargetSslProxy.
	SetBackendService(ctx context.Context, in *SetBackendServiceTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the Certificate Map for TargetSslProxy.
	SetCertificateMap(ctx context.Context, in *SetCertificateMapTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the ProxyHeaderType for TargetSslProxy.
	SetProxyHeader(ctx context.Context, in *SetProxyHeaderTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes SslCertificates for TargetSslProxy.
	SetSslCertificates(ctx context.Context, in *SetSslCertificatesTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
	// server-side support for SSL features. This affects connections between
	// clients and the load balancer. They do not affect the
	// connection between the load balancer and the backends.
	SetSslPolicy(ctx context.Context, in *SetSslPolicyTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetSslProxyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type targetSslProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetSslProxiesClient(cc grpc.ClientConnInterface) TargetSslProxiesClient {
	return &targetSslProxiesClient{cc}
}

func (c *targetSslProxiesClient) Delete(ctx context.Context, in *DeleteTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) Get(ctx context.Context, in *GetTargetSslProxyRequest, opts ...grpc.CallOption) (*TargetSslProxy, error) {
	out := new(TargetSslProxy)
	err := c.cc.Invoke(ctx, TargetSslProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) Insert(ctx context.Context, in *InsertTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) List(ctx context.Context, in *ListTargetSslProxiesRequest, opts ...grpc.CallOption) (*TargetSslProxyList, error) {
	out := new(TargetSslProxyList)
	err := c.cc.Invoke(ctx, TargetSslProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) SetBackendService(ctx context.Context, in *SetBackendServiceTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_SetBackendService_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) SetCertificateMap(ctx context.Context, in *SetCertificateMapTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_SetCertificateMap_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) SetProxyHeader(ctx context.Context, in *SetProxyHeaderTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_SetProxyHeader_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) SetSslCertificates(ctx context.Context, in *SetSslCertificatesTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_SetSslCertificates_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) SetSslPolicy(ctx context.Context, in *SetSslPolicyTargetSslProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetSslProxies_SetSslPolicy_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetSslProxiesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetSslProxyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, TargetSslProxies_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetSslProxiesServer is the server API for TargetSslProxies service.
// All implementations should embed UnimplementedTargetSslProxiesServer
// for forward compatibility
type TargetSslProxiesServer interface {
	// Deletes the specified TargetSslProxy resource.
	Delete(context.Context, *DeleteTargetSslProxyRequest) (*Operation, error)
	// Returns the specified TargetSslProxy resource.
	Get(context.Context, *GetTargetSslProxyRequest) (*TargetSslProxy, error)
	// Creates a TargetSslProxy resource in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertTargetSslProxyRequest) (*Operation, error)
	// Retrieves the list of TargetSslProxy resources
	// available to the specified project.
	List(context.Context, *ListTargetSslProxiesRequest) (*TargetSslProxyList, error)
	// Changes the BackendService for TargetSslProxy.
	SetBackendService(context.Context, *SetBackendServiceTargetSslProxyRequest) (*Operation, error)
	// Changes the Certificate Map for TargetSslProxy.
	SetCertificateMap(context.Context, *SetCertificateMapTargetSslProxyRequest) (*Operation, error)
	// Changes the ProxyHeaderType for TargetSslProxy.
	SetProxyHeader(context.Context, *SetProxyHeaderTargetSslProxyRequest) (*Operation, error)
	// Changes SslCertificates for TargetSslProxy.
	SetSslCertificates(context.Context, *SetSslCertificatesTargetSslProxyRequest) (*Operation, error)
	// Sets the SSL policy for TargetSslProxy. The SSL policy specifies the
	// server-side support for SSL features. This affects connections between
	// clients and the load balancer. They do not affect the
	// connection between the load balancer and the backends.
	SetSslPolicy(context.Context, *SetSslPolicyTargetSslProxyRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsTargetSslProxyRequest) (*TestPermissionsResponse, error)
}

// UnimplementedTargetSslProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedTargetSslProxiesServer struct {
}

func (UnimplementedTargetSslProxiesServer) Delete(context.Context, *DeleteTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetSslProxiesServer) Get(context.Context, *GetTargetSslProxyRequest) (*TargetSslProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetSslProxiesServer) Insert(context.Context, *InsertTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetSslProxiesServer) List(context.Context, *ListTargetSslProxiesRequest) (*TargetSslProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetSslProxiesServer) SetBackendService(context.Context, *SetBackendServiceTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBackendService not implemented")
}
func (UnimplementedTargetSslProxiesServer) SetCertificateMap(context.Context, *SetCertificateMapTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetCertificateMap not implemented")
}
func (UnimplementedTargetSslProxiesServer) SetProxyHeader(context.Context, *SetProxyHeaderTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProxyHeader not implemented")
}
func (UnimplementedTargetSslProxiesServer) SetSslCertificates(context.Context, *SetSslCertificatesTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSslCertificates not implemented")
}
func (UnimplementedTargetSslProxiesServer) SetSslPolicy(context.Context, *SetSslPolicyTargetSslProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetSslPolicy not implemented")
}
func (UnimplementedTargetSslProxiesServer) TestIamPermissions(context.Context, *TestIamPermissionsTargetSslProxyRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeTargetSslProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetSslProxiesServer will
// result in compilation errors.
type UnsafeTargetSslProxiesServer interface {
	mustEmbedUnimplementedTargetSslProxiesServer()
}

func RegisterTargetSslProxiesServer(s grpc.ServiceRegistrar, srv TargetSslProxiesServer) {
	s.RegisterService(&TargetSslProxies_ServiceDesc, srv)
}

func _TargetSslProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).Delete(ctx, req.(*DeleteTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).Get(ctx, req.(*GetTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).Insert(ctx, req.(*InsertTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetSslProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).List(ctx, req.(*ListTargetSslProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_SetBackendService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBackendServiceTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).SetBackendService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_SetBackendService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).SetBackendService(ctx, req.(*SetBackendServiceTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_SetCertificateMap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetCertificateMapTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).SetCertificateMap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_SetCertificateMap_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).SetCertificateMap(ctx, req.(*SetCertificateMapTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_SetProxyHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProxyHeaderTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).SetProxyHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_SetProxyHeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).SetProxyHeader(ctx, req.(*SetProxyHeaderTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_SetSslCertificates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSslCertificatesTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).SetSslCertificates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_SetSslCertificates_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).SetSslCertificates(ctx, req.(*SetSslCertificatesTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_SetSslPolicy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetSslPolicyTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).SetSslPolicy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_SetSslPolicy_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).SetSslPolicy(ctx, req.(*SetSslPolicyTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetSslProxies_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsTargetSslProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetSslProxiesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetSslProxies_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetSslProxiesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsTargetSslProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetSslProxies_ServiceDesc is the grpc.ServiceDesc for TargetSslProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetSslProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetSslProxies",
	HandlerType: (*TargetSslProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _TargetSslProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetSslProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetSslProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetSslProxies_List_Handler,
		},
		{
			MethodName: "SetBackendService",
			Handler:    _TargetSslProxies_SetBackendService_Handler,
		},
		{
			MethodName: "SetCertificateMap",
			Handler:    _TargetSslProxies_SetCertificateMap_Handler,
		},
		{
			MethodName: "SetProxyHeader",
			Handler:    _TargetSslProxies_SetProxyHeader_Handler,
		},
		{
			MethodName: "SetSslCertificates",
			Handler:    _TargetSslProxies_SetSslCertificates_Handler,
		},
		{
			MethodName: "SetSslPolicy",
			Handler:    _TargetSslProxies_SetSslPolicy_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _TargetSslProxies_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetTcpProxies_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.TargetTcpProxies/AggregatedList"
	TargetTcpProxies_Delete_FullMethodName             = "/google.cloud.compute.v1.TargetTcpProxies/Delete"
	TargetTcpProxies_Get_FullMethodName                = "/google.cloud.compute.v1.TargetTcpProxies/Get"
	TargetTcpProxies_Insert_FullMethodName             = "/google.cloud.compute.v1.TargetTcpProxies/Insert"
	TargetTcpProxies_List_FullMethodName               = "/google.cloud.compute.v1.TargetTcpProxies/List"
	TargetTcpProxies_SetBackendService_FullMethodName  = "/google.cloud.compute.v1.TargetTcpProxies/SetBackendService"
	TargetTcpProxies_SetProxyHeader_FullMethodName     = "/google.cloud.compute.v1.TargetTcpProxies/SetProxyHeader"
	TargetTcpProxies_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.TargetTcpProxies/TestIamPermissions"
)

// TargetTcpProxiesClient is the client API for TargetTcpProxies service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetTcpProxiesClient interface {
	// Retrieves the list of all TargetTcpProxy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListTargetTcpProxiesRequest, opts ...grpc.CallOption) (*TargetTcpProxyAggregatedList, error)
	// Deletes the specified TargetTcpProxy resource.
	Delete(ctx context.Context, in *DeleteTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified TargetTcpProxy resource.
	Get(ctx context.Context, in *GetTargetTcpProxyRequest, opts ...grpc.CallOption) (*TargetTcpProxy, error)
	// Creates a TargetTcpProxy resource in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of TargetTcpProxy resources
	// available to the specified project.
	List(ctx context.Context, in *ListTargetTcpProxiesRequest, opts ...grpc.CallOption) (*TargetTcpProxyList, error)
	// Changes the BackendService for TargetTcpProxy.
	SetBackendService(ctx context.Context, in *SetBackendServiceTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Changes the ProxyHeaderType for TargetTcpProxy.
	SetProxyHeader(ctx context.Context, in *SetProxyHeaderTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetTcpProxyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type targetTcpProxiesClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetTcpProxiesClient(cc grpc.ClientConnInterface) TargetTcpProxiesClient {
	return &targetTcpProxiesClient{cc}
}

func (c *targetTcpProxiesClient) AggregatedList(ctx context.Context, in *AggregatedListTargetTcpProxiesRequest, opts ...grpc.CallOption) (*TargetTcpProxyAggregatedList, error) {
	out := new(TargetTcpProxyAggregatedList)
	err := c.cc.Invoke(ctx, TargetTcpProxies_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) Delete(ctx context.Context, in *DeleteTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetTcpProxies_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) Get(ctx context.Context, in *GetTargetTcpProxyRequest, opts ...grpc.CallOption) (*TargetTcpProxy, error) {
	out := new(TargetTcpProxy)
	err := c.cc.Invoke(ctx, TargetTcpProxies_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) Insert(ctx context.Context, in *InsertTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetTcpProxies_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) List(ctx context.Context, in *ListTargetTcpProxiesRequest, opts ...grpc.CallOption) (*TargetTcpProxyList, error) {
	out := new(TargetTcpProxyList)
	err := c.cc.Invoke(ctx, TargetTcpProxies_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) SetBackendService(ctx context.Context, in *SetBackendServiceTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetTcpProxies_SetBackendService_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) SetProxyHeader(ctx context.Context, in *SetProxyHeaderTargetTcpProxyRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetTcpProxies_SetProxyHeader_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetTcpProxiesClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsTargetTcpProxyRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, TargetTcpProxies_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetTcpProxiesServer is the server API for TargetTcpProxies service.
// All implementations should embed UnimplementedTargetTcpProxiesServer
// for forward compatibility
type TargetTcpProxiesServer interface {
	// Retrieves the list of all TargetTcpProxy resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListTargetTcpProxiesRequest) (*TargetTcpProxyAggregatedList, error)
	// Deletes the specified TargetTcpProxy resource.
	Delete(context.Context, *DeleteTargetTcpProxyRequest) (*Operation, error)
	// Returns the specified TargetTcpProxy resource.
	Get(context.Context, *GetTargetTcpProxyRequest) (*TargetTcpProxy, error)
	// Creates a TargetTcpProxy resource in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertTargetTcpProxyRequest) (*Operation, error)
	// Retrieves the list of TargetTcpProxy resources
	// available to the specified project.
	List(context.Context, *ListTargetTcpProxiesRequest) (*TargetTcpProxyList, error)
	// Changes the BackendService for TargetTcpProxy.
	SetBackendService(context.Context, *SetBackendServiceTargetTcpProxyRequest) (*Operation, error)
	// Changes the ProxyHeaderType for TargetTcpProxy.
	SetProxyHeader(context.Context, *SetProxyHeaderTargetTcpProxyRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsTargetTcpProxyRequest) (*TestPermissionsResponse, error)
}

// UnimplementedTargetTcpProxiesServer should be embedded to have forward compatible implementations.
type UnimplementedTargetTcpProxiesServer struct {
}

func (UnimplementedTargetTcpProxiesServer) AggregatedList(context.Context, *AggregatedListTargetTcpProxiesRequest) (*TargetTcpProxyAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedTargetTcpProxiesServer) Delete(context.Context, *DeleteTargetTcpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetTcpProxiesServer) Get(context.Context, *GetTargetTcpProxyRequest) (*TargetTcpProxy, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetTcpProxiesServer) Insert(context.Context, *InsertTargetTcpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetTcpProxiesServer) List(context.Context, *ListTargetTcpProxiesRequest) (*TargetTcpProxyList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetTcpProxiesServer) SetBackendService(context.Context, *SetBackendServiceTargetTcpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetBackendService not implemented")
}
func (UnimplementedTargetTcpProxiesServer) SetProxyHeader(context.Context, *SetProxyHeaderTargetTcpProxyRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetProxyHeader not implemented")
}
func (UnimplementedTargetTcpProxiesServer) TestIamPermissions(context.Context, *TestIamPermissionsTargetTcpProxyRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeTargetTcpProxiesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetTcpProxiesServer will
// result in compilation errors.
type UnsafeTargetTcpProxiesServer interface {
	mustEmbedUnimplementedTargetTcpProxiesServer()
}

func RegisterTargetTcpProxiesServer(s grpc.ServiceRegistrar, srv TargetTcpProxiesServer) {
	s.RegisterService(&TargetTcpProxies_ServiceDesc, srv)
}

func _TargetTcpProxies_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListTargetTcpProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).AggregatedList(ctx, req.(*AggregatedListTargetTcpProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).Delete(ctx, req.(*DeleteTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).Get(ctx, req.(*GetTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).Insert(ctx, req.(*InsertTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetTcpProxiesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).List(ctx, req.(*ListTargetTcpProxiesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_SetBackendService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetBackendServiceTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).SetBackendService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_SetBackendService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).SetBackendService(ctx, req.(*SetBackendServiceTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_SetProxyHeader_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetProxyHeaderTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).SetProxyHeader(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_SetProxyHeader_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).SetProxyHeader(ctx, req.(*SetProxyHeaderTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetTcpProxies_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsTargetTcpProxyRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetTcpProxiesServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetTcpProxies_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetTcpProxiesServer).TestIamPermissions(ctx, req.(*TestIamPermissionsTargetTcpProxyRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetTcpProxies_ServiceDesc is the grpc.ServiceDesc for TargetTcpProxies service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetTcpProxies_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetTcpProxies",
	HandlerType: (*TargetTcpProxiesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _TargetTcpProxies_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TargetTcpProxies_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetTcpProxies_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetTcpProxies_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetTcpProxies_List_Handler,
		},
		{
			MethodName: "SetBackendService",
			Handler:    _TargetTcpProxies_SetBackendService_Handler,
		},
		{
			MethodName: "SetProxyHeader",
			Handler:    _TargetTcpProxies_SetProxyHeader_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _TargetTcpProxies_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	TargetVpnGateways_AggregatedList_FullMethodName = "/google.cloud.compute.v1.TargetVpnGateways/AggregatedList"
	TargetVpnGateways_Delete_FullMethodName         = "/google.cloud.compute.v1.TargetVpnGateways/Delete"
	TargetVpnGateways_Get_FullMethodName            = "/google.cloud.compute.v1.TargetVpnGateways/Get"
	TargetVpnGateways_Insert_FullMethodName         = "/google.cloud.compute.v1.TargetVpnGateways/Insert"
	TargetVpnGateways_List_FullMethodName           = "/google.cloud.compute.v1.TargetVpnGateways/List"
	TargetVpnGateways_SetLabels_FullMethodName      = "/google.cloud.compute.v1.TargetVpnGateways/SetLabels"
)

// TargetVpnGatewaysClient is the client API for TargetVpnGateways service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type TargetVpnGatewaysClient interface {
	// Retrieves an aggregated list of target VPN gateways.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListTargetVpnGatewaysRequest, opts ...grpc.CallOption) (*TargetVpnGatewayAggregatedList, error)
	// Deletes the specified target VPN gateway.
	Delete(ctx context.Context, in *DeleteTargetVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified target VPN gateway.
	Get(ctx context.Context, in *GetTargetVpnGatewayRequest, opts ...grpc.CallOption) (*TargetVpnGateway, error)
	// Creates a target VPN gateway in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertTargetVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of target VPN gateways available to the specified
	// project and region.
	List(ctx context.Context, in *ListTargetVpnGatewaysRequest, opts ...grpc.CallOption) (*TargetVpnGatewayList, error)
	// Sets the labels on a TargetVpnGateway. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsTargetVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
}

type targetVpnGatewaysClient struct {
	cc grpc.ClientConnInterface
}

func NewTargetVpnGatewaysClient(cc grpc.ClientConnInterface) TargetVpnGatewaysClient {
	return &targetVpnGatewaysClient{cc}
}

func (c *targetVpnGatewaysClient) AggregatedList(ctx context.Context, in *AggregatedListTargetVpnGatewaysRequest, opts ...grpc.CallOption) (*TargetVpnGatewayAggregatedList, error) {
	out := new(TargetVpnGatewayAggregatedList)
	err := c.cc.Invoke(ctx, TargetVpnGateways_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetVpnGatewaysClient) Delete(ctx context.Context, in *DeleteTargetVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetVpnGateways_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetVpnGatewaysClient) Get(ctx context.Context, in *GetTargetVpnGatewayRequest, opts ...grpc.CallOption) (*TargetVpnGateway, error) {
	out := new(TargetVpnGateway)
	err := c.cc.Invoke(ctx, TargetVpnGateways_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetVpnGatewaysClient) Insert(ctx context.Context, in *InsertTargetVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetVpnGateways_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetVpnGatewaysClient) List(ctx context.Context, in *ListTargetVpnGatewaysRequest, opts ...grpc.CallOption) (*TargetVpnGatewayList, error) {
	out := new(TargetVpnGatewayList)
	err := c.cc.Invoke(ctx, TargetVpnGateways_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *targetVpnGatewaysClient) SetLabels(ctx context.Context, in *SetLabelsTargetVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, TargetVpnGateways_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// TargetVpnGatewaysServer is the server API for TargetVpnGateways service.
// All implementations should embed UnimplementedTargetVpnGatewaysServer
// for forward compatibility
type TargetVpnGatewaysServer interface {
	// Retrieves an aggregated list of target VPN gateways.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListTargetVpnGatewaysRequest) (*TargetVpnGatewayAggregatedList, error)
	// Deletes the specified target VPN gateway.
	Delete(context.Context, *DeleteTargetVpnGatewayRequest) (*Operation, error)
	// Returns the specified target VPN gateway.
	Get(context.Context, *GetTargetVpnGatewayRequest) (*TargetVpnGateway, error)
	// Creates a target VPN gateway in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertTargetVpnGatewayRequest) (*Operation, error)
	// Retrieves a list of target VPN gateways available to the specified
	// project and region.
	List(context.Context, *ListTargetVpnGatewaysRequest) (*TargetVpnGatewayList, error)
	// Sets the labels on a TargetVpnGateway. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsTargetVpnGatewayRequest) (*Operation, error)
}

// UnimplementedTargetVpnGatewaysServer should be embedded to have forward compatible implementations.
type UnimplementedTargetVpnGatewaysServer struct {
}

func (UnimplementedTargetVpnGatewaysServer) AggregatedList(context.Context, *AggregatedListTargetVpnGatewaysRequest) (*TargetVpnGatewayAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedTargetVpnGatewaysServer) Delete(context.Context, *DeleteTargetVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedTargetVpnGatewaysServer) Get(context.Context, *GetTargetVpnGatewayRequest) (*TargetVpnGateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedTargetVpnGatewaysServer) Insert(context.Context, *InsertTargetVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedTargetVpnGatewaysServer) List(context.Context, *ListTargetVpnGatewaysRequest) (*TargetVpnGatewayList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedTargetVpnGatewaysServer) SetLabels(context.Context, *SetLabelsTargetVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}

// UnsafeTargetVpnGatewaysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to TargetVpnGatewaysServer will
// result in compilation errors.
type UnsafeTargetVpnGatewaysServer interface {
	mustEmbedUnimplementedTargetVpnGatewaysServer()
}

func RegisterTargetVpnGatewaysServer(s grpc.ServiceRegistrar, srv TargetVpnGatewaysServer) {
	s.RegisterService(&TargetVpnGateways_ServiceDesc, srv)
}

func _TargetVpnGateways_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListTargetVpnGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetVpnGatewaysServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetVpnGateways_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetVpnGatewaysServer).AggregatedList(ctx, req.(*AggregatedListTargetVpnGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetVpnGateways_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteTargetVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetVpnGatewaysServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetVpnGateways_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetVpnGatewaysServer).Delete(ctx, req.(*DeleteTargetVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetVpnGateways_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetTargetVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetVpnGatewaysServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetVpnGateways_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetVpnGatewaysServer).Get(ctx, req.(*GetTargetVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetVpnGateways_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertTargetVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetVpnGatewaysServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetVpnGateways_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetVpnGatewaysServer).Insert(ctx, req.(*InsertTargetVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetVpnGateways_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListTargetVpnGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetVpnGatewaysServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetVpnGateways_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetVpnGatewaysServer).List(ctx, req.(*ListTargetVpnGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _TargetVpnGateways_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsTargetVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TargetVpnGatewaysServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: TargetVpnGateways_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TargetVpnGatewaysServer).SetLabels(ctx, req.(*SetLabelsTargetVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// TargetVpnGateways_ServiceDesc is the grpc.ServiceDesc for TargetVpnGateways service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var TargetVpnGateways_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.TargetVpnGateways",
	HandlerType: (*TargetVpnGatewaysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _TargetVpnGateways_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _TargetVpnGateways_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _TargetVpnGateways_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _TargetVpnGateways_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _TargetVpnGateways_List_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _TargetVpnGateways_SetLabels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	UrlMaps_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.UrlMaps/AggregatedList"
	UrlMaps_Delete_FullMethodName             = "/google.cloud.compute.v1.UrlMaps/Delete"
	UrlMaps_Get_FullMethodName                = "/google.cloud.compute.v1.UrlMaps/Get"
	UrlMaps_Insert_FullMethodName             = "/google.cloud.compute.v1.UrlMaps/Insert"
	UrlMaps_InvalidateCache_FullMethodName    = "/google.cloud.compute.v1.UrlMaps/InvalidateCache"
	UrlMaps_List_FullMethodName               = "/google.cloud.compute.v1.UrlMaps/List"
	UrlMaps_Patch_FullMethodName              = "/google.cloud.compute.v1.UrlMaps/Patch"
	UrlMaps_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.UrlMaps/TestIamPermissions"
	UrlMaps_Update_FullMethodName             = "/google.cloud.compute.v1.UrlMaps/Update"
	UrlMaps_Validate_FullMethodName           = "/google.cloud.compute.v1.UrlMaps/Validate"
)

// UrlMapsClient is the client API for UrlMaps service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type UrlMapsClient interface {
	// Retrieves the list of all UrlMap resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListUrlMapsRequest, opts ...grpc.CallOption) (*UrlMapsAggregatedList, error)
	// Deletes the specified UrlMap resource.
	Delete(ctx context.Context, in *DeleteUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified UrlMap resource.
	Get(ctx context.Context, in *GetUrlMapRequest, opts ...grpc.CallOption) (*UrlMap, error)
	// Creates a UrlMap resource in the specified project using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Initiates a cache invalidation operation, invalidating the specified path,
	// scoped to the specified UrlMap.
	//
	// For more information, see [Invalidating cached
	// content](/cdn/docs/invalidating-cached-content).
	InvalidateCache(ctx context.Context, in *InvalidateCacheUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves the list of UrlMap resources available to the specified
	// project.
	List(ctx context.Context, in *ListUrlMapsRequest, opts ...grpc.CallOption) (*UrlMapList, error)
	// Patches the specified UrlMap resource with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsUrlMapRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
	// Updates the specified UrlMap resource with the data included in the
	// request.
	Update(ctx context.Context, in *UpdateUrlMapRequest, opts ...grpc.CallOption) (*Operation, error)
	// Runs static validation for the UrlMap. In particular, the tests of the
	// provided UrlMap will be run. Calling this method does NOT create the
	// UrlMap.
	Validate(ctx context.Context, in *ValidateUrlMapRequest, opts ...grpc.CallOption) (*UrlMapsValidateResponse, error)
}

type urlMapsClient struct {
	cc grpc.ClientConnInterface
}

func NewUrlMapsClient(cc grpc.ClientConnInterface) UrlMapsClient {
	return &urlMapsClient{cc}
}

func (c *urlMapsClient) AggregatedList(ctx context.Context, in *AggregatedListUrlMapsRequest, opts ...grpc.CallOption) (*UrlMapsAggregatedList, error) {
	out := new(UrlMapsAggregatedList)
	err := c.cc.Invoke(ctx, UrlMaps_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) Delete(ctx context.Context, in *DeleteUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, UrlMaps_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) Get(ctx context.Context, in *GetUrlMapRequest, opts ...grpc.CallOption) (*UrlMap, error) {
	out := new(UrlMap)
	err := c.cc.Invoke(ctx, UrlMaps_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) Insert(ctx context.Context, in *InsertUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, UrlMaps_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) InvalidateCache(ctx context.Context, in *InvalidateCacheUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, UrlMaps_InvalidateCache_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) List(ctx context.Context, in *ListUrlMapsRequest, opts ...grpc.CallOption) (*UrlMapList, error) {
	out := new(UrlMapList)
	err := c.cc.Invoke(ctx, UrlMaps_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) Patch(ctx context.Context, in *PatchUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, UrlMaps_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsUrlMapRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, UrlMaps_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) Update(ctx context.Context, in *UpdateUrlMapRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, UrlMaps_Update_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *urlMapsClient) Validate(ctx context.Context, in *ValidateUrlMapRequest, opts ...grpc.CallOption) (*UrlMapsValidateResponse, error) {
	out := new(UrlMapsValidateResponse)
	err := c.cc.Invoke(ctx, UrlMaps_Validate_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// UrlMapsServer is the server API for UrlMaps service.
// All implementations should embed UnimplementedUrlMapsServer
// for forward compatibility
type UrlMapsServer interface {
	// Retrieves the list of all UrlMap resources, regional and global,
	// available to the specified project.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListUrlMapsRequest) (*UrlMapsAggregatedList, error)
	// Deletes the specified UrlMap resource.
	Delete(context.Context, *DeleteUrlMapRequest) (*Operation, error)
	// Returns the specified UrlMap resource.
	Get(context.Context, *GetUrlMapRequest) (*UrlMap, error)
	// Creates a UrlMap resource in the specified project using
	// the data included in the request.
	Insert(context.Context, *InsertUrlMapRequest) (*Operation, error)
	// Initiates a cache invalidation operation, invalidating the specified path,
	// scoped to the specified UrlMap.
	//
	// For more information, see [Invalidating cached
	// content](/cdn/docs/invalidating-cached-content).
	InvalidateCache(context.Context, *InvalidateCacheUrlMapRequest) (*Operation, error)
	// Retrieves the list of UrlMap resources available to the specified
	// project.
	List(context.Context, *ListUrlMapsRequest) (*UrlMapList, error)
	// Patches the specified UrlMap resource with the data included in the
	// request. This method supportsPATCH
	// semantics and uses theJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchUrlMapRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsUrlMapRequest) (*TestPermissionsResponse, error)
	// Updates the specified UrlMap resource with the data included in the
	// request.
	Update(context.Context, *UpdateUrlMapRequest) (*Operation, error)
	// Runs static validation for the UrlMap. In particular, the tests of the
	// provided UrlMap will be run. Calling this method does NOT create the
	// UrlMap.
	Validate(context.Context, *ValidateUrlMapRequest) (*UrlMapsValidateResponse, error)
}

// UnimplementedUrlMapsServer should be embedded to have forward compatible implementations.
type UnimplementedUrlMapsServer struct {
}

func (UnimplementedUrlMapsServer) AggregatedList(context.Context, *AggregatedListUrlMapsRequest) (*UrlMapsAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedUrlMapsServer) Delete(context.Context, *DeleteUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedUrlMapsServer) Get(context.Context, *GetUrlMapRequest) (*UrlMap, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedUrlMapsServer) Insert(context.Context, *InsertUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedUrlMapsServer) InvalidateCache(context.Context, *InvalidateCacheUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InvalidateCache not implemented")
}
func (UnimplementedUrlMapsServer) List(context.Context, *ListUrlMapsRequest) (*UrlMapList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedUrlMapsServer) Patch(context.Context, *PatchUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}
func (UnimplementedUrlMapsServer) TestIamPermissions(context.Context, *TestIamPermissionsUrlMapRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}
func (UnimplementedUrlMapsServer) Update(context.Context, *UpdateUrlMapRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Update not implemented")
}
func (UnimplementedUrlMapsServer) Validate(context.Context, *ValidateUrlMapRequest) (*UrlMapsValidateResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Validate not implemented")
}

// UnsafeUrlMapsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to UrlMapsServer will
// result in compilation errors.
type UnsafeUrlMapsServer interface {
	mustEmbedUnimplementedUrlMapsServer()
}

func RegisterUrlMapsServer(s grpc.ServiceRegistrar, srv UrlMapsServer) {
	s.RegisterService(&UrlMaps_ServiceDesc, srv)
}

func _UrlMaps_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListUrlMapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).AggregatedList(ctx, req.(*AggregatedListUrlMapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).Delete(ctx, req.(*DeleteUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).Get(ctx, req.(*GetUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).Insert(ctx, req.(*InsertUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_InvalidateCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InvalidateCacheUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).InvalidateCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_InvalidateCache_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).InvalidateCache(ctx, req.(*InvalidateCacheUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListUrlMapsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).List(ctx, req.(*ListUrlMapsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).Patch(ctx, req.(*PatchUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).TestIamPermissions(ctx, req.(*TestIamPermissionsUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_Update_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).Update(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_Update_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).Update(ctx, req.(*UpdateUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _UrlMaps_Validate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateUrlMapRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(UrlMapsServer).Validate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: UrlMaps_Validate_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(UrlMapsServer).Validate(ctx, req.(*ValidateUrlMapRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// UrlMaps_ServiceDesc is the grpc.ServiceDesc for UrlMaps service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var UrlMaps_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.UrlMaps",
	HandlerType: (*UrlMapsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _UrlMaps_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _UrlMaps_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _UrlMaps_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _UrlMaps_Insert_Handler,
		},
		{
			MethodName: "InvalidateCache",
			Handler:    _UrlMaps_InvalidateCache_Handler,
		},
		{
			MethodName: "List",
			Handler:    _UrlMaps_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _UrlMaps_Patch_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _UrlMaps_TestIamPermissions_Handler,
		},
		{
			MethodName: "Update",
			Handler:    _UrlMaps_Update_Handler,
		},
		{
			MethodName: "Validate",
			Handler:    _UrlMaps_Validate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	VpnGateways_AggregatedList_FullMethodName     = "/google.cloud.compute.v1.VpnGateways/AggregatedList"
	VpnGateways_Delete_FullMethodName             = "/google.cloud.compute.v1.VpnGateways/Delete"
	VpnGateways_Get_FullMethodName                = "/google.cloud.compute.v1.VpnGateways/Get"
	VpnGateways_GetStatus_FullMethodName          = "/google.cloud.compute.v1.VpnGateways/GetStatus"
	VpnGateways_Insert_FullMethodName             = "/google.cloud.compute.v1.VpnGateways/Insert"
	VpnGateways_List_FullMethodName               = "/google.cloud.compute.v1.VpnGateways/List"
	VpnGateways_SetLabels_FullMethodName          = "/google.cloud.compute.v1.VpnGateways/SetLabels"
	VpnGateways_TestIamPermissions_FullMethodName = "/google.cloud.compute.v1.VpnGateways/TestIamPermissions"
)

// VpnGatewaysClient is the client API for VpnGateways service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VpnGatewaysClient interface {
	// Retrieves an aggregated list of VPN gateways.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListVpnGatewaysRequest, opts ...grpc.CallOption) (*VpnGatewayAggregatedList, error)
	// Deletes the specified VPN gateway.
	Delete(ctx context.Context, in *DeleteVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified VPN gateway.
	Get(ctx context.Context, in *GetVpnGatewayRequest, opts ...grpc.CallOption) (*VpnGateway, error)
	// Returns the status for the specified VPN gateway.
	GetStatus(ctx context.Context, in *GetStatusVpnGatewayRequest, opts ...grpc.CallOption) (*VpnGatewaysGetStatusResponse, error)
	// Creates a VPN gateway in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of VPN gateways available to the specified
	// project and region.
	List(ctx context.Context, in *ListVpnGatewaysRequest, opts ...grpc.CallOption) (*VpnGatewayList, error)
	// Sets the labels on a VpnGateway. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(ctx context.Context, in *TestIamPermissionsVpnGatewayRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error)
}

type vpnGatewaysClient struct {
	cc grpc.ClientConnInterface
}

func NewVpnGatewaysClient(cc grpc.ClientConnInterface) VpnGatewaysClient {
	return &vpnGatewaysClient{cc}
}

func (c *vpnGatewaysClient) AggregatedList(ctx context.Context, in *AggregatedListVpnGatewaysRequest, opts ...grpc.CallOption) (*VpnGatewayAggregatedList, error) {
	out := new(VpnGatewayAggregatedList)
	err := c.cc.Invoke(ctx, VpnGateways_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) Delete(ctx context.Context, in *DeleteVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, VpnGateways_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) Get(ctx context.Context, in *GetVpnGatewayRequest, opts ...grpc.CallOption) (*VpnGateway, error) {
	out := new(VpnGateway)
	err := c.cc.Invoke(ctx, VpnGateways_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) GetStatus(ctx context.Context, in *GetStatusVpnGatewayRequest, opts ...grpc.CallOption) (*VpnGatewaysGetStatusResponse, error) {
	out := new(VpnGatewaysGetStatusResponse)
	err := c.cc.Invoke(ctx, VpnGateways_GetStatus_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) Insert(ctx context.Context, in *InsertVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, VpnGateways_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) List(ctx context.Context, in *ListVpnGatewaysRequest, opts ...grpc.CallOption) (*VpnGatewayList, error) {
	out := new(VpnGatewayList)
	err := c.cc.Invoke(ctx, VpnGateways_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) SetLabels(ctx context.Context, in *SetLabelsVpnGatewayRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, VpnGateways_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnGatewaysClient) TestIamPermissions(ctx context.Context, in *TestIamPermissionsVpnGatewayRequest, opts ...grpc.CallOption) (*TestPermissionsResponse, error) {
	out := new(TestPermissionsResponse)
	err := c.cc.Invoke(ctx, VpnGateways_TestIamPermissions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VpnGatewaysServer is the server API for VpnGateways service.
// All implementations should embed UnimplementedVpnGatewaysServer
// for forward compatibility
type VpnGatewaysServer interface {
	// Retrieves an aggregated list of VPN gateways.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListVpnGatewaysRequest) (*VpnGatewayAggregatedList, error)
	// Deletes the specified VPN gateway.
	Delete(context.Context, *DeleteVpnGatewayRequest) (*Operation, error)
	// Returns the specified VPN gateway.
	Get(context.Context, *GetVpnGatewayRequest) (*VpnGateway, error)
	// Returns the status for the specified VPN gateway.
	GetStatus(context.Context, *GetStatusVpnGatewayRequest) (*VpnGatewaysGetStatusResponse, error)
	// Creates a VPN gateway in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertVpnGatewayRequest) (*Operation, error)
	// Retrieves a list of VPN gateways available to the specified
	// project and region.
	List(context.Context, *ListVpnGatewaysRequest) (*VpnGatewayList, error)
	// Sets the labels on a VpnGateway. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsVpnGatewayRequest) (*Operation, error)
	// Returns permissions that a caller has on the specified resource.
	TestIamPermissions(context.Context, *TestIamPermissionsVpnGatewayRequest) (*TestPermissionsResponse, error)
}

// UnimplementedVpnGatewaysServer should be embedded to have forward compatible implementations.
type UnimplementedVpnGatewaysServer struct {
}

func (UnimplementedVpnGatewaysServer) AggregatedList(context.Context, *AggregatedListVpnGatewaysRequest) (*VpnGatewayAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedVpnGatewaysServer) Delete(context.Context, *DeleteVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedVpnGatewaysServer) Get(context.Context, *GetVpnGatewayRequest) (*VpnGateway, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedVpnGatewaysServer) GetStatus(context.Context, *GetStatusVpnGatewayRequest) (*VpnGatewaysGetStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatus not implemented")
}
func (UnimplementedVpnGatewaysServer) Insert(context.Context, *InsertVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedVpnGatewaysServer) List(context.Context, *ListVpnGatewaysRequest) (*VpnGatewayList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedVpnGatewaysServer) SetLabels(context.Context, *SetLabelsVpnGatewayRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}
func (UnimplementedVpnGatewaysServer) TestIamPermissions(context.Context, *TestIamPermissionsVpnGatewayRequest) (*TestPermissionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method TestIamPermissions not implemented")
}

// UnsafeVpnGatewaysServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VpnGatewaysServer will
// result in compilation errors.
type UnsafeVpnGatewaysServer interface {
	mustEmbedUnimplementedVpnGatewaysServer()
}

func RegisterVpnGatewaysServer(s grpc.ServiceRegistrar, srv VpnGatewaysServer) {
	s.RegisterService(&VpnGateways_ServiceDesc, srv)
}

func _VpnGateways_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListVpnGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).AggregatedList(ctx, req.(*AggregatedListVpnGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).Delete(ctx, req.(*DeleteVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).Get(ctx, req.(*GetVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_GetStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetStatusVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).GetStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_GetStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).GetStatus(ctx, req.(*GetStatusVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).Insert(ctx, req.(*InsertVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVpnGatewaysRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).List(ctx, req.(*ListVpnGatewaysRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).SetLabels(ctx, req.(*SetLabelsVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnGateways_TestIamPermissions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TestIamPermissionsVpnGatewayRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnGatewaysServer).TestIamPermissions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnGateways_TestIamPermissions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnGatewaysServer).TestIamPermissions(ctx, req.(*TestIamPermissionsVpnGatewayRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VpnGateways_ServiceDesc is the grpc.ServiceDesc for VpnGateways service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VpnGateways_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.VpnGateways",
	HandlerType: (*VpnGatewaysServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _VpnGateways_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VpnGateways_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _VpnGateways_Get_Handler,
		},
		{
			MethodName: "GetStatus",
			Handler:    _VpnGateways_GetStatus_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _VpnGateways_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _VpnGateways_List_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _VpnGateways_SetLabels_Handler,
		},
		{
			MethodName: "TestIamPermissions",
			Handler:    _VpnGateways_TestIamPermissions_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	VpnTunnels_AggregatedList_FullMethodName = "/google.cloud.compute.v1.VpnTunnels/AggregatedList"
	VpnTunnels_Delete_FullMethodName         = "/google.cloud.compute.v1.VpnTunnels/Delete"
	VpnTunnels_Get_FullMethodName            = "/google.cloud.compute.v1.VpnTunnels/Get"
	VpnTunnels_Insert_FullMethodName         = "/google.cloud.compute.v1.VpnTunnels/Insert"
	VpnTunnels_List_FullMethodName           = "/google.cloud.compute.v1.VpnTunnels/List"
	VpnTunnels_SetLabels_FullMethodName      = "/google.cloud.compute.v1.VpnTunnels/SetLabels"
)

// VpnTunnelsClient is the client API for VpnTunnels service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VpnTunnelsClient interface {
	// Retrieves an aggregated list of VPN tunnels.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(ctx context.Context, in *AggregatedListVpnTunnelsRequest, opts ...grpc.CallOption) (*VpnTunnelAggregatedList, error)
	// Deletes the specified VpnTunnel resource.
	Delete(ctx context.Context, in *DeleteVpnTunnelRequest, opts ...grpc.CallOption) (*Operation, error)
	// Returns the specified VpnTunnel resource.
	Get(ctx context.Context, in *GetVpnTunnelRequest, opts ...grpc.CallOption) (*VpnTunnel, error)
	// Creates a VpnTunnel resource in the specified project and region using
	// the data included in the request.
	Insert(ctx context.Context, in *InsertVpnTunnelRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of VpnTunnel resources contained in the specified
	// project and region.
	List(ctx context.Context, in *ListVpnTunnelsRequest, opts ...grpc.CallOption) (*VpnTunnelList, error)
	// Sets the labels on a VpnTunnel. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(ctx context.Context, in *SetLabelsVpnTunnelRequest, opts ...grpc.CallOption) (*Operation, error)
}

type vpnTunnelsClient struct {
	cc grpc.ClientConnInterface
}

func NewVpnTunnelsClient(cc grpc.ClientConnInterface) VpnTunnelsClient {
	return &vpnTunnelsClient{cc}
}

func (c *vpnTunnelsClient) AggregatedList(ctx context.Context, in *AggregatedListVpnTunnelsRequest, opts ...grpc.CallOption) (*VpnTunnelAggregatedList, error) {
	out := new(VpnTunnelAggregatedList)
	err := c.cc.Invoke(ctx, VpnTunnels_AggregatedList_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnTunnelsClient) Delete(ctx context.Context, in *DeleteVpnTunnelRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, VpnTunnels_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnTunnelsClient) Get(ctx context.Context, in *GetVpnTunnelRequest, opts ...grpc.CallOption) (*VpnTunnel, error) {
	out := new(VpnTunnel)
	err := c.cc.Invoke(ctx, VpnTunnels_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnTunnelsClient) Insert(ctx context.Context, in *InsertVpnTunnelRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, VpnTunnels_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnTunnelsClient) List(ctx context.Context, in *ListVpnTunnelsRequest, opts ...grpc.CallOption) (*VpnTunnelList, error) {
	out := new(VpnTunnelList)
	err := c.cc.Invoke(ctx, VpnTunnels_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vpnTunnelsClient) SetLabels(ctx context.Context, in *SetLabelsVpnTunnelRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, VpnTunnels_SetLabels_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VpnTunnelsServer is the server API for VpnTunnels service.
// All implementations should embed UnimplementedVpnTunnelsServer
// for forward compatibility
type VpnTunnelsServer interface {
	// Retrieves an aggregated list of VPN tunnels.
	//
	// To prevent failure, Google recommends that you set the
	// `returnPartialSuccess` parameter to `true`.
	AggregatedList(context.Context, *AggregatedListVpnTunnelsRequest) (*VpnTunnelAggregatedList, error)
	// Deletes the specified VpnTunnel resource.
	Delete(context.Context, *DeleteVpnTunnelRequest) (*Operation, error)
	// Returns the specified VpnTunnel resource.
	Get(context.Context, *GetVpnTunnelRequest) (*VpnTunnel, error)
	// Creates a VpnTunnel resource in the specified project and region using
	// the data included in the request.
	Insert(context.Context, *InsertVpnTunnelRequest) (*Operation, error)
	// Retrieves a list of VpnTunnel resources contained in the specified
	// project and region.
	List(context.Context, *ListVpnTunnelsRequest) (*VpnTunnelList, error)
	// Sets the labels on a VpnTunnel. To learn more about labels, read theLabeling
	// Resources documentation.
	SetLabels(context.Context, *SetLabelsVpnTunnelRequest) (*Operation, error)
}

// UnimplementedVpnTunnelsServer should be embedded to have forward compatible implementations.
type UnimplementedVpnTunnelsServer struct {
}

func (UnimplementedVpnTunnelsServer) AggregatedList(context.Context, *AggregatedListVpnTunnelsRequest) (*VpnTunnelAggregatedList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregatedList not implemented")
}
func (UnimplementedVpnTunnelsServer) Delete(context.Context, *DeleteVpnTunnelRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedVpnTunnelsServer) Get(context.Context, *GetVpnTunnelRequest) (*VpnTunnel, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedVpnTunnelsServer) Insert(context.Context, *InsertVpnTunnelRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedVpnTunnelsServer) List(context.Context, *ListVpnTunnelsRequest) (*VpnTunnelList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedVpnTunnelsServer) SetLabels(context.Context, *SetLabelsVpnTunnelRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetLabels not implemented")
}

// UnsafeVpnTunnelsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to VpnTunnelsServer will
// result in compilation errors.
type UnsafeVpnTunnelsServer interface {
	mustEmbedUnimplementedVpnTunnelsServer()
}

func RegisterVpnTunnelsServer(s grpc.ServiceRegistrar, srv VpnTunnelsServer) {
	s.RegisterService(&VpnTunnels_ServiceDesc, srv)
}

func _VpnTunnels_AggregatedList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregatedListVpnTunnelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnTunnelsServer).AggregatedList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnTunnels_AggregatedList_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnTunnelsServer).AggregatedList(ctx, req.(*AggregatedListVpnTunnelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnTunnels_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteVpnTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnTunnelsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnTunnels_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnTunnelsServer).Delete(ctx, req.(*DeleteVpnTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnTunnels_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetVpnTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnTunnelsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnTunnels_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnTunnelsServer).Get(ctx, req.(*GetVpnTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnTunnels_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertVpnTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnTunnelsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnTunnels_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnTunnelsServer).Insert(ctx, req.(*InsertVpnTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnTunnels_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVpnTunnelsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnTunnelsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnTunnels_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnTunnelsServer).List(ctx, req.(*ListVpnTunnelsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VpnTunnels_SetLabels_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetLabelsVpnTunnelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VpnTunnelsServer).SetLabels(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: VpnTunnels_SetLabels_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VpnTunnelsServer).SetLabels(ctx, req.(*SetLabelsVpnTunnelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// VpnTunnels_ServiceDesc is the grpc.ServiceDesc for VpnTunnels service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var VpnTunnels_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.VpnTunnels",
	HandlerType: (*VpnTunnelsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "AggregatedList",
			Handler:    _VpnTunnels_AggregatedList_Handler,
		},
		{
			MethodName: "Delete",
			Handler:    _VpnTunnels_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _VpnTunnels_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _VpnTunnels_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _VpnTunnels_List_Handler,
		},
		{
			MethodName: "SetLabels",
			Handler:    _VpnTunnels_SetLabels_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	WireGroups_Delete_FullMethodName = "/google.cloud.compute.v1.WireGroups/Delete"
	WireGroups_Get_FullMethodName    = "/google.cloud.compute.v1.WireGroups/Get"
	WireGroups_Insert_FullMethodName = "/google.cloud.compute.v1.WireGroups/Insert"
	WireGroups_List_FullMethodName   = "/google.cloud.compute.v1.WireGroups/List"
	WireGroups_Patch_FullMethodName  = "/google.cloud.compute.v1.WireGroups/Patch"
)

// WireGroupsClient is the client API for WireGroups service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type WireGroupsClient interface {
	// Deletes the specified wire group in the given scope.
	Delete(ctx context.Context, in *DeleteWireGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Gets the specified wire group resource in the given scope.
	Get(ctx context.Context, in *GetWireGroupRequest, opts ...grpc.CallOption) (*WireGroup, error)
	// Creates a wire group in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(ctx context.Context, in *InsertWireGroupRequest, opts ...grpc.CallOption) (*Operation, error)
	// Lists the wire groups for a project in the given scope.
	List(ctx context.Context, in *ListWireGroupsRequest, opts ...grpc.CallOption) (*WireGroupList, error)
	// Updates the specified wire group resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(ctx context.Context, in *PatchWireGroupRequest, opts ...grpc.CallOption) (*Operation, error)
}

type wireGroupsClient struct {
	cc grpc.ClientConnInterface
}

func NewWireGroupsClient(cc grpc.ClientConnInterface) WireGroupsClient {
	return &wireGroupsClient{cc}
}

func (c *wireGroupsClient) Delete(ctx context.Context, in *DeleteWireGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, WireGroups_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wireGroupsClient) Get(ctx context.Context, in *GetWireGroupRequest, opts ...grpc.CallOption) (*WireGroup, error) {
	out := new(WireGroup)
	err := c.cc.Invoke(ctx, WireGroups_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wireGroupsClient) Insert(ctx context.Context, in *InsertWireGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, WireGroups_Insert_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wireGroupsClient) List(ctx context.Context, in *ListWireGroupsRequest, opts ...grpc.CallOption) (*WireGroupList, error) {
	out := new(WireGroupList)
	err := c.cc.Invoke(ctx, WireGroups_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *wireGroupsClient) Patch(ctx context.Context, in *PatchWireGroupRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, WireGroups_Patch_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// WireGroupsServer is the server API for WireGroups service.
// All implementations should embed UnimplementedWireGroupsServer
// for forward compatibility
type WireGroupsServer interface {
	// Deletes the specified wire group in the given scope.
	Delete(context.Context, *DeleteWireGroupRequest) (*Operation, error)
	// Gets the specified wire group resource in the given scope.
	Get(context.Context, *GetWireGroupRequest) (*WireGroup, error)
	// Creates a wire group in the specified project in the given scope
	// using the parameters that are included in the request.
	Insert(context.Context, *InsertWireGroupRequest) (*Operation, error)
	// Lists the wire groups for a project in the given scope.
	List(context.Context, *ListWireGroupsRequest) (*WireGroupList, error)
	// Updates the specified wire group resource with the data included in the
	// request. This method supportsPATCH
	// semantics and usesJSON merge
	// patch format and processing rules.
	Patch(context.Context, *PatchWireGroupRequest) (*Operation, error)
}

// UnimplementedWireGroupsServer should be embedded to have forward compatible implementations.
type UnimplementedWireGroupsServer struct {
}

func (UnimplementedWireGroupsServer) Delete(context.Context, *DeleteWireGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedWireGroupsServer) Get(context.Context, *GetWireGroupRequest) (*WireGroup, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedWireGroupsServer) Insert(context.Context, *InsertWireGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Insert not implemented")
}
func (UnimplementedWireGroupsServer) List(context.Context, *ListWireGroupsRequest) (*WireGroupList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedWireGroupsServer) Patch(context.Context, *PatchWireGroupRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Patch not implemented")
}

// UnsafeWireGroupsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to WireGroupsServer will
// result in compilation errors.
type UnsafeWireGroupsServer interface {
	mustEmbedUnimplementedWireGroupsServer()
}

func RegisterWireGroupsServer(s grpc.ServiceRegistrar, srv WireGroupsServer) {
	s.RegisterService(&WireGroups_ServiceDesc, srv)
}

func _WireGroups_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteWireGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WireGroupsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WireGroups_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WireGroupsServer).Delete(ctx, req.(*DeleteWireGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WireGroups_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWireGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WireGroupsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WireGroups_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WireGroupsServer).Get(ctx, req.(*GetWireGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WireGroups_Insert_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InsertWireGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WireGroupsServer).Insert(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WireGroups_Insert_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WireGroupsServer).Insert(ctx, req.(*InsertWireGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WireGroups_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListWireGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WireGroupsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WireGroups_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WireGroupsServer).List(ctx, req.(*ListWireGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _WireGroups_Patch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PatchWireGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(WireGroupsServer).Patch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: WireGroups_Patch_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(WireGroupsServer).Patch(ctx, req.(*PatchWireGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// WireGroups_ServiceDesc is the grpc.ServiceDesc for WireGroups service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var WireGroups_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.WireGroups",
	HandlerType: (*WireGroupsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _WireGroups_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _WireGroups_Get_Handler,
		},
		{
			MethodName: "Insert",
			Handler:    _WireGroups_Insert_Handler,
		},
		{
			MethodName: "List",
			Handler:    _WireGroups_List_Handler,
		},
		{
			MethodName: "Patch",
			Handler:    _WireGroups_Patch_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	ZoneOperations_Delete_FullMethodName = "/google.cloud.compute.v1.ZoneOperations/Delete"
	ZoneOperations_Get_FullMethodName    = "/google.cloud.compute.v1.ZoneOperations/Get"
	ZoneOperations_List_FullMethodName   = "/google.cloud.compute.v1.ZoneOperations/List"
	ZoneOperations_Wait_FullMethodName   = "/google.cloud.compute.v1.ZoneOperations/Wait"
)

// ZoneOperationsClient is the client API for ZoneOperations service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ZoneOperationsClient interface {
	// Deletes the specified zone-specific Operations resource.
	Delete(ctx context.Context, in *DeleteZoneOperationRequest, opts ...grpc.CallOption) (*DeleteZoneOperationResponse, error)
	// Retrieves the specified zone-specific Operations resource.
	Get(ctx context.Context, in *GetZoneOperationRequest, opts ...grpc.CallOption) (*Operation, error)
	// Retrieves a list of Operation resources contained within
	// the specified zone.
	List(ctx context.Context, in *ListZoneOperationsRequest, opts ...grpc.CallOption) (*OperationList, error)
	// Waits for the specified Operation resource to return as `DONE`
	// or for the request to approach the 2 minute deadline, and retrieves the
	// specified Operation resource. This method waits for no more than the
	// 2 minutes and then returns the current state of the
	// operation, which might be `DONE` or still in progress.
	//
	// This method is called on a best-effort basis. Specifically:
	//
	//   - In uncommon cases, when the server is overloaded, the request might
	//     return before the default deadline is reached, or might return after zero
	//     seconds.
	//   - If the default deadline is reached, there is no guarantee that the
	//     operation is actually done when the method returns. Be prepared to retry
	//     if the operation is not `DONE`.
	Wait(ctx context.Context, in *WaitZoneOperationRequest, opts ...grpc.CallOption) (*Operation, error)
}

type zoneOperationsClient struct {
	cc grpc.ClientConnInterface
}

func NewZoneOperationsClient(cc grpc.ClientConnInterface) ZoneOperationsClient {
	return &zoneOperationsClient{cc}
}

func (c *zoneOperationsClient) Delete(ctx context.Context, in *DeleteZoneOperationRequest, opts ...grpc.CallOption) (*DeleteZoneOperationResponse, error) {
	out := new(DeleteZoneOperationResponse)
	err := c.cc.Invoke(ctx, ZoneOperations_Delete_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneOperationsClient) Get(ctx context.Context, in *GetZoneOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ZoneOperations_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneOperationsClient) List(ctx context.Context, in *ListZoneOperationsRequest, opts ...grpc.CallOption) (*OperationList, error) {
	out := new(OperationList)
	err := c.cc.Invoke(ctx, ZoneOperations_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zoneOperationsClient) Wait(ctx context.Context, in *WaitZoneOperationRequest, opts ...grpc.CallOption) (*Operation, error) {
	out := new(Operation)
	err := c.cc.Invoke(ctx, ZoneOperations_Wait_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZoneOperationsServer is the server API for ZoneOperations service.
// All implementations should embed UnimplementedZoneOperationsServer
// for forward compatibility
type ZoneOperationsServer interface {
	// Deletes the specified zone-specific Operations resource.
	Delete(context.Context, *DeleteZoneOperationRequest) (*DeleteZoneOperationResponse, error)
	// Retrieves the specified zone-specific Operations resource.
	Get(context.Context, *GetZoneOperationRequest) (*Operation, error)
	// Retrieves a list of Operation resources contained within
	// the specified zone.
	List(context.Context, *ListZoneOperationsRequest) (*OperationList, error)
	// Waits for the specified Operation resource to return as `DONE`
	// or for the request to approach the 2 minute deadline, and retrieves the
	// specified Operation resource. This method waits for no more than the
	// 2 minutes and then returns the current state of the
	// operation, which might be `DONE` or still in progress.
	//
	// This method is called on a best-effort basis. Specifically:
	//
	//   - In uncommon cases, when the server is overloaded, the request might
	//     return before the default deadline is reached, or might return after zero
	//     seconds.
	//   - If the default deadline is reached, there is no guarantee that the
	//     operation is actually done when the method returns. Be prepared to retry
	//     if the operation is not `DONE`.
	Wait(context.Context, *WaitZoneOperationRequest) (*Operation, error)
}

// UnimplementedZoneOperationsServer should be embedded to have forward compatible implementations.
type UnimplementedZoneOperationsServer struct {
}

func (UnimplementedZoneOperationsServer) Delete(context.Context, *DeleteZoneOperationRequest) (*DeleteZoneOperationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Delete not implemented")
}
func (UnimplementedZoneOperationsServer) Get(context.Context, *GetZoneOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedZoneOperationsServer) List(context.Context, *ListZoneOperationsRequest) (*OperationList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}
func (UnimplementedZoneOperationsServer) Wait(context.Context, *WaitZoneOperationRequest) (*Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Wait not implemented")
}

// UnsafeZoneOperationsServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ZoneOperationsServer will
// result in compilation errors.
type UnsafeZoneOperationsServer interface {
	mustEmbedUnimplementedZoneOperationsServer()
}

func RegisterZoneOperationsServer(s grpc.ServiceRegistrar, srv ZoneOperationsServer) {
	s.RegisterService(&ZoneOperations_ServiceDesc, srv)
}

func _ZoneOperations_Delete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteZoneOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneOperationsServer).Delete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneOperations_Delete_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneOperationsServer).Delete(ctx, req.(*DeleteZoneOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneOperations_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetZoneOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneOperationsServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneOperations_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneOperationsServer).Get(ctx, req.(*GetZoneOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneOperations_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListZoneOperationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneOperationsServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneOperations_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneOperationsServer).List(ctx, req.(*ListZoneOperationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ZoneOperations_Wait_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WaitZoneOperationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZoneOperationsServer).Wait(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ZoneOperations_Wait_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZoneOperationsServer).Wait(ctx, req.(*WaitZoneOperationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ZoneOperations_ServiceDesc is the grpc.ServiceDesc for ZoneOperations service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ZoneOperations_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.ZoneOperations",
	HandlerType: (*ZoneOperationsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Delete",
			Handler:    _ZoneOperations_Delete_Handler,
		},
		{
			MethodName: "Get",
			Handler:    _ZoneOperations_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _ZoneOperations_List_Handler,
		},
		{
			MethodName: "Wait",
			Handler:    _ZoneOperations_Wait_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}

const (
	Zones_Get_FullMethodName  = "/google.cloud.compute.v1.Zones/Get"
	Zones_List_FullMethodName = "/google.cloud.compute.v1.Zones/List"
)

// ZonesClient is the client API for Zones service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ZonesClient interface {
	// Returns the specified Zone resource.
	Get(ctx context.Context, in *GetZoneRequest, opts ...grpc.CallOption) (*Zone, error)
	// Retrieves the list of Zone resources available to the specified project.
	List(ctx context.Context, in *ListZonesRequest, opts ...grpc.CallOption) (*ZoneList, error)
}

type zonesClient struct {
	cc grpc.ClientConnInterface
}

func NewZonesClient(cc grpc.ClientConnInterface) ZonesClient {
	return &zonesClient{cc}
}

func (c *zonesClient) Get(ctx context.Context, in *GetZoneRequest, opts ...grpc.CallOption) (*Zone, error) {
	out := new(Zone)
	err := c.cc.Invoke(ctx, Zones_Get_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *zonesClient) List(ctx context.Context, in *ListZonesRequest, opts ...grpc.CallOption) (*ZoneList, error) {
	out := new(ZoneList)
	err := c.cc.Invoke(ctx, Zones_List_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ZonesServer is the server API for Zones service.
// All implementations should embed UnimplementedZonesServer
// for forward compatibility
type ZonesServer interface {
	// Returns the specified Zone resource.
	Get(context.Context, *GetZoneRequest) (*Zone, error)
	// Retrieves the list of Zone resources available to the specified project.
	List(context.Context, *ListZonesRequest) (*ZoneList, error)
}

// UnimplementedZonesServer should be embedded to have forward compatible implementations.
type UnimplementedZonesServer struct {
}

func (UnimplementedZonesServer) Get(context.Context, *GetZoneRequest) (*Zone, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Get not implemented")
}
func (UnimplementedZonesServer) List(context.Context, *ListZonesRequest) (*ZoneList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method List not implemented")
}

// UnsafeZonesServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ZonesServer will
// result in compilation errors.
type UnsafeZonesServer interface {
	mustEmbedUnimplementedZonesServer()
}

func RegisterZonesServer(s grpc.ServiceRegistrar, srv ZonesServer) {
	s.RegisterService(&Zones_ServiceDesc, srv)
}

func _Zones_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetZoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZonesServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zones_Get_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZonesServer).Get(ctx, req.(*GetZoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Zones_List_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListZonesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ZonesServer).List(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: Zones_List_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ZonesServer).List(ctx, req.(*ListZonesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// Zones_ServiceDesc is the grpc.ServiceDesc for Zones service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var Zones_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.compute.v1.Zones",
	HandlerType: (*ZonesServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _Zones_Get_Handler,
		},
		{
			MethodName: "List",
			Handler:    _Zones_List_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/compute/v1/compute.proto",
}
