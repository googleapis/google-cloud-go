// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.7
// source: google/cloud/devicestreaming/v1/service.proto

package devicestreamingpb

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	emptypb "google.golang.org/protobuf/types/known/emptypb"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	DirectAccessService_CreateDeviceSession_FullMethodName = "/google.cloud.devicestreaming.v1.DirectAccessService/CreateDeviceSession"
	DirectAccessService_ListDeviceSessions_FullMethodName  = "/google.cloud.devicestreaming.v1.DirectAccessService/ListDeviceSessions"
	DirectAccessService_GetDeviceSession_FullMethodName    = "/google.cloud.devicestreaming.v1.DirectAccessService/GetDeviceSession"
	DirectAccessService_CancelDeviceSession_FullMethodName = "/google.cloud.devicestreaming.v1.DirectAccessService/CancelDeviceSession"
	DirectAccessService_UpdateDeviceSession_FullMethodName = "/google.cloud.devicestreaming.v1.DirectAccessService/UpdateDeviceSession"
	DirectAccessService_AdbConnect_FullMethodName          = "/google.cloud.devicestreaming.v1.DirectAccessService/AdbConnect"
)

// DirectAccessServiceClient is the client API for DirectAccessService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type DirectAccessServiceClient interface {
	// Creates a DeviceSession.
	CreateDeviceSession(ctx context.Context, in *CreateDeviceSessionRequest, opts ...grpc.CallOption) (*DeviceSession, error)
	// Lists DeviceSessions owned by the project user.
	ListDeviceSessions(ctx context.Context, in *ListDeviceSessionsRequest, opts ...grpc.CallOption) (*ListDeviceSessionsResponse, error)
	// Gets a DeviceSession, which documents the allocation status and
	// whether the device is allocated. Clients making requests from this API
	// must poll GetDeviceSession.
	GetDeviceSession(ctx context.Context, in *GetDeviceSessionRequest, opts ...grpc.CallOption) (*DeviceSession, error)
	// Cancel a DeviceSession.
	// This RPC changes the DeviceSession to state FINISHED and terminates all
	// connections.
	// Canceled sessions are not deleted and can be retrieved or
	// listed by the user until they expire based on the 28 day deletion policy.
	CancelDeviceSession(ctx context.Context, in *CancelDeviceSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Updates the current DeviceSession to the fields described by the
	// update_mask.
	UpdateDeviceSession(ctx context.Context, in *UpdateDeviceSessionRequest, opts ...grpc.CallOption) (*DeviceSession, error)
	// Exposes an ADB connection if the device supports ADB.
	// gRPC headers are used to authenticate the Connect RPC, as well as
	// associate to a particular DeviceSession.
	// In particular, the user must specify the "X-Omnilab-Session-Name" header.
	AdbConnect(ctx context.Context, opts ...grpc.CallOption) (DirectAccessService_AdbConnectClient, error)
}

type directAccessServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewDirectAccessServiceClient(cc grpc.ClientConnInterface) DirectAccessServiceClient {
	return &directAccessServiceClient{cc}
}

func (c *directAccessServiceClient) CreateDeviceSession(ctx context.Context, in *CreateDeviceSessionRequest, opts ...grpc.CallOption) (*DeviceSession, error) {
	out := new(DeviceSession)
	err := c.cc.Invoke(ctx, DirectAccessService_CreateDeviceSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directAccessServiceClient) ListDeviceSessions(ctx context.Context, in *ListDeviceSessionsRequest, opts ...grpc.CallOption) (*ListDeviceSessionsResponse, error) {
	out := new(ListDeviceSessionsResponse)
	err := c.cc.Invoke(ctx, DirectAccessService_ListDeviceSessions_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directAccessServiceClient) GetDeviceSession(ctx context.Context, in *GetDeviceSessionRequest, opts ...grpc.CallOption) (*DeviceSession, error) {
	out := new(DeviceSession)
	err := c.cc.Invoke(ctx, DirectAccessService_GetDeviceSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directAccessServiceClient) CancelDeviceSession(ctx context.Context, in *CancelDeviceSessionRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, DirectAccessService_CancelDeviceSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directAccessServiceClient) UpdateDeviceSession(ctx context.Context, in *UpdateDeviceSessionRequest, opts ...grpc.CallOption) (*DeviceSession, error) {
	out := new(DeviceSession)
	err := c.cc.Invoke(ctx, DirectAccessService_UpdateDeviceSession_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *directAccessServiceClient) AdbConnect(ctx context.Context, opts ...grpc.CallOption) (DirectAccessService_AdbConnectClient, error) {
	stream, err := c.cc.NewStream(ctx, &DirectAccessService_ServiceDesc.Streams[0], DirectAccessService_AdbConnect_FullMethodName, opts...)
	if err != nil {
		return nil, err
	}
	x := &directAccessServiceAdbConnectClient{stream}
	return x, nil
}

type DirectAccessService_AdbConnectClient interface {
	Send(*AdbMessage) error
	Recv() (*DeviceMessage, error)
	grpc.ClientStream
}

type directAccessServiceAdbConnectClient struct {
	grpc.ClientStream
}

func (x *directAccessServiceAdbConnectClient) Send(m *AdbMessage) error {
	return x.ClientStream.SendMsg(m)
}

func (x *directAccessServiceAdbConnectClient) Recv() (*DeviceMessage, error) {
	m := new(DeviceMessage)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DirectAccessServiceServer is the server API for DirectAccessService service.
// All implementations should embed UnimplementedDirectAccessServiceServer
// for forward compatibility
type DirectAccessServiceServer interface {
	// Creates a DeviceSession.
	CreateDeviceSession(context.Context, *CreateDeviceSessionRequest) (*DeviceSession, error)
	// Lists DeviceSessions owned by the project user.
	ListDeviceSessions(context.Context, *ListDeviceSessionsRequest) (*ListDeviceSessionsResponse, error)
	// Gets a DeviceSession, which documents the allocation status and
	// whether the device is allocated. Clients making requests from this API
	// must poll GetDeviceSession.
	GetDeviceSession(context.Context, *GetDeviceSessionRequest) (*DeviceSession, error)
	// Cancel a DeviceSession.
	// This RPC changes the DeviceSession to state FINISHED and terminates all
	// connections.
	// Canceled sessions are not deleted and can be retrieved or
	// listed by the user until they expire based on the 28 day deletion policy.
	CancelDeviceSession(context.Context, *CancelDeviceSessionRequest) (*emptypb.Empty, error)
	// Updates the current DeviceSession to the fields described by the
	// update_mask.
	UpdateDeviceSession(context.Context, *UpdateDeviceSessionRequest) (*DeviceSession, error)
	// Exposes an ADB connection if the device supports ADB.
	// gRPC headers are used to authenticate the Connect RPC, as well as
	// associate to a particular DeviceSession.
	// In particular, the user must specify the "X-Omnilab-Session-Name" header.
	AdbConnect(DirectAccessService_AdbConnectServer) error
}

// UnimplementedDirectAccessServiceServer should be embedded to have forward compatible implementations.
type UnimplementedDirectAccessServiceServer struct {
}

func (UnimplementedDirectAccessServiceServer) CreateDeviceSession(context.Context, *CreateDeviceSessionRequest) (*DeviceSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateDeviceSession not implemented")
}
func (UnimplementedDirectAccessServiceServer) ListDeviceSessions(context.Context, *ListDeviceSessionsRequest) (*ListDeviceSessionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListDeviceSessions not implemented")
}
func (UnimplementedDirectAccessServiceServer) GetDeviceSession(context.Context, *GetDeviceSessionRequest) (*DeviceSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDeviceSession not implemented")
}
func (UnimplementedDirectAccessServiceServer) CancelDeviceSession(context.Context, *CancelDeviceSessionRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelDeviceSession not implemented")
}
func (UnimplementedDirectAccessServiceServer) UpdateDeviceSession(context.Context, *UpdateDeviceSessionRequest) (*DeviceSession, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateDeviceSession not implemented")
}
func (UnimplementedDirectAccessServiceServer) AdbConnect(DirectAccessService_AdbConnectServer) error {
	return status.Errorf(codes.Unimplemented, "method AdbConnect not implemented")
}

// UnsafeDirectAccessServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to DirectAccessServiceServer will
// result in compilation errors.
type UnsafeDirectAccessServiceServer interface {
	mustEmbedUnimplementedDirectAccessServiceServer()
}

func RegisterDirectAccessServiceServer(s grpc.ServiceRegistrar, srv DirectAccessServiceServer) {
	s.RegisterService(&DirectAccessService_ServiceDesc, srv)
}

func _DirectAccessService_CreateDeviceSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateDeviceSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectAccessServiceServer).CreateDeviceSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectAccessService_CreateDeviceSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectAccessServiceServer).CreateDeviceSession(ctx, req.(*CreateDeviceSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectAccessService_ListDeviceSessions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListDeviceSessionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectAccessServiceServer).ListDeviceSessions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectAccessService_ListDeviceSessions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectAccessServiceServer).ListDeviceSessions(ctx, req.(*ListDeviceSessionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectAccessService_GetDeviceSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetDeviceSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectAccessServiceServer).GetDeviceSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectAccessService_GetDeviceSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectAccessServiceServer).GetDeviceSession(ctx, req.(*GetDeviceSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectAccessService_CancelDeviceSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelDeviceSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectAccessServiceServer).CancelDeviceSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectAccessService_CancelDeviceSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectAccessServiceServer).CancelDeviceSession(ctx, req.(*CancelDeviceSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectAccessService_UpdateDeviceSession_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateDeviceSessionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(DirectAccessServiceServer).UpdateDeviceSession(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: DirectAccessService_UpdateDeviceSession_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(DirectAccessServiceServer).UpdateDeviceSession(ctx, req.(*UpdateDeviceSessionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _DirectAccessService_AdbConnect_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(DirectAccessServiceServer).AdbConnect(&directAccessServiceAdbConnectServer{stream})
}

type DirectAccessService_AdbConnectServer interface {
	Send(*DeviceMessage) error
	Recv() (*AdbMessage, error)
	grpc.ServerStream
}

type directAccessServiceAdbConnectServer struct {
	grpc.ServerStream
}

func (x *directAccessServiceAdbConnectServer) Send(m *DeviceMessage) error {
	return x.ServerStream.SendMsg(m)
}

func (x *directAccessServiceAdbConnectServer) Recv() (*AdbMessage, error) {
	m := new(AdbMessage)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// DirectAccessService_ServiceDesc is the grpc.ServiceDesc for DirectAccessService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var DirectAccessService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.devicestreaming.v1.DirectAccessService",
	HandlerType: (*DirectAccessServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateDeviceSession",
			Handler:    _DirectAccessService_CreateDeviceSession_Handler,
		},
		{
			MethodName: "ListDeviceSessions",
			Handler:    _DirectAccessService_ListDeviceSessions_Handler,
		},
		{
			MethodName: "GetDeviceSession",
			Handler:    _DirectAccessService_GetDeviceSession_Handler,
		},
		{
			MethodName: "CancelDeviceSession",
			Handler:    _DirectAccessService_CancelDeviceSession_Handler,
		},
		{
			MethodName: "UpdateDeviceSession",
			Handler:    _DirectAccessService_UpdateDeviceSession_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "AdbConnect",
			Handler:       _DirectAccessService_AdbConnect_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "google/cloud/devicestreaming/v1/service.proto",
}
