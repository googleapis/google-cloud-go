// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.7
// source: google/api/serviceusage/v1/serviceusage.proto

package serviceusagepb

import (
	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	ServiceUsage_EnableService_FullMethodName       = "/google.api.serviceusage.v1.ServiceUsage/EnableService"
	ServiceUsage_DisableService_FullMethodName      = "/google.api.serviceusage.v1.ServiceUsage/DisableService"
	ServiceUsage_GetService_FullMethodName          = "/google.api.serviceusage.v1.ServiceUsage/GetService"
	ServiceUsage_ListServices_FullMethodName        = "/google.api.serviceusage.v1.ServiceUsage/ListServices"
	ServiceUsage_BatchEnableServices_FullMethodName = "/google.api.serviceusage.v1.ServiceUsage/BatchEnableServices"
	ServiceUsage_BatchGetServices_FullMethodName    = "/google.api.serviceusage.v1.ServiceUsage/BatchGetServices"
)

// ServiceUsageClient is the client API for ServiceUsage service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ServiceUsageClient interface {
	// Enable a service so that it can be used with a project.
	EnableService(ctx context.Context, in *EnableServiceRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Disable a service so that it can no longer be used with a project.
	// This prevents unintended usage that may cause unexpected billing
	// charges or security leaks.
	//
	// It is not valid to call the disable method on a service that is not
	// currently enabled. Callers will receive a `FAILED_PRECONDITION` status if
	// the target service is not currently enabled.
	DisableService(ctx context.Context, in *DisableServiceRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Returns the service configuration and enabled state for a given service.
	GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*Service, error)
	// List all services available to the specified project, and the current
	// state of those services with respect to the project. The list includes
	// all public services, all services for which the calling user has the
	// `servicemanagement.services.bind` permission, and all services that have
	// already been enabled on the project. The list can be filtered to
	// only include services in a specific state, for example to only include
	// services enabled on the project.
	//
	// WARNING: If you need to query enabled services frequently or across
	// an organization, you should use
	// [Cloud Asset Inventory
	// API](https://cloud.google.com/asset-inventory/docs/apis), which provides
	// higher throughput and richer filtering capability.
	ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error)
	// Enable multiple services on a project. The operation is atomic: if enabling
	// any service fails, then the entire batch fails, and no state changes occur.
	// To enable a single service, use the `EnableService` method instead.
	BatchEnableServices(ctx context.Context, in *BatchEnableServicesRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Returns the service configurations and enabled states for a given list of
	// services.
	BatchGetServices(ctx context.Context, in *BatchGetServicesRequest, opts ...grpc.CallOption) (*BatchGetServicesResponse, error)
}

type serviceUsageClient struct {
	cc grpc.ClientConnInterface
}

func NewServiceUsageClient(cc grpc.ClientConnInterface) ServiceUsageClient {
	return &serviceUsageClient{cc}
}

func (c *serviceUsageClient) EnableService(ctx context.Context, in *EnableServiceRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, ServiceUsage_EnableService_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceUsageClient) DisableService(ctx context.Context, in *DisableServiceRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, ServiceUsage_DisableService_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceUsageClient) GetService(ctx context.Context, in *GetServiceRequest, opts ...grpc.CallOption) (*Service, error) {
	out := new(Service)
	err := c.cc.Invoke(ctx, ServiceUsage_GetService_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceUsageClient) ListServices(ctx context.Context, in *ListServicesRequest, opts ...grpc.CallOption) (*ListServicesResponse, error) {
	out := new(ListServicesResponse)
	err := c.cc.Invoke(ctx, ServiceUsage_ListServices_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceUsageClient) BatchEnableServices(ctx context.Context, in *BatchEnableServicesRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, ServiceUsage_BatchEnableServices_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serviceUsageClient) BatchGetServices(ctx context.Context, in *BatchGetServicesRequest, opts ...grpc.CallOption) (*BatchGetServicesResponse, error) {
	out := new(BatchGetServicesResponse)
	err := c.cc.Invoke(ctx, ServiceUsage_BatchGetServices_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServiceUsageServer is the server API for ServiceUsage service.
// All implementations should embed UnimplementedServiceUsageServer
// for forward compatibility
type ServiceUsageServer interface {
	// Enable a service so that it can be used with a project.
	EnableService(context.Context, *EnableServiceRequest) (*longrunningpb.Operation, error)
	// Disable a service so that it can no longer be used with a project.
	// This prevents unintended usage that may cause unexpected billing
	// charges or security leaks.
	//
	// It is not valid to call the disable method on a service that is not
	// currently enabled. Callers will receive a `FAILED_PRECONDITION` status if
	// the target service is not currently enabled.
	DisableService(context.Context, *DisableServiceRequest) (*longrunningpb.Operation, error)
	// Returns the service configuration and enabled state for a given service.
	GetService(context.Context, *GetServiceRequest) (*Service, error)
	// List all services available to the specified project, and the current
	// state of those services with respect to the project. The list includes
	// all public services, all services for which the calling user has the
	// `servicemanagement.services.bind` permission, and all services that have
	// already been enabled on the project. The list can be filtered to
	// only include services in a specific state, for example to only include
	// services enabled on the project.
	//
	// WARNING: If you need to query enabled services frequently or across
	// an organization, you should use
	// [Cloud Asset Inventory
	// API](https://cloud.google.com/asset-inventory/docs/apis), which provides
	// higher throughput and richer filtering capability.
	ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error)
	// Enable multiple services on a project. The operation is atomic: if enabling
	// any service fails, then the entire batch fails, and no state changes occur.
	// To enable a single service, use the `EnableService` method instead.
	BatchEnableServices(context.Context, *BatchEnableServicesRequest) (*longrunningpb.Operation, error)
	// Returns the service configurations and enabled states for a given list of
	// services.
	BatchGetServices(context.Context, *BatchGetServicesRequest) (*BatchGetServicesResponse, error)
}

// UnimplementedServiceUsageServer should be embedded to have forward compatible implementations.
type UnimplementedServiceUsageServer struct {
}

func (UnimplementedServiceUsageServer) EnableService(context.Context, *EnableServiceRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableService not implemented")
}
func (UnimplementedServiceUsageServer) DisableService(context.Context, *DisableServiceRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableService not implemented")
}
func (UnimplementedServiceUsageServer) GetService(context.Context, *GetServiceRequest) (*Service, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetService not implemented")
}
func (UnimplementedServiceUsageServer) ListServices(context.Context, *ListServicesRequest) (*ListServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListServices not implemented")
}
func (UnimplementedServiceUsageServer) BatchEnableServices(context.Context, *BatchEnableServicesRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchEnableServices not implemented")
}
func (UnimplementedServiceUsageServer) BatchGetServices(context.Context, *BatchGetServicesRequest) (*BatchGetServicesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BatchGetServices not implemented")
}

// UnsafeServiceUsageServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ServiceUsageServer will
// result in compilation errors.
type UnsafeServiceUsageServer interface {
	mustEmbedUnimplementedServiceUsageServer()
}

func RegisterServiceUsageServer(s grpc.ServiceRegistrar, srv ServiceUsageServer) {
	s.RegisterService(&ServiceUsage_ServiceDesc, srv)
}

func _ServiceUsage_EnableService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EnableServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceUsageServer).EnableService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceUsage_EnableService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceUsageServer).EnableService(ctx, req.(*EnableServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceUsage_DisableService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DisableServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceUsageServer).DisableService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceUsage_DisableService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceUsageServer).DisableService(ctx, req.(*DisableServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceUsage_GetService_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetServiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceUsageServer).GetService(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceUsage_GetService_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceUsageServer).GetService(ctx, req.(*GetServiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceUsage_ListServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceUsageServer).ListServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceUsage_ListServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceUsageServer).ListServices(ctx, req.(*ListServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceUsage_BatchEnableServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchEnableServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceUsageServer).BatchEnableServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceUsage_BatchEnableServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceUsageServer).BatchEnableServices(ctx, req.(*BatchEnableServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ServiceUsage_BatchGetServices_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BatchGetServicesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServiceUsageServer).BatchGetServices(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ServiceUsage_BatchGetServices_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServiceUsageServer).BatchGetServices(ctx, req.(*BatchGetServicesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ServiceUsage_ServiceDesc is the grpc.ServiceDesc for ServiceUsage service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ServiceUsage_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.api.serviceusage.v1.ServiceUsage",
	HandlerType: (*ServiceUsageServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "EnableService",
			Handler:    _ServiceUsage_EnableService_Handler,
		},
		{
			MethodName: "DisableService",
			Handler:    _ServiceUsage_DisableService_Handler,
		},
		{
			MethodName: "GetService",
			Handler:    _ServiceUsage_GetService_Handler,
		},
		{
			MethodName: "ListServices",
			Handler:    _ServiceUsage_ListServices_Handler,
		},
		{
			MethodName: "BatchEnableServices",
			Handler:    _ServiceUsage_BatchEnableServices_Handler,
		},
		{
			MethodName: "BatchGetServices",
			Handler:    _ServiceUsage_BatchGetServices_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/api/serviceusage/v1/serviceusage.proto",
}
