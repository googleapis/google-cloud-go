/*
Copyright 2017 Google LLC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package spanner

import (
	"context"
	"fmt"
	"log"
	"math/rand"
	"strings"
	"sync"
	"time"

	"cloud.google.com/go/internal/trace"
	sppb "cloud.google.com/go/spanner/apiv1/spannerpb"
	"cloud.google.com/go/spanner/internal"
	"go.opencensus.io/stats"
	"go.opencensus.io/tag"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/metric"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
)

const (
	multiplexSessionRefreshInterval = 7 * 24 * time.Hour
)

// ActionOnInactiveTransactionKind describes the kind of action taken when there are inactive transactions.
//
// Deprecated: This type is no longer used as the session pool has been removed.
type ActionOnInactiveTransactionKind int

const (
	actionUnspecified ActionOnInactiveTransactionKind = iota
	// NoAction action does not perform any action on inactive transactions.
	//
	// Deprecated: This constant is no longer used as the session pool has been removed.
	NoAction
	// Warn action logs inactive transactions. Any inactive transaction gets logged only once.
	//
	// Deprecated: This constant is no longer used as the session pool has been removed.
	Warn
	// Close action closes inactive transactions without logging.
	//
	// Deprecated: This constant is no longer used as the session pool has been removed.
	Close
	// WarnAndClose action logs and closes the inactive transactions.
	//
	// Deprecated: This constant is no longer used as the session pool has been removed.
	WarnAndClose
)

// InactiveTransactionRemovalOptions has configurations for action on long-running transactions.
//
// Deprecated: This type is no longer used as the session pool has been removed.
// Multiplexed sessions are now used for all operations. Kept for backward compatibility.
type InactiveTransactionRemovalOptions struct {
	// ActionOnInactiveTransaction is the action to take on inactive transactions.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	ActionOnInactiveTransaction ActionOnInactiveTransactionKind
}

// sessionHandle is an interface for transactions to access Cloud Spanner
// sessions safely. It is generated by sessionPool.takeMultiplexed().
type sessionHandle struct {
	mu sync.Mutex
	// session is a pointer to a session object.
	session *session
	// client is the RPC channel to Cloud Spanner.
	client spannerClient
	// checkoutTime is the time the session was checked out.
	checkoutTime time.Time
	// lastUseTime is the time the session was last used.
	lastUseTime time.Time
	// eligibleForLongRunning tells if the inner session is eligible to be long-running.
	eligibleForLongRunning bool
}

// recycle returns the session handle back to the pool.
func (sh *sessionHandle) recycle() {
	sh.mu.Lock()
	if sh.session == nil {
		sh.mu.Unlock()
		return
	}
	p := sh.session.pool
	s := sh.session
	sh.session = nil
	sh.client = nil
	sh.checkoutTime = time.Time{}
	sh.lastUseTime = time.Time{}
	sh.mu.Unlock()
	s.recycle()
	if p != nil {
		p.mu.Lock()
		p.decNumMultiplexedInUseLocked(context.Background())
		p.mu.Unlock()
	}
}

// getID gets the Cloud Spanner session ID from the internal session object.
func (sh *sessionHandle) getID() string {
	sh.mu.Lock()
	defer sh.mu.Unlock()
	if sh.session == nil {
		return ""
	}
	return sh.session.getID()
}

// getClient gets the Cloud Spanner RPC client associated with the session.
func (sh *sessionHandle) getClient() spannerClient {
	sh.mu.Lock()
	defer sh.mu.Unlock()
	if sh.session == nil {
		return nil
	}
	if sh.client != nil {
		return sh.client
	}
	return sh.session.client
}

// getMetadata returns the metadata associated with the session.
func (sh *sessionHandle) getMetadata() metadata.MD {
	sh.mu.Lock()
	defer sh.mu.Unlock()
	if sh.session == nil {
		return nil
	}
	return sh.session.md
}

// getTransactionID returns the transaction id in the session if available.
func (sh *sessionHandle) getTransactionID() transactionID {
	sh.mu.Lock()
	defer sh.mu.Unlock()
	if sh.session == nil {
		return nil
	}
	return sh.session.tx
}

// destroy destroys the inner session object.
func (sh *sessionHandle) destroy() {
	sh.mu.Lock()
	s := sh.session
	if s == nil {
		sh.mu.Unlock()
		return
	}
	sh.session = nil
	sh.client = nil
	sh.checkoutTime = time.Time{}
	sh.lastUseTime = time.Time{}
	sh.mu.Unlock()
	// Multiplexed sessions should not be destroyed
	if !s.isMultiplexed {
		s.destroy(false, true)
	}
}

func (sh *sessionHandle) updateLastUseTime() {
	sh.mu.Lock()
	defer sh.mu.Unlock()
	if sh.session != nil {
		sh.lastUseTime = time.Now()
	}
}

// session wraps a Cloud Spanner session ID through which transactions are
// created and executed.
type session struct {
	// client is the RPC channel to Cloud Spanner.
	client spannerClient
	// id is the unique id of the session in Cloud Spanner.
	id string
	// pool is the session's home session pool.
	pool *sessionPool
	// createTime is the timestamp of the session's creation.
	createTime time.Time
	// logger is the logger configured for the Spanner client.
	logger *log.Logger

	mu sync.Mutex
	// valid marks the validity of a session.
	valid bool
	// md is the Metadata to be sent with each request.
	md metadata.MD
	// tx contains the transaction id if the session has been prepared for write.
	tx transactionID
	// isMultiplexed is true if the session is multiplexed.
	isMultiplexed bool
}

// isValid returns true if the session is still valid for use.
func (s *session) isValid() bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.valid
}

// isWritePrepared returns true if the session is prepared for write.
func (s *session) isWritePrepared() bool {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.tx != nil
}

// String implements fmt.Stringer for session.
func (s *session) String() string {
	s.mu.Lock()
	defer s.mu.Unlock()
	return fmt.Sprintf("<id=%v, valid=%v, create=%v, multiplexed=%v>",
		s.id, s.valid, s.createTime, s.isMultiplexed)
}

// setTransactionID sets the transaction id in the session
func (s *session) setTransactionID(tx transactionID) {
	s.mu.Lock()
	defer s.mu.Unlock()
	s.tx = tx
}

// getID returns the session ID which uniquely identifies the session in Cloud Spanner.
func (s *session) getID() string {
	s.mu.Lock()
	defer s.mu.Unlock()
	return s.id
}

// recycle turns the session back to its home session pool.
func (s *session) recycle() {
	s.setTransactionID(nil)
	// Multiplexed sessions don't need to be recycled to a pool
}

// destroy removes the session from Cloud Spanner service.
func (s *session) destroy(isExpire, wasInUse bool) bool {
	// Multiplexed sessions should not be destroyed
	if s.isMultiplexed {
		return false
	}
	ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
	defer cancel()
	return s.destroyWithContext(ctx, isExpire, wasInUse)
}

func (s *session) destroyWithContext(ctx context.Context, isExpire, wasInUse bool) bool {
	if s.isMultiplexed {
		return false
	}
	s.delete(ctx)
	return true
}

func (s *session) delete(ctx context.Context) {
	if s.isMultiplexed {
		return
	}
	err := s.client.DeleteSession(contextWithOutgoingMetadata(ctx, s.md, true), &sppb.DeleteSessionRequest{Name: s.getID()})
	if err != nil && ErrCode(err) != codes.DeadlineExceeded {
		logf(s.logger, "Failed to delete session %v. Error: %v", s.getID(), err)
	}
}

// SessionPoolConfig stores configurations of a session pool.
//
// Deprecated: This configuration is no longer used as the session pool has been removed.
// Multiplexed sessions are now used for all operations. These options are kept for
// backward compatibility but are ignored.
type SessionPoolConfig struct {
	// MaxOpened is the maximum number of opened sessions allowed by the session pool.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	MaxOpened uint64

	// MinOpened is the minimum number of opened sessions that the session pool tries to maintain.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	MinOpened uint64

	// MaxIdle is the maximum number of idle sessions.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	MaxIdle uint64

	// MaxBurst is the maximum number of concurrent session creation requests.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	MaxBurst uint64

	// WriteSessions is the fraction of sessions we try to keep prepared for write.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	WriteSessions float64

	// HealthCheckWorkers is number of workers used by health checker.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	HealthCheckWorkers int

	// HealthCheckInterval is how often the health checker pings a session.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	HealthCheckInterval time.Duration

	// MultiplexSessionCheckInterval is the interval at which the multiplexed session is checked.
	//
	// Defaults to 10 mins.
	MultiplexSessionCheckInterval time.Duration

	// TrackSessionHandles determines whether the session pool will keep track of session handles.
	//
	// Deprecated: This option is no longer used as the session pool has been removed.
	TrackSessionHandles bool

	// Deprecated: This option is no longer used as the session pool has been removed.
	InactiveTransactionRemovalOptions
}

// DefaultSessionPoolConfig is the default configuration for the session pool.
//
// Deprecated: The session pool has been removed. Multiplexed sessions are now used
// for all operations. This configuration is kept for backward compatibility.
var DefaultSessionPoolConfig = SessionPoolConfig{
	MinOpened:           100,
	MaxOpened:           numChannels * 100,
	MaxBurst:            10,
	WriteSessions:       0.2,
	HealthCheckWorkers:  10,
	HealthCheckInterval: 50 * time.Minute,
	InactiveTransactionRemovalOptions: InactiveTransactionRemovalOptions{
		ActionOnInactiveTransaction: Warn,
	},
}

type muxSessionCreateRequest struct {
	ctx   context.Context
	force bool
}

// sessionPool manages multiplexed sessions for a database.
// The traditional session pool has been removed and replaced with multiplexed sessions only.
type sessionPool struct {
	mu    sync.Mutex
	valid bool
	sc    *sessionClient

	// multiplexSessionClientCounter is the counter for the multiplexed session client.
	multiplexSessionClientCounter int
	// clientPool is a pool of Cloud Spanner grpc clients.
	clientPool []spannerClient
	// multiplexedSession contains the multiplexed session
	multiplexedSession *session
	// multiplexedSessionReq is the ongoing multiplexed session creation request (if any).
	multiplexedSessionReq chan muxSessionCreateRequest
	// mayGetMultiplexedSession is for broadcasting that multiplexed session retrieval is possible.
	mayGetMultiplexedSession chan bool
	// multiplexedSessionCreationError is the error that occurred during multiplexed session creation.
	multiplexedSessionCreationError error

	// configuration of the session pool (kept for backward compatibility)
	SessionPoolConfig

	// rand is a separately sourced random generator.
	rand *rand.Rand

	// tagMap is a map of all tags that are associated with the emitted metrics.
	tagMap *tag.Map

	otConfig *openTelemetryConfig

	// done is used to signal that the session pool is closing.
	done chan struct{}
	// once is used for closing channel done only once.
	once sync.Once
}

// newSessionPool creates a new session pool that manages multiplexed sessions.
func newSessionPool(sc *sessionClient, config SessionPoolConfig) (*sessionPool, error) {
	if config.MultiplexSessionCheckInterval == 0 {
		config.MultiplexSessionCheckInterval = 10 * time.Minute
	}

	pool := &sessionPool{
		sc:                       sc,
		valid:                    true,
		mayGetMultiplexedSession: make(chan bool),
		multiplexedSessionReq:    make(chan muxSessionCreateRequest),
		SessionPoolConfig:        config,
		rand:                     rand.New(rand.NewSource(time.Now().UnixNano())),
		otConfig:                 sc.otConfig,
		done:                     make(chan struct{}),
	}

	_, instance, database, err := parseDatabaseName(sc.database)
	if err != nil {
		return nil, err
	}
	ctx, err := tag.New(context.Background(),
		tag.Upsert(tagKeyClientID, sc.id),
		tag.Upsert(tagKeyDatabase, database),
		tag.Upsert(tagKeyInstance, instance),
		tag.Upsert(tagKeyLibVersion, internal.Version),
	)
	if err != nil {
		logf(pool.sc.logger, "Failed to create tag map, error: %v", err)
	}
	pool.tagMap = tag.FromContext(ctx)

	// Start the multiplexed session creation goroutine
	go pool.createMultiplexedSession()

	// Create the initial multiplexed session
	ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
	pool.multiplexedSessionReq <- muxSessionCreateRequest{force: true, ctx: ctx}
	go func() {
		select {
		case <-ctx.Done():
			cancel()
			return
		case <-pool.mayGetMultiplexedSession:
			cancel()
		}
	}()

	// Start the multiplexed session refresh worker
	go pool.multiplexSessionWorker()

	err = registerSessionPoolOTMetrics(pool)
	if err != nil {
		logf(pool.sc.logger, "Error when registering session pool metrics in OpenTelemetry, error: %v", err)
	}

	return pool, nil
}

func (p *sessionPool) recordStat(ctx context.Context, m *stats.Int64Measure, n int64, tags ...tag.Tag) {
	ctx = tag.NewContext(ctx, p.tagMap)
	mutators := make([]tag.Mutator, len(tags))
	for i, t := range tags {
		mutators[i] = tag.Upsert(t.Key, t.Value)
	}
	ctx, err := tag.New(ctx, mutators...)
	if err != nil {
		logf(p.sc.logger, "Failed to tag metrics, error: %v", err)
	}
	recordStat(ctx, m, n)
}

type recordOTStatOption struct {
	attr []attribute.KeyValue
}

func (p *sessionPool) recordOTStat(ctx context.Context, m metric.Int64Counter, val int64, option recordOTStatOption) {
	if m != nil {
		attrs := p.otConfig.attributeMap
		if len(option.attr) > 0 {
			attrs = option.attr
		}
		m.Add(ctx, val, metric.WithAttributes(attrs...))
	}
}

// isMultiplexedSessionForRWEnabled always returns true.
// Multiplexed sessions are always enabled and cannot be disabled.
func (p *sessionPool) isMultiplexedSessionForRWEnabled() bool {
	return true
}

// isMultiplexedSessionForPartitionedOpsEnabled always returns true.
// Multiplexed sessions are always enabled and cannot be disabled.
func (p *sessionPool) isMultiplexedSessionForPartitionedOpsEnabled() bool {
	return true
}

// disableMultiplexedSessionForRW is a no-op.
// Multiplexed sessions are always enabled and cannot be disabled.
// This method is kept for backwards compatibility but has no effect.
func (p *sessionPool) disableMultiplexedSessionForRW() {
	// No-op: multiplexed sessions cannot be disabled
}

// disableMultiplexedSessionForPartitionedOps is a no-op.
// Multiplexed sessions are always enabled and cannot be disabled.
// This method is kept for backwards compatibility but has no effect.
func (p *sessionPool) disableMultiplexedSessionForPartitionedOps() {
	// No-op: multiplexed sessions cannot be disabled
}

func (p *sessionPool) createMultiplexedSession() {
	for c := range p.multiplexedSessionReq {
		p.mu.Lock()
		sess := p.multiplexedSession
		p.mu.Unlock()
		if c.force || sess == nil {
			p.mu.Lock()
			p.sc.mu.Lock()
			client, err := p.sc.nextClient()
			p.sc.mu.Unlock()
			p.mu.Unlock()
			if err != nil {
				p.mu.Lock()
				p.multiplexedSessionCreationError = err
				p.mu.Unlock()
				select {
				case p.mayGetMultiplexedSession <- true:
				case <-c.ctx.Done():
				}
				continue
			}
			p.sc.executeCreateMultiplexedSession(c.ctx, client, p.sc.md, p)
			continue
		}
		select {
		case p.mayGetMultiplexedSession <- true:
		case <-c.ctx.Done():
			return
		}
	}
}

// sessionReady is called when a session has been created and is ready for use.
func (p *sessionPool) sessionReady(ctx context.Context, s *session) {
	p.mu.Lock()
	defer p.mu.Unlock()
	if s.isMultiplexed {
		s.pool = p
		p.multiplexedSession = s
		p.multiplexedSessionCreationError = nil
		p.recordStat(context.Background(), OpenSessionCount, int64(1), tag.Tag{Key: tagKeyIsMultiplexed, Value: "true"})
		p.recordStat(context.Background(), SessionsCount, 1, tagNumSessions, tag.Tag{Key: tagKeyIsMultiplexed, Value: "true"})
		select {
		case p.mayGetMultiplexedSession <- true:
		case <-ctx.Done():
			return
		}
		return
	}
	// Regular sessions are no longer supported - this should not be called for non-multiplexed sessions
	logf(p.sc.logger, "Warning: sessionReady called for non-multiplexed session, ignoring")
}

// sessionCreationFailed is called when session creation fails.
func (p *sessionPool) sessionCreationFailed(ctx context.Context, err error, numSessions int32, isMultiplexed bool) {
	p.mu.Lock()
	defer p.mu.Unlock()
	if isMultiplexed {
		if p.multiplexedSession != nil {
			p.multiplexedSessionCreationError = nil
			select {
			case p.mayGetMultiplexedSession <- true:
			case <-ctx.Done():
				return
			}
			return
		}
		p.recordStat(context.Background(), OpenSessionCount, int64(0), tag.Tag{Key: tagKeyIsMultiplexed, Value: "true"})
		p.multiplexedSessionCreationError = err
		select {
		case p.mayGetMultiplexedSession <- true:
		case <-ctx.Done():
			return
		}
		return
	}
	// Regular session creation errors are no longer handled
	logf(p.sc.logger, "Warning: sessionCreationFailed called for non-multiplexed sessions, ignoring")
}

// isValid checks if the session pool is still valid.
func (p *sessionPool) isValid() bool {
	if p == nil {
		return false
	}
	p.mu.Lock()
	defer p.mu.Unlock()
	return p.valid
}

// close marks the session pool as closed.
func (p *sessionPool) close(ctx context.Context) {
	if p == nil {
		return
	}
	p.mu.Lock()
	if !p.valid {
		p.mu.Unlock()
		return
	}
	p.valid = false
	if p.otConfig != nil && p.otConfig.otMetricRegistration != nil {
		err := p.otConfig.otMetricRegistration.Unregister()
		if err != nil {
			logf(p.sc.logger, "Failed to unregister callback from the OpenTelemetry meter, error : %v", err)
		}
	}
	p.mu.Unlock()
	p.once.Do(func() { close(p.done) })
	close(p.multiplexedSessionReq)
}

// errInvalidSessionPool is the error for using an invalid session pool.
var errInvalidSessionPool = spannerErrorf(codes.InvalidArgument, "invalid session pool")

// errGetSessionTimeout returns error for context timeout during session acquisition.
var errGetSessionTimeout = spannerErrorf(codes.Canceled, "timeout / context canceled during getting session")

// newSessionHandle creates a new session handle for the given session.
func (p *sessionPool) newSessionHandle(s *session) (sh *sessionHandle) {
	sh = &sessionHandle{session: s, checkoutTime: time.Now(), lastUseTime: time.Now()}
	if s.isMultiplexed {
		p.mu.Lock()
		sh.client = p.getRoundRobinClient()
		p.mu.Unlock()
		return sh
	}
	return sh
}

func (p *sessionPool) getRoundRobinClient() spannerClient {
	p.sc.mu.Lock()
	defer func() {
		p.multiplexSessionClientCounter++
		p.sc.mu.Unlock()
	}()
	if len(p.clientPool) == 0 {
		p.clientPool = make([]spannerClient, p.sc.connPool.Num())
		for i := 0; i < p.sc.connPool.Num(); i++ {
			c, err := p.sc.nextClient()
			if err != nil {
				return nil
			}
			p.clientPool[i] = c
		}
	}
	p.multiplexSessionClientCounter = p.multiplexSessionClientCounter % len(p.clientPool)
	return p.clientPool[p.multiplexSessionClientCounter]
}

// errGetSessionTimeout returns error for context timeout during session acquisition.
func (p *sessionPool) errGetSessionTimeout(ctx context.Context) error {
	var code codes.Code
	if ctx.Err() == context.DeadlineExceeded {
		code = codes.DeadlineExceeded
	} else {
		code = codes.Canceled
	}
	return spannerErrorf(code, "timeout / context canceled during getting session.")
}

// take returns a multiplexed session.
//
// Deprecated: Regular session pool has been removed. This method now returns
// a multiplexed session for backward compatibility.
func (p *sessionPool) take(ctx context.Context) (*sessionHandle, error) {
	return p.takeMultiplexed(ctx)
}

// takeMultiplexed returns a multiplexed session.
func (p *sessionPool) takeMultiplexed(ctx context.Context) (*sessionHandle, error) {
	trace.TracePrintf(ctx, nil, "Acquiring a multiplexed session")
	for {
		var s *session
		p.mu.Lock()
		if !p.valid {
			p.mu.Unlock()
			return nil, errInvalidSessionPool
		}
		if p.multiplexedSession != nil {
			s = p.multiplexedSession
			trace.TracePrintf(ctx, map[string]interface{}{"sessionID": s.getID()},
				"Acquired multiplexed session")
			p.mu.Unlock()
			p.incNumMultiplexedInUse(ctx)
			return p.newSessionHandle(s), nil
		}
		mayGetSession := p.mayGetMultiplexedSession
		p.mu.Unlock()
		p.multiplexedSessionReq <- muxSessionCreateRequest{force: false, ctx: ctx}
		select {
		case <-ctx.Done():
			trace.TracePrintf(ctx, nil, "Context done waiting for multiplexed session")
			p.recordStat(ctx, GetSessionTimeoutsCount, 1, tag.Tag{Key: tagKeyIsMultiplexed, Value: "true"})
			if p.otConfig != nil {
				p.recordOTStat(ctx, p.otConfig.getSessionTimeoutsCount, 1, recordOTStatOption{attr: p.otConfig.attributeMapWithMultiplexed})
			}
			return nil, p.errGetSessionTimeout(ctx)
		case <-mayGetSession:
			p.mu.Lock()
			if p.multiplexedSessionCreationError != nil {
				trace.TracePrintf(ctx, nil, "Error creating multiplexed session: %v", p.multiplexedSessionCreationError)
				err := p.multiplexedSessionCreationError
				p.mu.Unlock()
				return nil, err
			}
			p.mu.Unlock()
		}
	}
}

func (p *sessionPool) incNumMultiplexedInUse(ctx context.Context) {
	p.recordStat(ctx, AcquiredSessionsCount, 1, tag.Tag{Key: tagKeyIsMultiplexed, Value: "true"})
	if p.otConfig != nil {
		p.recordOTStat(ctx, p.otConfig.acquiredSessionsCount, 1, recordOTStatOption{attr: p.otConfig.attributeMapWithMultiplexed})
	}
}

func (p *sessionPool) decNumMultiplexedInUseLocked(ctx context.Context) {
	p.recordStat(ctx, ReleasedSessionsCount, 1, tag.Tag{Key: tagKeyIsMultiplexed, Value: "true"})
	if p.otConfig != nil {
		p.recordOTStat(ctx, p.otConfig.releasedSessionsCount, 1, recordOTStatOption{attr: p.otConfig.attributeMapWithMultiplexed})
	}
}

func (p *sessionPool) multiplexSessionWorker() {
	for {
		select {
		case <-p.done:
			return
		default:
		}

		p.mu.Lock()
		createTime := time.Now()
		s := p.multiplexedSession
		if s != nil {
			createTime = p.multiplexedSession.createTime
		}
		p.mu.Unlock()

		ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
		if createTime.Add(multiplexSessionRefreshInterval).Before(time.Now()) {
			// Multiplexed session is idle for more than 7 days, replace it.
			p.multiplexedSessionReq <- muxSessionCreateRequest{force: true, ctx: ctx}
			// wait for the new multiplexed session to be created.
			select {
			case <-p.mayGetMultiplexedSession:
			case <-p.done:
				cancel()
				return
			}
		}
		cancel()

		// Sleep for a while to avoid burning CPU.
		select {
		case <-time.After(p.MultiplexSessionCheckInterval):
		case <-p.done:
			return
		}
	}
}

// sessionResourceType is the type name of Spanner sessions.
const sessionResourceType = "type.googleapis.com/google.spanner.v1.Session"

// isSessionNotFoundError returns true if the given error is a `Session not found` error.
func isSessionNotFoundError(err error) bool {
	if err == nil {
		return false
	}
	if ErrCode(err) == codes.NotFound {
		if rt, ok := extractResourceType(err); ok {
			return rt == sessionResourceType
		}
	}
	return strings.Contains(err.Error(), "Session not found")
}

func isUnimplementedError(err error) bool {
	if err == nil {
		return false
	}
	return ErrCode(err) == codes.Unimplemented
}

// isUnimplementedErrorForMultiplexedRW returns true if the gRPC error code is Unimplemented and related to use of multiplexed session with ReadWrite txn.
func isUnimplementedErrorForMultiplexedRW(err error) bool {
	if err == nil {
		return false
	}
	return ErrCode(err) == codes.Unimplemented && strings.Contains(err.Error(), "Transaction type read_write not supported with multiplexed sessions")
}

// isUnimplementedErrorForMultiplexedPartitionedDML returns true if the gRPC error code is Unimplemented and related to use of multiplexed session with partitioned ops.
func isUnimplementedErrorForMultiplexedPartitionedDML(err error) bool {
	if err == nil {
		return false
	}
	return ErrCode(err) == codes.Unimplemented && strings.Contains(err.Error(), "Transaction type partitioned_dml not supported with multiplexed sessions")
}

func isUnimplementedErrorForMultiplexedPartitionReads(err error) bool {
	if err == nil {
		return false
	}
	return strings.Contains(err.Error(), "Partitioned operations are not supported with multiplexed sessions")
}

func isFailedInlineBeginTransaction(err error) bool {
	if err == nil {
		return false
	}
	return ErrCode(err) == codes.Internal && strings.Contains(err.Error(), errInlineBeginTransactionFailedMsg)
}

// isClientClosing returns true if the given error is a `Connection is closing` error.
func isClientClosing(err error) bool {
	if err == nil {
		return false
	}
	return ErrCode(err) == codes.Canceled && strings.Contains(err.Error(), "the client connection is closing")
}
