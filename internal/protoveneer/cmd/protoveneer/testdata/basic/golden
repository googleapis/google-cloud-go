// This file was generated by protoveneer. DO NOT EDIT.

package basic

import (
	"fmt"
	"time"

	"cloud.google.com/go/civil"
	pb "example.com/basic"
	"example.com/protoveneer/support"
	"github.com/googleapis/gax-go/v2/apierror"
	"google.golang.org/protobuf/types/known/durationpb"
)

// Blob contains raw media bytes.
//
// Text should not be sent as raw bytes, use the 'text' field.
type Blob struct {
	// Required. The IANA standard MIME type of the source data.
	MIMEType string
	// Required. Raw bytes for media formats.
	Data []byte
}

func (v *Blob) toProto() *pb.Blob {
	if v == nil {
		return nil
	}
	return &pb.Blob{
		MimeType: v.MIMEType,
		Data:     v.Data,
	}
}

func (Blob) fromProto(p *pb.Blob) *Blob {
	if p == nil {
		return nil
	}
	return &Blob{
		MIMEType: p.MimeType,
		Data:     p.Data,
	}
}

// Citation contains source attributions for content.
type Citation struct {
	// Output only. Url reference of the attribution.
	URI string
	// Output only. Publication date of the attribution.
	PublicationDate civil.Date
	Struct          map[string]any
	CreateTime      time.Time
}

func (v *Citation) toProto() *pb.Citation {
	if v == nil {
		return nil
	}
	return &pb.Citation{
		Uri:             v.URI,
		PublicationDate: support.CivilDateToProto(v.PublicationDate),
		Struct:          support.MapToStructPB(v.Struct),
		CreateTime:      support.TimeToProto(v.CreateTime),
	}
}

func (Citation) fromProto(p *pb.Citation) *Citation {
	if p == nil {
		return nil
	}
	return &Citation{
		URI:             p.Uri,
		PublicationDate: support.CivilDateFromProto(p.PublicationDate),
		Struct:          support.MapFromStructPB(p.Struct),
		CreateTime:      support.TimeFromProto(p.CreateTime),
	}
}

// CitationMetadata is a collection of source attributions for a piece of content.
type CitationMetadata struct {
	// Output only. List of citations.
	Citations []*Citation
	CitMap    map[string]*Citation
}

func (v *CitationMetadata) toProto() *pb.CitationMetadata {
	if v == nil {
		return nil
	}
	return &pb.CitationMetadata{
		Citations: support.TransformSlice(v.Citations, (*Citation).toProto),
		CitMap:    support.TransformMapValues(v.CitMap, (*Citation).toProto),
	}
}

func (CitationMetadata) fromProto(p *pb.CitationMetadata) *CitationMetadata {
	if p == nil {
		return nil
	}
	return &CitationMetadata{
		Citations: support.TransformSlice(p.Citations, (Citation{}).fromProto),
		CitMap:    support.TransformMapValues(p.CitMap, (Citation{}).fromProto),
	}
}

type File struct {
	Error  *apierror.APIError
	Dur    time.Duration
	hidden *Client
}

func (v *File) toProto() *pb.File {
	if v == nil {
		return nil
	}
	return &pb.File{
		Error: support.APIErrorToProto(v.Error),
		Dur:   durationpb.New(v.Dur),
	}
}

func (File) fromProto(p *pb.File) *File {
	if p == nil {
		return nil
	}
	return &File{
		Error: support.APIErrorFromProto(p.Error),
		Dur:   support.DurationFromProto(p.Dur),
	}
}

// FinishReason is the reason why the model stopped generating tokens.
// If empty, the model has not stopped generating the tokens.
type FinishReason int32

const (
	// FinishReasonUnspecified means the finish reason is unspecified.
	FinishReasonUnspecified FinishReason = 0
	// FinishReasonStop means natural stop point of the model or provided stop sequence.
	FinishReasonStop FinishReason = 1
	// FinishReasonMaxTokens means the maximum number of tokens as specified in the request was reached.
	FinishReasonMaxTokens FinishReason = 2
	// FinishReasonSafety means the token generation was stopped as the response was flagged for safety
	// reasons. NOTE: When streaming the Candidate.content will be empty if
	// content filters blocked the output.
	FinishReasonSafety FinishReason = 3
	// FinishReasonRecitation means the token generation was stopped as the response was flagged for
	// unauthorized citations.
	FinishReasonRecitation FinishReason = 4
	// FinishReasonOther means all other reasons that stopped the token generation
	FinishReasonOther FinishReason = 5
)

var namesForFinishReason = map[FinishReason]string{
	FinishReasonUnspecified: "FinishReasonUnspecified",
	FinishReasonStop:        "FinishReasonStop",
	FinishReasonMaxTokens:   "FinishReasonMaxTokens",
	FinishReasonSafety:      "FinishReasonSafety",
	FinishReasonRecitation:  "FinishReasonRecitation",
	FinishReasonOther:       "FinishReasonOther",
}

func (v FinishReason) String() string {
	if n, ok := namesForFinishReason[v]; ok {
		return n
	}
	return fmt.Sprintf("FinishReason(%d)", v)
}

// GenerationConfig is generation config.
type GenerationConfig struct {
	// Optional. Controls the randomness of predictions.
	Temperature float32
	// Optional. Number of candidates to generate.
	CandidateCount int32
	// Optional. Stop sequences.
	StopSequences []string
	HarmCat       HarmCategory
	// The reason for finishing.
	FinishReason FinishReason
	CitMet       *CitationMetadata
	// Multiple lines of
	// documentation for this
	// field.
	TopK *int32
}

func (v *GenerationConfig) toProto() *pb.GenerationConfig {
	if v == nil {
		return nil
	}
	return &pb.GenerationConfig{
		Temperature:    support.AddrOrNil(v.Temperature),
		CandidateCount: support.AddrOrNil(v.CandidateCount),
		StopSequences:  v.StopSequences,
		HarmCat:        pb.HarmCategory(v.HarmCat),
		FinishReason:   pb.Candidate_FinishReason(v.FinishReason),
		CitMet:         v.CitMet.toProto(),
		TopK:           int32pToFloat32p(v.TopK),
	}
}

func (GenerationConfig) fromProto(p *pb.GenerationConfig) *GenerationConfig {
	if p == nil {
		return nil
	}
	return &GenerationConfig{
		Temperature:    support.DerefOrZero(p.Temperature),
		CandidateCount: support.DerefOrZero(p.CandidateCount),
		StopSequences:  p.StopSequences,
		HarmCat:        HarmCategory(p.HarmCat),
		FinishReason:   FinishReason(p.FinishReason),
		CitMet:         (CitationMetadata{}).fromProto(p.CitMet),
		TopK:           float32pToInt32p(p.TopK),
	}
}

// HarmCategory specifies harm categories that will block the content.
type HarmCategory int32

const (
	// HarmCategoryUnspecified means the harm category is unspecified.
	HarmCategoryUnspecified HarmCategory = 0
	// HarmCategoryHateSpeech means the harm category is hate speech.
	HarmCategoryHateSpeech HarmCategory = 1
	// HarmCategoryDangerousContent means the harm category is dangerous content.
	HarmCategoryDangerousContent HarmCategory = 2
	// HarmCategoryHarassment means the harm category is harassment.
	HarmCategoryHarassment HarmCategory = 3
	// HarmCategorySexuallyExplicit means the harm category is sexually explicit content.
	HarmCategorySexuallyExplicit HarmCategory = 4
)

var namesForHarmCategory = map[HarmCategory]string{
	HarmCategoryUnspecified:      "HarmCategoryUnspecified",
	HarmCategoryHateSpeech:       "HarmCategoryHateSpeech",
	HarmCategoryDangerousContent: "HarmCategoryDangerousContent",
	HarmCategoryHarassment:       "HarmCategoryHarassment",
	HarmCategorySexuallyExplicit: "HarmCategorySexuallyExplicit",
}

func (v HarmCategory) String() string {
	if n, ok := namesForHarmCategory[v]; ok {
		return n
	}
	return fmt.Sprintf("HarmCategory(%d)", v)
}

// Pop is this demonstrates using population functions to deal with
// proto oneof field, which has an unexported type.
// That can be a way to deal with proto oneofs.
type Pop struct {
	X int
	Y unexported
}

func (v *Pop) toProto() *pb.Pop {
	if v == nil {
		return nil
	}
	p := &pb.Pop{
		X: v.X,
	}
	popYTo(p, v)
	return p
}

func (Pop) fromProto(p *pb.Pop) *Pop {
	if p == nil {
		return nil
	}
	v := &Pop{
		X: p.X,
	}
	popYFrom(v, p)
	return v
}
