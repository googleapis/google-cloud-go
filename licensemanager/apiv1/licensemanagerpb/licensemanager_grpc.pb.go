// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.3.0
// - protoc             v4.25.7
// source: google/cloud/licensemanager/v1/licensemanager.proto

package licensemanagerpb

import (
	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.32.0 or later.
const _ = grpc.SupportPackageIsVersion7

const (
	LicenseManager_ListConfigurations_FullMethodName             = "/google.cloud.licensemanager.v1.LicenseManager/ListConfigurations"
	LicenseManager_GetConfiguration_FullMethodName               = "/google.cloud.licensemanager.v1.LicenseManager/GetConfiguration"
	LicenseManager_CreateConfiguration_FullMethodName            = "/google.cloud.licensemanager.v1.LicenseManager/CreateConfiguration"
	LicenseManager_UpdateConfiguration_FullMethodName            = "/google.cloud.licensemanager.v1.LicenseManager/UpdateConfiguration"
	LicenseManager_DeleteConfiguration_FullMethodName            = "/google.cloud.licensemanager.v1.LicenseManager/DeleteConfiguration"
	LicenseManager_ListInstances_FullMethodName                  = "/google.cloud.licensemanager.v1.LicenseManager/ListInstances"
	LicenseManager_GetInstance_FullMethodName                    = "/google.cloud.licensemanager.v1.LicenseManager/GetInstance"
	LicenseManager_DeactivateConfiguration_FullMethodName        = "/google.cloud.licensemanager.v1.LicenseManager/DeactivateConfiguration"
	LicenseManager_ReactivateConfiguration_FullMethodName        = "/google.cloud.licensemanager.v1.LicenseManager/ReactivateConfiguration"
	LicenseManager_QueryConfigurationLicenseUsage_FullMethodName = "/google.cloud.licensemanager.v1.LicenseManager/QueryConfigurationLicenseUsage"
	LicenseManager_AggregateUsage_FullMethodName                 = "/google.cloud.licensemanager.v1.LicenseManager/AggregateUsage"
	LicenseManager_ListProducts_FullMethodName                   = "/google.cloud.licensemanager.v1.LicenseManager/ListProducts"
	LicenseManager_GetProduct_FullMethodName                     = "/google.cloud.licensemanager.v1.LicenseManager/GetProduct"
)

// LicenseManagerClient is the client API for LicenseManager service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LicenseManagerClient interface {
	// Lists Configurations in a given project and location.
	ListConfigurations(ctx context.Context, in *ListConfigurationsRequest, opts ...grpc.CallOption) (*ListConfigurationsResponse, error)
	// Gets details of a single Configuration.
	GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...grpc.CallOption) (*Configuration, error)
	// Creates a new Configuration in a given project and location.
	CreateConfiguration(ctx context.Context, in *CreateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Updates the parameters of a single Configuration.
	UpdateConfiguration(ctx context.Context, in *UpdateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Deletes a single Configuration.
	DeleteConfiguration(ctx context.Context, in *DeleteConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Lists Instances in a given project and location.
	ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error)
	// Gets details of a single Instance.
	GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*Instance, error)
	// Deactivates the given configuration.
	DeactivateConfiguration(ctx context.Context, in *DeactivateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// Reactivates the given configuration.
	ReactivateConfiguration(ctx context.Context, in *ReactivateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error)
	// License Usage information for a Configuration.
	QueryConfigurationLicenseUsage(ctx context.Context, in *QueryConfigurationLicenseUsageRequest, opts ...grpc.CallOption) (*QueryConfigurationLicenseUsageResponse, error)
	// Aggregates Usage per Instance for a Configuration.
	AggregateUsage(ctx context.Context, in *AggregateUsageRequest, opts ...grpc.CallOption) (*AggregateUsageResponse, error)
	// Lists Products in a given project and location.
	ListProducts(ctx context.Context, in *ListProductsRequest, opts ...grpc.CallOption) (*ListProductsResponse, error)
	// Gets details of a single Product.
	GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error)
}

type licenseManagerClient struct {
	cc grpc.ClientConnInterface
}

func NewLicenseManagerClient(cc grpc.ClientConnInterface) LicenseManagerClient {
	return &licenseManagerClient{cc}
}

func (c *licenseManagerClient) ListConfigurations(ctx context.Context, in *ListConfigurationsRequest, opts ...grpc.CallOption) (*ListConfigurationsResponse, error) {
	out := new(ListConfigurationsResponse)
	err := c.cc.Invoke(ctx, LicenseManager_ListConfigurations_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) GetConfiguration(ctx context.Context, in *GetConfigurationRequest, opts ...grpc.CallOption) (*Configuration, error) {
	out := new(Configuration)
	err := c.cc.Invoke(ctx, LicenseManager_GetConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) CreateConfiguration(ctx context.Context, in *CreateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, LicenseManager_CreateConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) UpdateConfiguration(ctx context.Context, in *UpdateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, LicenseManager_UpdateConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) DeleteConfiguration(ctx context.Context, in *DeleteConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, LicenseManager_DeleteConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) ListInstances(ctx context.Context, in *ListInstancesRequest, opts ...grpc.CallOption) (*ListInstancesResponse, error) {
	out := new(ListInstancesResponse)
	err := c.cc.Invoke(ctx, LicenseManager_ListInstances_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) GetInstance(ctx context.Context, in *GetInstanceRequest, opts ...grpc.CallOption) (*Instance, error) {
	out := new(Instance)
	err := c.cc.Invoke(ctx, LicenseManager_GetInstance_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) DeactivateConfiguration(ctx context.Context, in *DeactivateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, LicenseManager_DeactivateConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) ReactivateConfiguration(ctx context.Context, in *ReactivateConfigurationRequest, opts ...grpc.CallOption) (*longrunningpb.Operation, error) {
	out := new(longrunningpb.Operation)
	err := c.cc.Invoke(ctx, LicenseManager_ReactivateConfiguration_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) QueryConfigurationLicenseUsage(ctx context.Context, in *QueryConfigurationLicenseUsageRequest, opts ...grpc.CallOption) (*QueryConfigurationLicenseUsageResponse, error) {
	out := new(QueryConfigurationLicenseUsageResponse)
	err := c.cc.Invoke(ctx, LicenseManager_QueryConfigurationLicenseUsage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) AggregateUsage(ctx context.Context, in *AggregateUsageRequest, opts ...grpc.CallOption) (*AggregateUsageResponse, error) {
	out := new(AggregateUsageResponse)
	err := c.cc.Invoke(ctx, LicenseManager_AggregateUsage_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) ListProducts(ctx context.Context, in *ListProductsRequest, opts ...grpc.CallOption) (*ListProductsResponse, error) {
	out := new(ListProductsResponse)
	err := c.cc.Invoke(ctx, LicenseManager_ListProducts_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *licenseManagerClient) GetProduct(ctx context.Context, in *GetProductRequest, opts ...grpc.CallOption) (*Product, error) {
	out := new(Product)
	err := c.cc.Invoke(ctx, LicenseManager_GetProduct_FullMethodName, in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LicenseManagerServer is the server API for LicenseManager service.
// All implementations should embed UnimplementedLicenseManagerServer
// for forward compatibility
type LicenseManagerServer interface {
	// Lists Configurations in a given project and location.
	ListConfigurations(context.Context, *ListConfigurationsRequest) (*ListConfigurationsResponse, error)
	// Gets details of a single Configuration.
	GetConfiguration(context.Context, *GetConfigurationRequest) (*Configuration, error)
	// Creates a new Configuration in a given project and location.
	CreateConfiguration(context.Context, *CreateConfigurationRequest) (*longrunningpb.Operation, error)
	// Updates the parameters of a single Configuration.
	UpdateConfiguration(context.Context, *UpdateConfigurationRequest) (*longrunningpb.Operation, error)
	// Deletes a single Configuration.
	DeleteConfiguration(context.Context, *DeleteConfigurationRequest) (*longrunningpb.Operation, error)
	// Lists Instances in a given project and location.
	ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error)
	// Gets details of a single Instance.
	GetInstance(context.Context, *GetInstanceRequest) (*Instance, error)
	// Deactivates the given configuration.
	DeactivateConfiguration(context.Context, *DeactivateConfigurationRequest) (*longrunningpb.Operation, error)
	// Reactivates the given configuration.
	ReactivateConfiguration(context.Context, *ReactivateConfigurationRequest) (*longrunningpb.Operation, error)
	// License Usage information for a Configuration.
	QueryConfigurationLicenseUsage(context.Context, *QueryConfigurationLicenseUsageRequest) (*QueryConfigurationLicenseUsageResponse, error)
	// Aggregates Usage per Instance for a Configuration.
	AggregateUsage(context.Context, *AggregateUsageRequest) (*AggregateUsageResponse, error)
	// Lists Products in a given project and location.
	ListProducts(context.Context, *ListProductsRequest) (*ListProductsResponse, error)
	// Gets details of a single Product.
	GetProduct(context.Context, *GetProductRequest) (*Product, error)
}

// UnimplementedLicenseManagerServer should be embedded to have forward compatible implementations.
type UnimplementedLicenseManagerServer struct {
}

func (UnimplementedLicenseManagerServer) ListConfigurations(context.Context, *ListConfigurationsRequest) (*ListConfigurationsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConfigurations not implemented")
}
func (UnimplementedLicenseManagerServer) GetConfiguration(context.Context, *GetConfigurationRequest) (*Configuration, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConfiguration not implemented")
}
func (UnimplementedLicenseManagerServer) CreateConfiguration(context.Context, *CreateConfigurationRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConfiguration not implemented")
}
func (UnimplementedLicenseManagerServer) UpdateConfiguration(context.Context, *UpdateConfigurationRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateConfiguration not implemented")
}
func (UnimplementedLicenseManagerServer) DeleteConfiguration(context.Context, *DeleteConfigurationRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeleteConfiguration not implemented")
}
func (UnimplementedLicenseManagerServer) ListInstances(context.Context, *ListInstancesRequest) (*ListInstancesResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListInstances not implemented")
}
func (UnimplementedLicenseManagerServer) GetInstance(context.Context, *GetInstanceRequest) (*Instance, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetInstance not implemented")
}
func (UnimplementedLicenseManagerServer) DeactivateConfiguration(context.Context, *DeactivateConfigurationRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeactivateConfiguration not implemented")
}
func (UnimplementedLicenseManagerServer) ReactivateConfiguration(context.Context, *ReactivateConfigurationRequest) (*longrunningpb.Operation, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReactivateConfiguration not implemented")
}
func (UnimplementedLicenseManagerServer) QueryConfigurationLicenseUsage(context.Context, *QueryConfigurationLicenseUsageRequest) (*QueryConfigurationLicenseUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method QueryConfigurationLicenseUsage not implemented")
}
func (UnimplementedLicenseManagerServer) AggregateUsage(context.Context, *AggregateUsageRequest) (*AggregateUsageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AggregateUsage not implemented")
}
func (UnimplementedLicenseManagerServer) ListProducts(context.Context, *ListProductsRequest) (*ListProductsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListProducts not implemented")
}
func (UnimplementedLicenseManagerServer) GetProduct(context.Context, *GetProductRequest) (*Product, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetProduct not implemented")
}

// UnsafeLicenseManagerServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LicenseManagerServer will
// result in compilation errors.
type UnsafeLicenseManagerServer interface {
	mustEmbedUnimplementedLicenseManagerServer()
}

func RegisterLicenseManagerServer(s grpc.ServiceRegistrar, srv LicenseManagerServer) {
	s.RegisterService(&LicenseManager_ServiceDesc, srv)
}

func _LicenseManager_ListConfigurations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConfigurationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).ListConfigurations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_ListConfigurations_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).ListConfigurations(ctx, req.(*ListConfigurationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_GetConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).GetConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_GetConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).GetConfiguration(ctx, req.(*GetConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_CreateConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).CreateConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_CreateConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).CreateConfiguration(ctx, req.(*CreateConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_UpdateConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).UpdateConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_UpdateConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).UpdateConfiguration(ctx, req.(*UpdateConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_DeleteConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeleteConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).DeleteConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_DeleteConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).DeleteConfiguration(ctx, req.(*DeleteConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_ListInstances_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListInstancesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).ListInstances(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_ListInstances_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).ListInstances(ctx, req.(*ListInstancesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_GetInstance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetInstanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).GetInstance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_GetInstance_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).GetInstance(ctx, req.(*GetInstanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_DeactivateConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeactivateConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).DeactivateConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_DeactivateConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).DeactivateConfiguration(ctx, req.(*DeactivateConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_ReactivateConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReactivateConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).ReactivateConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_ReactivateConfiguration_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).ReactivateConfiguration(ctx, req.(*ReactivateConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_QueryConfigurationLicenseUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(QueryConfigurationLicenseUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).QueryConfigurationLicenseUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_QueryConfigurationLicenseUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).QueryConfigurationLicenseUsage(ctx, req.(*QueryConfigurationLicenseUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_AggregateUsage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AggregateUsageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).AggregateUsage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_AggregateUsage_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).AggregateUsage(ctx, req.(*AggregateUsageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_ListProducts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListProductsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).ListProducts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_ListProducts_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).ListProducts(ctx, req.(*ListProductsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LicenseManager_GetProduct_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetProductRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LicenseManagerServer).GetProduct(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: LicenseManager_GetProduct_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LicenseManagerServer).GetProduct(ctx, req.(*GetProductRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// LicenseManager_ServiceDesc is the grpc.ServiceDesc for LicenseManager service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var LicenseManager_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "google.cloud.licensemanager.v1.LicenseManager",
	HandlerType: (*LicenseManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListConfigurations",
			Handler:    _LicenseManager_ListConfigurations_Handler,
		},
		{
			MethodName: "GetConfiguration",
			Handler:    _LicenseManager_GetConfiguration_Handler,
		},
		{
			MethodName: "CreateConfiguration",
			Handler:    _LicenseManager_CreateConfiguration_Handler,
		},
		{
			MethodName: "UpdateConfiguration",
			Handler:    _LicenseManager_UpdateConfiguration_Handler,
		},
		{
			MethodName: "DeleteConfiguration",
			Handler:    _LicenseManager_DeleteConfiguration_Handler,
		},
		{
			MethodName: "ListInstances",
			Handler:    _LicenseManager_ListInstances_Handler,
		},
		{
			MethodName: "GetInstance",
			Handler:    _LicenseManager_GetInstance_Handler,
		},
		{
			MethodName: "DeactivateConfiguration",
			Handler:    _LicenseManager_DeactivateConfiguration_Handler,
		},
		{
			MethodName: "ReactivateConfiguration",
			Handler:    _LicenseManager_ReactivateConfiguration_Handler,
		},
		{
			MethodName: "QueryConfigurationLicenseUsage",
			Handler:    _LicenseManager_QueryConfigurationLicenseUsage_Handler,
		},
		{
			MethodName: "AggregateUsage",
			Handler:    _LicenseManager_AggregateUsage_Handler,
		},
		{
			MethodName: "ListProducts",
			Handler:    _LicenseManager_ListProducts_Handler,
		},
		{
			MethodName: "GetProduct",
			Handler:    _LicenseManager_GetProduct_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "google/cloud/licensemanager/v1/licensemanager.proto",
}
