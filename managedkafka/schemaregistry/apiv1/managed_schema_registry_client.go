// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Code generated by protoc-gen-go_gapic. DO NOT EDIT.

package schemaregistry

import (
	"bytes"
	"context"
	"fmt"
	"log/slog"
	"math"
	"net/http"
	"net/url"

	longrunningpb "cloud.google.com/go/longrunning/autogen/longrunningpb"
	schemaregistrypb "cloud.google.com/go/managedkafka/schemaregistry/apiv1/schemaregistrypb"
	gax "github.com/googleapis/gax-go/v2"
	"google.golang.org/api/iterator"
	"google.golang.org/api/option"
	"google.golang.org/api/option/internaloption"
	gtransport "google.golang.org/api/transport/grpc"
	httptransport "google.golang.org/api/transport/http"
	httpbodypb "google.golang.org/genproto/googleapis/api/httpbody"
	locationpb "google.golang.org/genproto/googleapis/cloud/location"
	"google.golang.org/grpc"
	"google.golang.org/protobuf/encoding/protojson"
	"google.golang.org/protobuf/proto"
)

var newManagedSchemaRegistryClientHook clientHook

// ManagedSchemaRegistryCallOptions contains the retry settings for each method of ManagedSchemaRegistryClient.
type ManagedSchemaRegistryCallOptions struct {
	GetSchemaRegistry      []gax.CallOption
	ListSchemaRegistries   []gax.CallOption
	CreateSchemaRegistry   []gax.CallOption
	DeleteSchemaRegistry   []gax.CallOption
	GetContext             []gax.CallOption
	ListContexts           []gax.CallOption
	GetSchema              []gax.CallOption
	GetRawSchema           []gax.CallOption
	ListSchemaVersions     []gax.CallOption
	ListSchemaTypes        []gax.CallOption
	ListSubjects           []gax.CallOption
	ListSubjectsBySchemaId []gax.CallOption
	DeleteSubject          []gax.CallOption
	LookupVersion          []gax.CallOption
	GetVersion             []gax.CallOption
	GetRawSchemaVersion    []gax.CallOption
	ListVersions           []gax.CallOption
	CreateVersion          []gax.CallOption
	DeleteVersion          []gax.CallOption
	ListReferencedSchemas  []gax.CallOption
	CheckCompatibility     []gax.CallOption
	GetSchemaConfig        []gax.CallOption
	UpdateSchemaConfig     []gax.CallOption
	DeleteSchemaConfig     []gax.CallOption
	GetSchemaMode          []gax.CallOption
	UpdateSchemaMode       []gax.CallOption
	DeleteSchemaMode       []gax.CallOption
	GetLocation            []gax.CallOption
	ListLocations          []gax.CallOption
	CancelOperation        []gax.CallOption
	DeleteOperation        []gax.CallOption
	GetOperation           []gax.CallOption
	ListOperations         []gax.CallOption
}

func defaultManagedSchemaRegistryGRPCClientOptions() []option.ClientOption {
	return []option.ClientOption{
		internaloption.WithDefaultEndpoint("managedkafka.googleapis.com:443"),
		internaloption.WithDefaultEndpointTemplate("managedkafka.UNIVERSE_DOMAIN:443"),
		internaloption.WithDefaultMTLSEndpoint("managedkafka.mtls.googleapis.com:443"),
		internaloption.WithDefaultUniverseDomain("googleapis.com"),
		internaloption.WithDefaultAudience("https://managedkafka.googleapis.com/"),
		internaloption.WithDefaultScopes(DefaultAuthScopes()...),
		internaloption.EnableJwtWithScope(),
		internaloption.EnableNewAuthLibrary(),
		option.WithGRPCDialOption(grpc.WithDefaultCallOptions(
			grpc.MaxCallRecvMsgSize(math.MaxInt32))),
	}
}

func defaultManagedSchemaRegistryCallOptions() *ManagedSchemaRegistryCallOptions {
	return &ManagedSchemaRegistryCallOptions{
		GetSchemaRegistry:      []gax.CallOption{},
		ListSchemaRegistries:   []gax.CallOption{},
		CreateSchemaRegistry:   []gax.CallOption{},
		DeleteSchemaRegistry:   []gax.CallOption{},
		GetContext:             []gax.CallOption{},
		ListContexts:           []gax.CallOption{},
		GetSchema:              []gax.CallOption{},
		GetRawSchema:           []gax.CallOption{},
		ListSchemaVersions:     []gax.CallOption{},
		ListSchemaTypes:        []gax.CallOption{},
		ListSubjects:           []gax.CallOption{},
		ListSubjectsBySchemaId: []gax.CallOption{},
		DeleteSubject:          []gax.CallOption{},
		LookupVersion:          []gax.CallOption{},
		GetVersion:             []gax.CallOption{},
		GetRawSchemaVersion:    []gax.CallOption{},
		ListVersions:           []gax.CallOption{},
		CreateVersion:          []gax.CallOption{},
		DeleteVersion:          []gax.CallOption{},
		ListReferencedSchemas:  []gax.CallOption{},
		CheckCompatibility:     []gax.CallOption{},
		GetSchemaConfig:        []gax.CallOption{},
		UpdateSchemaConfig:     []gax.CallOption{},
		DeleteSchemaConfig:     []gax.CallOption{},
		GetSchemaMode:          []gax.CallOption{},
		UpdateSchemaMode:       []gax.CallOption{},
		DeleteSchemaMode:       []gax.CallOption{},
		GetLocation:            []gax.CallOption{},
		ListLocations:          []gax.CallOption{},
		CancelOperation:        []gax.CallOption{},
		DeleteOperation:        []gax.CallOption{},
		GetOperation:           []gax.CallOption{},
		ListOperations:         []gax.CallOption{},
	}
}

func defaultManagedSchemaRegistryRESTCallOptions() *ManagedSchemaRegistryCallOptions {
	return &ManagedSchemaRegistryCallOptions{
		GetSchemaRegistry:      []gax.CallOption{},
		ListSchemaRegistries:   []gax.CallOption{},
		CreateSchemaRegistry:   []gax.CallOption{},
		DeleteSchemaRegistry:   []gax.CallOption{},
		GetContext:             []gax.CallOption{},
		ListContexts:           []gax.CallOption{},
		GetSchema:              []gax.CallOption{},
		GetRawSchema:           []gax.CallOption{},
		ListSchemaVersions:     []gax.CallOption{},
		ListSchemaTypes:        []gax.CallOption{},
		ListSubjects:           []gax.CallOption{},
		ListSubjectsBySchemaId: []gax.CallOption{},
		DeleteSubject:          []gax.CallOption{},
		LookupVersion:          []gax.CallOption{},
		GetVersion:             []gax.CallOption{},
		GetRawSchemaVersion:    []gax.CallOption{},
		ListVersions:           []gax.CallOption{},
		CreateVersion:          []gax.CallOption{},
		DeleteVersion:          []gax.CallOption{},
		ListReferencedSchemas:  []gax.CallOption{},
		CheckCompatibility:     []gax.CallOption{},
		GetSchemaConfig:        []gax.CallOption{},
		UpdateSchemaConfig:     []gax.CallOption{},
		DeleteSchemaConfig:     []gax.CallOption{},
		GetSchemaMode:          []gax.CallOption{},
		UpdateSchemaMode:       []gax.CallOption{},
		DeleteSchemaMode:       []gax.CallOption{},
		GetLocation:            []gax.CallOption{},
		ListLocations:          []gax.CallOption{},
		CancelOperation:        []gax.CallOption{},
		DeleteOperation:        []gax.CallOption{},
		GetOperation:           []gax.CallOption{},
		ListOperations:         []gax.CallOption{},
	}
}

// internalManagedSchemaRegistryClient is an interface that defines the methods available from Managed Service for Apache Kafka API.
type internalManagedSchemaRegistryClient interface {
	Close() error
	setGoogleClientInfo(...string)
	Connection() *grpc.ClientConn
	GetSchemaRegistry(context.Context, *schemaregistrypb.GetSchemaRegistryRequest, ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error)
	ListSchemaRegistries(context.Context, *schemaregistrypb.ListSchemaRegistriesRequest, ...gax.CallOption) (*schemaregistrypb.ListSchemaRegistriesResponse, error)
	CreateSchemaRegistry(context.Context, *schemaregistrypb.CreateSchemaRegistryRequest, ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error)
	DeleteSchemaRegistry(context.Context, *schemaregistrypb.DeleteSchemaRegistryRequest, ...gax.CallOption) error
	GetContext(context.Context, *schemaregistrypb.GetContextRequest, ...gax.CallOption) (*schemaregistrypb.Context, error)
	ListContexts(context.Context, *schemaregistrypb.ListContextsRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	GetSchema(context.Context, *schemaregistrypb.GetSchemaRequest, ...gax.CallOption) (*schemaregistrypb.Schema, error)
	GetRawSchema(context.Context, *schemaregistrypb.GetSchemaRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	ListSchemaVersions(context.Context, *schemaregistrypb.ListSchemaVersionsRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	ListSchemaTypes(context.Context, *schemaregistrypb.ListSchemaTypesRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	ListSubjects(context.Context, *schemaregistrypb.ListSubjectsRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	ListSubjectsBySchemaId(context.Context, *schemaregistrypb.ListSubjectsBySchemaIdRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	DeleteSubject(context.Context, *schemaregistrypb.DeleteSubjectRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	LookupVersion(context.Context, *schemaregistrypb.LookupVersionRequest, ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error)
	GetVersion(context.Context, *schemaregistrypb.GetVersionRequest, ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error)
	GetRawSchemaVersion(context.Context, *schemaregistrypb.GetVersionRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	ListVersions(context.Context, *schemaregistrypb.ListVersionsRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	CreateVersion(context.Context, *schemaregistrypb.CreateVersionRequest, ...gax.CallOption) (*schemaregistrypb.CreateVersionResponse, error)
	DeleteVersion(context.Context, *schemaregistrypb.DeleteVersionRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	ListReferencedSchemas(context.Context, *schemaregistrypb.ListReferencedSchemasRequest, ...gax.CallOption) (*httpbodypb.HttpBody, error)
	CheckCompatibility(context.Context, *schemaregistrypb.CheckCompatibilityRequest, ...gax.CallOption) (*schemaregistrypb.CheckCompatibilityResponse, error)
	GetSchemaConfig(context.Context, *schemaregistrypb.GetSchemaConfigRequest, ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error)
	UpdateSchemaConfig(context.Context, *schemaregistrypb.UpdateSchemaConfigRequest, ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error)
	DeleteSchemaConfig(context.Context, *schemaregistrypb.DeleteSchemaConfigRequest, ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error)
	GetSchemaMode(context.Context, *schemaregistrypb.GetSchemaModeRequest, ...gax.CallOption) (*schemaregistrypb.SchemaMode, error)
	UpdateSchemaMode(context.Context, *schemaregistrypb.UpdateSchemaModeRequest, ...gax.CallOption) (*schemaregistrypb.SchemaMode, error)
	DeleteSchemaMode(context.Context, *schemaregistrypb.DeleteSchemaModeRequest, ...gax.CallOption) (*schemaregistrypb.SchemaMode, error)
	GetLocation(context.Context, *locationpb.GetLocationRequest, ...gax.CallOption) (*locationpb.Location, error)
	ListLocations(context.Context, *locationpb.ListLocationsRequest, ...gax.CallOption) *LocationIterator
	CancelOperation(context.Context, *longrunningpb.CancelOperationRequest, ...gax.CallOption) error
	DeleteOperation(context.Context, *longrunningpb.DeleteOperationRequest, ...gax.CallOption) error
	GetOperation(context.Context, *longrunningpb.GetOperationRequest, ...gax.CallOption) (*longrunningpb.Operation, error)
	ListOperations(context.Context, *longrunningpb.ListOperationsRequest, ...gax.CallOption) *OperationIterator
}

// ManagedSchemaRegistryClient is a client for interacting with Managed Service for Apache Kafka API.
// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
//
// SchemaRegistry is a service that allows users to manage schemas for their
// Kafka clusters. It provides APIs to register, list, and delete schemas, as
// well as to get the schema for a given schema id or a given version id under a
// subject, to update the global or subject-specific compatibility mode, and to
// check the compatibility of a schema against a subject or a version. The main
// resource hierarchy is as follows:
//
//	SchemaRegistry
//
//	SchemaRegistry/Context
//
//	SchemaRegistry/Context/Schema
//
//	SchemaRegistry/Context/Subject
//
//	SchemaRegistry/Context/Subject/Version
//
//	SchemaRegistry/Config
//
//	SchemaRegistry/Mode
//
// SchemaRegistry is the root resource to represent a schema registry
// instance. A customer can have multiple schema registry instances in a
// project.
//
// Context is a context resource that represents a group of
// schemas, subjects and versions. A schema registry instance can have multiple
// contexts and always has a ‘default’ context. Contexts are independent of each
// other. Context is optional and if not specified, it falls back to the
// ‘default’ context.
//
// Schema is a schema resource that represents a unique schema in a context
// of a schema registry instance. Each schema has a unique schema id, and can be
// referenced by a version of a subject.
//
// Subject refers to the name under which the schema is registered. A
// typical subject is the Kafka topic name. A schema registry instance can have
// multiple subjects.
//
// Version represents a version of a subject. A subject can have multiple
// versions. Creation of new version of a subject is guarded by the
// compatibility mode configured globally or for the subject specifically.
//
// Config represents a config at global level cross all registry
// instances or at subject level. Currently, only compatibility is supported in
// config.
//
// Mode represents the mode of a schema registry or a specific subject.
// Three modes are supported:
//
//	READONLY: The schema registry is in read-only mode, no write operations
//	allowed…
//
//	READWRITE: The schema registry is in read-write mode, which allows limited
//	write operations on the schema.
//
//	IMPORT: The schema registry is in import mode, which allows more editing
//	operations on the schema for data importing purposes.
type ManagedSchemaRegistryClient struct {
	// The internal transport-dependent client.
	internalClient internalManagedSchemaRegistryClient

	// The call options for this service.
	CallOptions *ManagedSchemaRegistryCallOptions
}

// Wrapper methods routed to the internal client.

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *ManagedSchemaRegistryClient) Close() error {
	return c.internalClient.Close()
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *ManagedSchemaRegistryClient) setGoogleClientInfo(keyval ...string) {
	c.internalClient.setGoogleClientInfo(keyval...)
}

// Connection returns a connection to the API service.
//
// Deprecated: Connections are now pooled so this method does not always
// return the same resource.
func (c *ManagedSchemaRegistryClient) Connection() *grpc.ClientConn {
	return c.internalClient.Connection()
}

// GetSchemaRegistry get the schema registry instance.
func (c *ManagedSchemaRegistryClient) GetSchemaRegistry(ctx context.Context, req *schemaregistrypb.GetSchemaRegistryRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error) {
	return c.internalClient.GetSchemaRegistry(ctx, req, opts...)
}

// ListSchemaRegistries list schema registries.
func (c *ManagedSchemaRegistryClient) ListSchemaRegistries(ctx context.Context, req *schemaregistrypb.ListSchemaRegistriesRequest, opts ...gax.CallOption) (*schemaregistrypb.ListSchemaRegistriesResponse, error) {
	return c.internalClient.ListSchemaRegistries(ctx, req, opts...)
}

// CreateSchemaRegistry create a schema registry instance.
func (c *ManagedSchemaRegistryClient) CreateSchemaRegistry(ctx context.Context, req *schemaregistrypb.CreateSchemaRegistryRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error) {
	return c.internalClient.CreateSchemaRegistry(ctx, req, opts...)
}

// DeleteSchemaRegistry delete a schema registry instance.
func (c *ManagedSchemaRegistryClient) DeleteSchemaRegistry(ctx context.Context, req *schemaregistrypb.DeleteSchemaRegistryRequest, opts ...gax.CallOption) error {
	return c.internalClient.DeleteSchemaRegistry(ctx, req, opts...)
}

// GetContext get the context.
func (c *ManagedSchemaRegistryClient) GetContext(ctx context.Context, req *schemaregistrypb.GetContextRequest, opts ...gax.CallOption) (*schemaregistrypb.Context, error) {
	return c.internalClient.GetContext(ctx, req, opts...)
}

// ListContexts list contexts for a schema registry.
func (c *ManagedSchemaRegistryClient) ListContexts(ctx context.Context, req *schemaregistrypb.ListContextsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListContexts(ctx, req, opts...)
}

// GetSchema get the schema for the given schema id.
func (c *ManagedSchemaRegistryClient) GetSchema(ctx context.Context, req *schemaregistrypb.GetSchemaRequest, opts ...gax.CallOption) (*schemaregistrypb.Schema, error) {
	return c.internalClient.GetSchema(ctx, req, opts...)
}

// GetRawSchema get the schema string for the given schema id.
// The response will be the schema string.
func (c *ManagedSchemaRegistryClient) GetRawSchema(ctx context.Context, req *schemaregistrypb.GetSchemaRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.GetRawSchema(ctx, req, opts...)
}

// ListSchemaVersions list the schema versions for the given schema id.
// The response will be an array of subject-version pairs as:
// [{“subject”:“subject1”, “version”:1}, {“subject”:“subject2”, “version”:2}].
func (c *ManagedSchemaRegistryClient) ListSchemaVersions(ctx context.Context, req *schemaregistrypb.ListSchemaVersionsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListSchemaVersions(ctx, req, opts...)
}

// ListSchemaTypes list the supported schema types.
// The response will be an array of schema types.
func (c *ManagedSchemaRegistryClient) ListSchemaTypes(ctx context.Context, req *schemaregistrypb.ListSchemaTypesRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListSchemaTypes(ctx, req, opts...)
}

// ListSubjects list subjects in the schema registry.
// The response will be an array of subject names.
func (c *ManagedSchemaRegistryClient) ListSubjects(ctx context.Context, req *schemaregistrypb.ListSubjectsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListSubjects(ctx, req, opts...)
}

// ListSubjectsBySchemaId list subjects which reference a particular schema id.
// The response will be an array of subject names.
func (c *ManagedSchemaRegistryClient) ListSubjectsBySchemaId(ctx context.Context, req *schemaregistrypb.ListSubjectsBySchemaIdRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListSubjectsBySchemaId(ctx, req, opts...)
}

// DeleteSubject delete a subject.
// The response will be an array of versions of the deleted subject.
func (c *ManagedSchemaRegistryClient) DeleteSubject(ctx context.Context, req *schemaregistrypb.DeleteSubjectRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.DeleteSubject(ctx, req, opts...)
}

// LookupVersion lookup a schema under the specified subject.
func (c *ManagedSchemaRegistryClient) LookupVersion(ctx context.Context, req *schemaregistrypb.LookupVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error) {
	return c.internalClient.LookupVersion(ctx, req, opts...)
}

// GetVersion get a versioned schema (schema with subject/version) of a subject.
func (c *ManagedSchemaRegistryClient) GetVersion(ctx context.Context, req *schemaregistrypb.GetVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error) {
	return c.internalClient.GetVersion(ctx, req, opts...)
}

// GetRawSchemaVersion get the schema string only for a version of a subject.
// The response will be the schema string.
func (c *ManagedSchemaRegistryClient) GetRawSchemaVersion(ctx context.Context, req *schemaregistrypb.GetVersionRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.GetRawSchemaVersion(ctx, req, opts...)
}

// ListVersions get all versions of a subject.
// The response will be an array of versions of the subject.
func (c *ManagedSchemaRegistryClient) ListVersions(ctx context.Context, req *schemaregistrypb.ListVersionsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListVersions(ctx, req, opts...)
}

// CreateVersion register a new version under a given subject with the given schema.
func (c *ManagedSchemaRegistryClient) CreateVersion(ctx context.Context, req *schemaregistrypb.CreateVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.CreateVersionResponse, error) {
	return c.internalClient.CreateVersion(ctx, req, opts...)
}

// DeleteVersion delete a version of a subject.
// The response will be the deleted version id.
func (c *ManagedSchemaRegistryClient) DeleteVersion(ctx context.Context, req *schemaregistrypb.DeleteVersionRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.DeleteVersion(ctx, req, opts...)
}

// ListReferencedSchemas get a list of IDs of schemas that reference the schema with the given
// subject and version.
func (c *ManagedSchemaRegistryClient) ListReferencedSchemas(ctx context.Context, req *schemaregistrypb.ListReferencedSchemasRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	return c.internalClient.ListReferencedSchemas(ctx, req, opts...)
}

// CheckCompatibility check compatibility of a schema with all versions or a specific version of
// a subject.
func (c *ManagedSchemaRegistryClient) CheckCompatibility(ctx context.Context, req *schemaregistrypb.CheckCompatibilityRequest, opts ...gax.CallOption) (*schemaregistrypb.CheckCompatibilityResponse, error) {
	return c.internalClient.CheckCompatibility(ctx, req, opts...)
}

// GetSchemaConfig get schema config at global level or for a subject.
func (c *ManagedSchemaRegistryClient) GetSchemaConfig(ctx context.Context, req *schemaregistrypb.GetSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	return c.internalClient.GetSchemaConfig(ctx, req, opts...)
}

// UpdateSchemaConfig update config at global level or for a subject.
// Creates a SchemaSubject-level SchemaConfig if it does not exist.
func (c *ManagedSchemaRegistryClient) UpdateSchemaConfig(ctx context.Context, req *schemaregistrypb.UpdateSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	return c.internalClient.UpdateSchemaConfig(ctx, req, opts...)
}

// DeleteSchemaConfig delete schema config for a subject.
func (c *ManagedSchemaRegistryClient) DeleteSchemaConfig(ctx context.Context, req *schemaregistrypb.DeleteSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	return c.internalClient.DeleteSchemaConfig(ctx, req, opts...)
}

// GetSchemaMode get mode at global level or for a subject.
func (c *ManagedSchemaRegistryClient) GetSchemaMode(ctx context.Context, req *schemaregistrypb.GetSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	return c.internalClient.GetSchemaMode(ctx, req, opts...)
}

// UpdateSchemaMode update mode at global level or for a subject.
func (c *ManagedSchemaRegistryClient) UpdateSchemaMode(ctx context.Context, req *schemaregistrypb.UpdateSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	return c.internalClient.UpdateSchemaMode(ctx, req, opts...)
}

// DeleteSchemaMode delete schema mode for a subject.
func (c *ManagedSchemaRegistryClient) DeleteSchemaMode(ctx context.Context, req *schemaregistrypb.DeleteSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	return c.internalClient.DeleteSchemaMode(ctx, req, opts...)
}

// GetLocation gets information about a location.
func (c *ManagedSchemaRegistryClient) GetLocation(ctx context.Context, req *locationpb.GetLocationRequest, opts ...gax.CallOption) (*locationpb.Location, error) {
	return c.internalClient.GetLocation(ctx, req, opts...)
}

// ListLocations lists information about the supported locations for this service.
func (c *ManagedSchemaRegistryClient) ListLocations(ctx context.Context, req *locationpb.ListLocationsRequest, opts ...gax.CallOption) *LocationIterator {
	return c.internalClient.ListLocations(ctx, req, opts...)
}

// CancelOperation is a utility method from google.longrunning.Operations.
func (c *ManagedSchemaRegistryClient) CancelOperation(ctx context.Context, req *longrunningpb.CancelOperationRequest, opts ...gax.CallOption) error {
	return c.internalClient.CancelOperation(ctx, req, opts...)
}

// DeleteOperation is a utility method from google.longrunning.Operations.
func (c *ManagedSchemaRegistryClient) DeleteOperation(ctx context.Context, req *longrunningpb.DeleteOperationRequest, opts ...gax.CallOption) error {
	return c.internalClient.DeleteOperation(ctx, req, opts...)
}

// GetOperation is a utility method from google.longrunning.Operations.
func (c *ManagedSchemaRegistryClient) GetOperation(ctx context.Context, req *longrunningpb.GetOperationRequest, opts ...gax.CallOption) (*longrunningpb.Operation, error) {
	return c.internalClient.GetOperation(ctx, req, opts...)
}

// ListOperations is a utility method from google.longrunning.Operations.
func (c *ManagedSchemaRegistryClient) ListOperations(ctx context.Context, req *longrunningpb.ListOperationsRequest, opts ...gax.CallOption) *OperationIterator {
	return c.internalClient.ListOperations(ctx, req, opts...)
}

// managedSchemaRegistryGRPCClient is a client for interacting with Managed Service for Apache Kafka API over gRPC transport.
//
// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
type managedSchemaRegistryGRPCClient struct {
	// Connection pool of gRPC connections to the service.
	connPool gtransport.ConnPool

	// Points back to the CallOptions field of the containing ManagedSchemaRegistryClient
	CallOptions **ManagedSchemaRegistryCallOptions

	// The gRPC API client.
	managedSchemaRegistryClient schemaregistrypb.ManagedSchemaRegistryClient

	operationsClient longrunningpb.OperationsClient

	locationsClient locationpb.LocationsClient

	// The x-goog-* metadata to be sent with each request.
	xGoogHeaders []string

	logger *slog.Logger
}

// NewManagedSchemaRegistryClient creates a new managed schema registry client based on gRPC.
// The returned client must be Closed when it is done being used to clean up its underlying connections.
//
// SchemaRegistry is a service that allows users to manage schemas for their
// Kafka clusters. It provides APIs to register, list, and delete schemas, as
// well as to get the schema for a given schema id or a given version id under a
// subject, to update the global or subject-specific compatibility mode, and to
// check the compatibility of a schema against a subject or a version. The main
// resource hierarchy is as follows:
//
//	SchemaRegistry
//
//	SchemaRegistry/Context
//
//	SchemaRegistry/Context/Schema
//
//	SchemaRegistry/Context/Subject
//
//	SchemaRegistry/Context/Subject/Version
//
//	SchemaRegistry/Config
//
//	SchemaRegistry/Mode
//
// SchemaRegistry is the root resource to represent a schema registry
// instance. A customer can have multiple schema registry instances in a
// project.
//
// Context is a context resource that represents a group of
// schemas, subjects and versions. A schema registry instance can have multiple
// contexts and always has a ‘default’ context. Contexts are independent of each
// other. Context is optional and if not specified, it falls back to the
// ‘default’ context.
//
// Schema is a schema resource that represents a unique schema in a context
// of a schema registry instance. Each schema has a unique schema id, and can be
// referenced by a version of a subject.
//
// Subject refers to the name under which the schema is registered. A
// typical subject is the Kafka topic name. A schema registry instance can have
// multiple subjects.
//
// Version represents a version of a subject. A subject can have multiple
// versions. Creation of new version of a subject is guarded by the
// compatibility mode configured globally or for the subject specifically.
//
// Config represents a config at global level cross all registry
// instances or at subject level. Currently, only compatibility is supported in
// config.
//
// Mode represents the mode of a schema registry or a specific subject.
// Three modes are supported:
//
//	READONLY: The schema registry is in read-only mode, no write operations
//	allowed…
//
//	READWRITE: The schema registry is in read-write mode, which allows limited
//	write operations on the schema.
//
//	IMPORT: The schema registry is in import mode, which allows more editing
//	operations on the schema for data importing purposes.
func NewManagedSchemaRegistryClient(ctx context.Context, opts ...option.ClientOption) (*ManagedSchemaRegistryClient, error) {
	clientOpts := defaultManagedSchemaRegistryGRPCClientOptions()
	if newManagedSchemaRegistryClientHook != nil {
		hookOpts, err := newManagedSchemaRegistryClientHook(ctx, clientHookParams{})
		if err != nil {
			return nil, err
		}
		clientOpts = append(clientOpts, hookOpts...)
	}

	connPool, err := gtransport.DialPool(ctx, append(clientOpts, opts...)...)
	if err != nil {
		return nil, err
	}
	client := ManagedSchemaRegistryClient{CallOptions: defaultManagedSchemaRegistryCallOptions()}

	c := &managedSchemaRegistryGRPCClient{
		connPool:                    connPool,
		managedSchemaRegistryClient: schemaregistrypb.NewManagedSchemaRegistryClient(connPool),
		CallOptions:                 &client.CallOptions,
		logger:                      internaloption.GetLogger(opts),
		operationsClient:            longrunningpb.NewOperationsClient(connPool),
		locationsClient:             locationpb.NewLocationsClient(connPool),
	}
	c.setGoogleClientInfo()

	client.internalClient = c

	return &client, nil
}

// Connection returns a connection to the API service.
//
// Deprecated: Connections are now pooled so this method does not always
// return the same resource.
func (c *managedSchemaRegistryGRPCClient) Connection() *grpc.ClientConn {
	return c.connPool.Conn()
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *managedSchemaRegistryGRPCClient) setGoogleClientInfo(keyval ...string) {
	kv := append([]string{"gl-go", gax.GoVersion}, keyval...)
	kv = append(kv, "gapic", getVersionClient(), "gax", gax.Version, "grpc", grpc.Version, "pb", protoVersion)
	c.xGoogHeaders = []string{
		"x-goog-api-client", gax.XGoogHeader(kv...),
	}
}

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *managedSchemaRegistryGRPCClient) Close() error {
	return c.connPool.Close()
}

// Methods, except Close, may be called concurrently. However, fields must not be modified concurrently with method calls.
type managedSchemaRegistryRESTClient struct {
	// The http endpoint to connect to.
	endpoint string

	// The http client.
	httpClient *http.Client

	// The x-goog-* headers to be sent with each request.
	xGoogHeaders []string

	// Points back to the CallOptions field of the containing ManagedSchemaRegistryClient
	CallOptions **ManagedSchemaRegistryCallOptions

	logger *slog.Logger
}

// NewManagedSchemaRegistryRESTClient creates a new managed schema registry rest client.
//
// SchemaRegistry is a service that allows users to manage schemas for their
// Kafka clusters. It provides APIs to register, list, and delete schemas, as
// well as to get the schema for a given schema id or a given version id under a
// subject, to update the global or subject-specific compatibility mode, and to
// check the compatibility of a schema against a subject or a version. The main
// resource hierarchy is as follows:
//
//	SchemaRegistry
//
//	SchemaRegistry/Context
//
//	SchemaRegistry/Context/Schema
//
//	SchemaRegistry/Context/Subject
//
//	SchemaRegistry/Context/Subject/Version
//
//	SchemaRegistry/Config
//
//	SchemaRegistry/Mode
//
// SchemaRegistry is the root resource to represent a schema registry
// instance. A customer can have multiple schema registry instances in a
// project.
//
// Context is a context resource that represents a group of
// schemas, subjects and versions. A schema registry instance can have multiple
// contexts and always has a ‘default’ context. Contexts are independent of each
// other. Context is optional and if not specified, it falls back to the
// ‘default’ context.
//
// Schema is a schema resource that represents a unique schema in a context
// of a schema registry instance. Each schema has a unique schema id, and can be
// referenced by a version of a subject.
//
// Subject refers to the name under which the schema is registered. A
// typical subject is the Kafka topic name. A schema registry instance can have
// multiple subjects.
//
// Version represents a version of a subject. A subject can have multiple
// versions. Creation of new version of a subject is guarded by the
// compatibility mode configured globally or for the subject specifically.
//
// Config represents a config at global level cross all registry
// instances or at subject level. Currently, only compatibility is supported in
// config.
//
// Mode represents the mode of a schema registry or a specific subject.
// Three modes are supported:
//
//	READONLY: The schema registry is in read-only mode, no write operations
//	allowed…
//
//	READWRITE: The schema registry is in read-write mode, which allows limited
//	write operations on the schema.
//
//	IMPORT: The schema registry is in import mode, which allows more editing
//	operations on the schema for data importing purposes.
func NewManagedSchemaRegistryRESTClient(ctx context.Context, opts ...option.ClientOption) (*ManagedSchemaRegistryClient, error) {
	clientOpts := append(defaultManagedSchemaRegistryRESTClientOptions(), opts...)
	httpClient, endpoint, err := httptransport.NewClient(ctx, clientOpts...)
	if err != nil {
		return nil, err
	}

	callOpts := defaultManagedSchemaRegistryRESTCallOptions()
	c := &managedSchemaRegistryRESTClient{
		endpoint:    endpoint,
		httpClient:  httpClient,
		CallOptions: &callOpts,
		logger:      internaloption.GetLogger(opts),
	}
	c.setGoogleClientInfo()

	return &ManagedSchemaRegistryClient{internalClient: c, CallOptions: callOpts}, nil
}

func defaultManagedSchemaRegistryRESTClientOptions() []option.ClientOption {
	return []option.ClientOption{
		internaloption.WithDefaultEndpoint("https://managedkafka.googleapis.com"),
		internaloption.WithDefaultEndpointTemplate("https://managedkafka.UNIVERSE_DOMAIN"),
		internaloption.WithDefaultMTLSEndpoint("https://managedkafka.mtls.googleapis.com"),
		internaloption.WithDefaultUniverseDomain("googleapis.com"),
		internaloption.WithDefaultAudience("https://managedkafka.googleapis.com/"),
		internaloption.WithDefaultScopes(DefaultAuthScopes()...),
		internaloption.EnableNewAuthLibrary(),
	}
}

// setGoogleClientInfo sets the name and version of the application in
// the `x-goog-api-client` header passed on each request. Intended for
// use by Google-written clients.
func (c *managedSchemaRegistryRESTClient) setGoogleClientInfo(keyval ...string) {
	kv := append([]string{"gl-go", gax.GoVersion}, keyval...)
	kv = append(kv, "gapic", getVersionClient(), "gax", gax.Version, "rest", "UNKNOWN", "pb", protoVersion)
	c.xGoogHeaders = []string{
		"x-goog-api-client", gax.XGoogHeader(kv...),
	}
}

// Close closes the connection to the API service. The user should invoke this when
// the client is no longer required.
func (c *managedSchemaRegistryRESTClient) Close() error {
	// Replace httpClient with nil to force cleanup.
	c.httpClient = nil
	return nil
}

// Connection returns a connection to the API service.
//
// Deprecated: This method always returns nil.
func (c *managedSchemaRegistryRESTClient) Connection() *grpc.ClientConn {
	return nil
}
func (c *managedSchemaRegistryGRPCClient) GetSchemaRegistry(ctx context.Context, req *schemaregistrypb.GetSchemaRegistryRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetSchemaRegistry[0:len((*c.CallOptions).GetSchemaRegistry):len((*c.CallOptions).GetSchemaRegistry)], opts...)
	var resp *schemaregistrypb.SchemaRegistry
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetSchemaRegistry, req, settings.GRPC, c.logger, "GetSchemaRegistry")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListSchemaRegistries(ctx context.Context, req *schemaregistrypb.ListSchemaRegistriesRequest, opts ...gax.CallOption) (*schemaregistrypb.ListSchemaRegistriesResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListSchemaRegistries[0:len((*c.CallOptions).ListSchemaRegistries):len((*c.CallOptions).ListSchemaRegistries)], opts...)
	var resp *schemaregistrypb.ListSchemaRegistriesResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListSchemaRegistries, req, settings.GRPC, c.logger, "ListSchemaRegistries")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) CreateSchemaRegistry(ctx context.Context, req *schemaregistrypb.CreateSchemaRegistryRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CreateSchemaRegistry[0:len((*c.CallOptions).CreateSchemaRegistry):len((*c.CallOptions).CreateSchemaRegistry)], opts...)
	var resp *schemaregistrypb.SchemaRegistry
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.CreateSchemaRegistry, req, settings.GRPC, c.logger, "CreateSchemaRegistry")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) DeleteSchemaRegistry(ctx context.Context, req *schemaregistrypb.DeleteSchemaRegistryRequest, opts ...gax.CallOption) error {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSchemaRegistry[0:len((*c.CallOptions).DeleteSchemaRegistry):len((*c.CallOptions).DeleteSchemaRegistry)], opts...)
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		_, err = executeRPC(ctx, c.managedSchemaRegistryClient.DeleteSchemaRegistry, req, settings.GRPC, c.logger, "DeleteSchemaRegistry")
		return err
	}, opts...)
	return err
}

func (c *managedSchemaRegistryGRPCClient) GetContext(ctx context.Context, req *schemaregistrypb.GetContextRequest, opts ...gax.CallOption) (*schemaregistrypb.Context, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetContext[0:len((*c.CallOptions).GetContext):len((*c.CallOptions).GetContext)], opts...)
	var resp *schemaregistrypb.Context
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetContext, req, settings.GRPC, c.logger, "GetContext")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListContexts(ctx context.Context, req *schemaregistrypb.ListContextsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListContexts[0:len((*c.CallOptions).ListContexts):len((*c.CallOptions).ListContexts)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListContexts, req, settings.GRPC, c.logger, "ListContexts")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetSchema(ctx context.Context, req *schemaregistrypb.GetSchemaRequest, opts ...gax.CallOption) (*schemaregistrypb.Schema, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetSchema[0:len((*c.CallOptions).GetSchema):len((*c.CallOptions).GetSchema)], opts...)
	var resp *schemaregistrypb.Schema
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetSchema, req, settings.GRPC, c.logger, "GetSchema")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetRawSchema(ctx context.Context, req *schemaregistrypb.GetSchemaRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetRawSchema[0:len((*c.CallOptions).GetRawSchema):len((*c.CallOptions).GetRawSchema)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetRawSchema, req, settings.GRPC, c.logger, "GetRawSchema")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListSchemaVersions(ctx context.Context, req *schemaregistrypb.ListSchemaVersionsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListSchemaVersions[0:len((*c.CallOptions).ListSchemaVersions):len((*c.CallOptions).ListSchemaVersions)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListSchemaVersions, req, settings.GRPC, c.logger, "ListSchemaVersions")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListSchemaTypes(ctx context.Context, req *schemaregistrypb.ListSchemaTypesRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListSchemaTypes[0:len((*c.CallOptions).ListSchemaTypes):len((*c.CallOptions).ListSchemaTypes)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListSchemaTypes, req, settings.GRPC, c.logger, "ListSchemaTypes")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListSubjects(ctx context.Context, req *schemaregistrypb.ListSubjectsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListSubjects[0:len((*c.CallOptions).ListSubjects):len((*c.CallOptions).ListSubjects)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListSubjects, req, settings.GRPC, c.logger, "ListSubjects")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListSubjectsBySchemaId(ctx context.Context, req *schemaregistrypb.ListSubjectsBySchemaIdRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListSubjectsBySchemaId[0:len((*c.CallOptions).ListSubjectsBySchemaId):len((*c.CallOptions).ListSubjectsBySchemaId)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListSubjectsBySchemaId, req, settings.GRPC, c.logger, "ListSubjectsBySchemaId")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) DeleteSubject(ctx context.Context, req *schemaregistrypb.DeleteSubjectRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSubject[0:len((*c.CallOptions).DeleteSubject):len((*c.CallOptions).DeleteSubject)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.DeleteSubject, req, settings.GRPC, c.logger, "DeleteSubject")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) LookupVersion(ctx context.Context, req *schemaregistrypb.LookupVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).LookupVersion[0:len((*c.CallOptions).LookupVersion):len((*c.CallOptions).LookupVersion)], opts...)
	var resp *schemaregistrypb.SchemaVersion
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.LookupVersion, req, settings.GRPC, c.logger, "LookupVersion")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetVersion(ctx context.Context, req *schemaregistrypb.GetVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetVersion[0:len((*c.CallOptions).GetVersion):len((*c.CallOptions).GetVersion)], opts...)
	var resp *schemaregistrypb.SchemaVersion
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetVersion, req, settings.GRPC, c.logger, "GetVersion")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetRawSchemaVersion(ctx context.Context, req *schemaregistrypb.GetVersionRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetRawSchemaVersion[0:len((*c.CallOptions).GetRawSchemaVersion):len((*c.CallOptions).GetRawSchemaVersion)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetRawSchemaVersion, req, settings.GRPC, c.logger, "GetRawSchemaVersion")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListVersions(ctx context.Context, req *schemaregistrypb.ListVersionsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListVersions[0:len((*c.CallOptions).ListVersions):len((*c.CallOptions).ListVersions)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListVersions, req, settings.GRPC, c.logger, "ListVersions")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) CreateVersion(ctx context.Context, req *schemaregistrypb.CreateVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.CreateVersionResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CreateVersion[0:len((*c.CallOptions).CreateVersion):len((*c.CallOptions).CreateVersion)], opts...)
	var resp *schemaregistrypb.CreateVersionResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.CreateVersion, req, settings.GRPC, c.logger, "CreateVersion")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) DeleteVersion(ctx context.Context, req *schemaregistrypb.DeleteVersionRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteVersion[0:len((*c.CallOptions).DeleteVersion):len((*c.CallOptions).DeleteVersion)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.DeleteVersion, req, settings.GRPC, c.logger, "DeleteVersion")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListReferencedSchemas(ctx context.Context, req *schemaregistrypb.ListReferencedSchemasRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListReferencedSchemas[0:len((*c.CallOptions).ListReferencedSchemas):len((*c.CallOptions).ListReferencedSchemas)], opts...)
	var resp *httpbodypb.HttpBody
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.ListReferencedSchemas, req, settings.GRPC, c.logger, "ListReferencedSchemas")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) CheckCompatibility(ctx context.Context, req *schemaregistrypb.CheckCompatibilityRequest, opts ...gax.CallOption) (*schemaregistrypb.CheckCompatibilityResponse, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CheckCompatibility[0:len((*c.CallOptions).CheckCompatibility):len((*c.CallOptions).CheckCompatibility)], opts...)
	var resp *schemaregistrypb.CheckCompatibilityResponse
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.CheckCompatibility, req, settings.GRPC, c.logger, "CheckCompatibility")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetSchemaConfig(ctx context.Context, req *schemaregistrypb.GetSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetSchemaConfig[0:len((*c.CallOptions).GetSchemaConfig):len((*c.CallOptions).GetSchemaConfig)], opts...)
	var resp *schemaregistrypb.SchemaConfig
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetSchemaConfig, req, settings.GRPC, c.logger, "GetSchemaConfig")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) UpdateSchemaConfig(ctx context.Context, req *schemaregistrypb.UpdateSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).UpdateSchemaConfig[0:len((*c.CallOptions).UpdateSchemaConfig):len((*c.CallOptions).UpdateSchemaConfig)], opts...)
	var resp *schemaregistrypb.SchemaConfig
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.UpdateSchemaConfig, req, settings.GRPC, c.logger, "UpdateSchemaConfig")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) DeleteSchemaConfig(ctx context.Context, req *schemaregistrypb.DeleteSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSchemaConfig[0:len((*c.CallOptions).DeleteSchemaConfig):len((*c.CallOptions).DeleteSchemaConfig)], opts...)
	var resp *schemaregistrypb.SchemaConfig
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.DeleteSchemaConfig, req, settings.GRPC, c.logger, "DeleteSchemaConfig")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetSchemaMode(ctx context.Context, req *schemaregistrypb.GetSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetSchemaMode[0:len((*c.CallOptions).GetSchemaMode):len((*c.CallOptions).GetSchemaMode)], opts...)
	var resp *schemaregistrypb.SchemaMode
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.GetSchemaMode, req, settings.GRPC, c.logger, "GetSchemaMode")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) UpdateSchemaMode(ctx context.Context, req *schemaregistrypb.UpdateSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).UpdateSchemaMode[0:len((*c.CallOptions).UpdateSchemaMode):len((*c.CallOptions).UpdateSchemaMode)], opts...)
	var resp *schemaregistrypb.SchemaMode
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.UpdateSchemaMode, req, settings.GRPC, c.logger, "UpdateSchemaMode")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) DeleteSchemaMode(ctx context.Context, req *schemaregistrypb.DeleteSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSchemaMode[0:len((*c.CallOptions).DeleteSchemaMode):len((*c.CallOptions).DeleteSchemaMode)], opts...)
	var resp *schemaregistrypb.SchemaMode
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.managedSchemaRegistryClient.DeleteSchemaMode, req, settings.GRPC, c.logger, "DeleteSchemaMode")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) GetLocation(ctx context.Context, req *locationpb.GetLocationRequest, opts ...gax.CallOption) (*locationpb.Location, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetLocation[0:len((*c.CallOptions).GetLocation):len((*c.CallOptions).GetLocation)], opts...)
	var resp *locationpb.Location
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.locationsClient.GetLocation, req, settings.GRPC, c.logger, "GetLocation")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListLocations(ctx context.Context, req *locationpb.ListLocationsRequest, opts ...gax.CallOption) *LocationIterator {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListLocations[0:len((*c.CallOptions).ListLocations):len((*c.CallOptions).ListLocations)], opts...)
	it := &LocationIterator{}
	req = proto.Clone(req).(*locationpb.ListLocationsRequest)
	it.InternalFetch = func(pageSize int, pageToken string) ([]*locationpb.Location, string, error) {
		resp := &locationpb.ListLocationsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			var err error
			resp, err = executeRPC(ctx, c.locationsClient.ListLocations, req, settings.GRPC, c.logger, "ListLocations")
			return err
		}, opts...)
		if err != nil {
			return nil, "", err
		}

		it.Response = resp
		return resp.GetLocations(), resp.GetNextPageToken(), nil
	}
	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

func (c *managedSchemaRegistryGRPCClient) CancelOperation(ctx context.Context, req *longrunningpb.CancelOperationRequest, opts ...gax.CallOption) error {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).CancelOperation[0:len((*c.CallOptions).CancelOperation):len((*c.CallOptions).CancelOperation)], opts...)
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		_, err = executeRPC(ctx, c.operationsClient.CancelOperation, req, settings.GRPC, c.logger, "CancelOperation")
		return err
	}, opts...)
	return err
}

func (c *managedSchemaRegistryGRPCClient) DeleteOperation(ctx context.Context, req *longrunningpb.DeleteOperationRequest, opts ...gax.CallOption) error {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).DeleteOperation[0:len((*c.CallOptions).DeleteOperation):len((*c.CallOptions).DeleteOperation)], opts...)
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		_, err = executeRPC(ctx, c.operationsClient.DeleteOperation, req, settings.GRPC, c.logger, "DeleteOperation")
		return err
	}, opts...)
	return err
}

func (c *managedSchemaRegistryGRPCClient) GetOperation(ctx context.Context, req *longrunningpb.GetOperationRequest, opts ...gax.CallOption) (*longrunningpb.Operation, error) {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).GetOperation[0:len((*c.CallOptions).GetOperation):len((*c.CallOptions).GetOperation)], opts...)
	var resp *longrunningpb.Operation
	err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		var err error
		resp, err = executeRPC(ctx, c.operationsClient.GetOperation, req, settings.GRPC, c.logger, "GetOperation")
		return err
	}, opts...)
	if err != nil {
		return nil, err
	}
	return resp, nil
}

func (c *managedSchemaRegistryGRPCClient) ListOperations(ctx context.Context, req *longrunningpb.ListOperationsRequest, opts ...gax.CallOption) *OperationIterator {
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	ctx = gax.InsertMetadataIntoOutgoingContext(ctx, hds...)
	opts = append((*c.CallOptions).ListOperations[0:len((*c.CallOptions).ListOperations):len((*c.CallOptions).ListOperations)], opts...)
	it := &OperationIterator{}
	req = proto.Clone(req).(*longrunningpb.ListOperationsRequest)
	it.InternalFetch = func(pageSize int, pageToken string) ([]*longrunningpb.Operation, string, error) {
		resp := &longrunningpb.ListOperationsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		err := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			var err error
			resp, err = executeRPC(ctx, c.operationsClient.ListOperations, req, settings.GRPC, c.logger, "ListOperations")
			return err
		}, opts...)
		if err != nil {
			return nil, "", err
		}

		it.Response = resp
		return resp.GetOperations(), resp.GetNextPageToken(), nil
	}
	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// GetSchemaRegistry get the schema registry instance.
func (c *managedSchemaRegistryRESTClient) GetSchemaRegistry(ctx context.Context, req *schemaregistrypb.GetSchemaRegistryRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetSchemaRegistry[0:len((*c.CallOptions).GetSchemaRegistry):len((*c.CallOptions).GetSchemaRegistry)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaRegistry{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetSchemaRegistry")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListSchemaRegistries list schema registries.
func (c *managedSchemaRegistryRESTClient) ListSchemaRegistries(ctx context.Context, req *schemaregistrypb.ListSchemaRegistriesRequest, opts ...gax.CallOption) (*schemaregistrypb.ListSchemaRegistriesResponse, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/schemaRegistries", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListSchemaRegistries[0:len((*c.CallOptions).ListSchemaRegistries):len((*c.CallOptions).ListSchemaRegistries)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.ListSchemaRegistriesResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "ListSchemaRegistries")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// CreateSchemaRegistry create a schema registry instance.
func (c *managedSchemaRegistryRESTClient) CreateSchemaRegistry(ctx context.Context, req *schemaregistrypb.CreateSchemaRegistryRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaRegistry, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/schemaRegistries", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).CreateSchemaRegistry[0:len((*c.CallOptions).CreateSchemaRegistry):len((*c.CallOptions).CreateSchemaRegistry)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaRegistry{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "CreateSchemaRegistry")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteSchemaRegistry delete a schema registry instance.
func (c *managedSchemaRegistryRESTClient) DeleteSchemaRegistry(ctx context.Context, req *schemaregistrypb.DeleteSchemaRegistryRequest, opts ...gax.CallOption) error {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	return gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		_, err = executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "DeleteSchemaRegistry")
		return err
	}, opts...)
}

// GetContext get the context.
func (c *managedSchemaRegistryRESTClient) GetContext(ctx context.Context, req *schemaregistrypb.GetContextRequest, opts ...gax.CallOption) (*schemaregistrypb.Context, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetContext[0:len((*c.CallOptions).GetContext):len((*c.CallOptions).GetContext)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.Context{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetContext")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListContexts list contexts for a schema registry.
func (c *managedSchemaRegistryRESTClient) ListContexts(ctx context.Context, req *schemaregistrypb.ListContextsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/contexts", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListContexts[0:len((*c.CallOptions).ListContexts):len((*c.CallOptions).ListContexts)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListContexts")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetSchema get the schema for the given schema id.
func (c *managedSchemaRegistryRESTClient) GetSchema(ctx context.Context, req *schemaregistrypb.GetSchemaRequest, opts ...gax.CallOption) (*schemaregistrypb.Schema, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Subject != nil {
		params.Add("subject", fmt.Sprintf("%v", req.GetSubject()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetSchema[0:len((*c.CallOptions).GetSchema):len((*c.CallOptions).GetSchema)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.Schema{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetSchema")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetRawSchema get the schema string for the given schema id.
// The response will be the schema string.
func (c *managedSchemaRegistryRESTClient) GetRawSchema(ctx context.Context, req *schemaregistrypb.GetSchemaRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/schema", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Subject != nil {
		params.Add("subject", fmt.Sprintf("%v", req.GetSubject()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetRawSchema[0:len((*c.CallOptions).GetRawSchema):len((*c.CallOptions).GetRawSchema)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "GetRawSchema")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListSchemaVersions list the schema versions for the given schema id.
// The response will be an array of subject-version pairs as:
// [{“subject”:“subject1”, “version”:1}, {“subject”:“subject2”, “version”:2}].
func (c *managedSchemaRegistryRESTClient) ListSchemaVersions(ctx context.Context, req *schemaregistrypb.ListSchemaVersionsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/versions", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Deleted != nil {
		params.Add("deleted", fmt.Sprintf("%v", req.GetDeleted()))
	}
	if req != nil && req.Subject != nil {
		params.Add("subject", fmt.Sprintf("%v", req.GetSubject()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListSchemaVersions[0:len((*c.CallOptions).ListSchemaVersions):len((*c.CallOptions).ListSchemaVersions)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListSchemaVersions")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListSchemaTypes list the supported schema types.
// The response will be an array of schema types.
func (c *managedSchemaRegistryRESTClient) ListSchemaTypes(ctx context.Context, req *schemaregistrypb.ListSchemaTypesRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/schemas/types", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListSchemaTypes[0:len((*c.CallOptions).ListSchemaTypes):len((*c.CallOptions).ListSchemaTypes)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListSchemaTypes")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListSubjects list subjects in the schema registry.
// The response will be an array of subject names.
func (c *managedSchemaRegistryRESTClient) ListSubjects(ctx context.Context, req *schemaregistrypb.ListSubjectsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/subjects", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Deleted != nil {
		params.Add("deleted", fmt.Sprintf("%v", req.GetDeleted()))
	}
	if req != nil && req.SubjectPrefix != nil {
		params.Add("subjectPrefix", fmt.Sprintf("%v", req.GetSubjectPrefix()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListSubjects[0:len((*c.CallOptions).ListSubjects):len((*c.CallOptions).ListSubjects)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListSubjects")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListSubjectsBySchemaId list subjects which reference a particular schema id.
// The response will be an array of subject names.
func (c *managedSchemaRegistryRESTClient) ListSubjectsBySchemaId(ctx context.Context, req *schemaregistrypb.ListSubjectsBySchemaIdRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/subjects", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Deleted != nil {
		params.Add("deleted", fmt.Sprintf("%v", req.GetDeleted()))
	}
	if req != nil && req.Subject != nil {
		params.Add("subject", fmt.Sprintf("%v", req.GetSubject()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListSubjectsBySchemaId[0:len((*c.CallOptions).ListSubjectsBySchemaId):len((*c.CallOptions).ListSubjectsBySchemaId)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListSubjectsBySchemaId")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteSubject delete a subject.
// The response will be an array of versions of the deleted subject.
func (c *managedSchemaRegistryRESTClient) DeleteSubject(ctx context.Context, req *schemaregistrypb.DeleteSubjectRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Permanent != nil {
		params.Add("permanent", fmt.Sprintf("%v", req.GetPermanent()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSubject[0:len((*c.CallOptions).DeleteSubject):len((*c.CallOptions).DeleteSubject)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "DeleteSubject")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// LookupVersion lookup a schema under the specified subject.
func (c *managedSchemaRegistryRESTClient) LookupVersion(ctx context.Context, req *schemaregistrypb.LookupVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).LookupVersion[0:len((*c.CallOptions).LookupVersion):len((*c.CallOptions).LookupVersion)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaVersion{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "LookupVersion")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetVersion get a versioned schema (schema with subject/version) of a subject.
func (c *managedSchemaRegistryRESTClient) GetVersion(ctx context.Context, req *schemaregistrypb.GetVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaVersion, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Deleted != nil {
		params.Add("deleted", fmt.Sprintf("%v", req.GetDeleted()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetVersion[0:len((*c.CallOptions).GetVersion):len((*c.CallOptions).GetVersion)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaVersion{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetVersion")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetRawSchemaVersion get the schema string only for a version of a subject.
// The response will be the schema string.
func (c *managedSchemaRegistryRESTClient) GetRawSchemaVersion(ctx context.Context, req *schemaregistrypb.GetVersionRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/schema", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Deleted != nil {
		params.Add("deleted", fmt.Sprintf("%v", req.GetDeleted()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetRawSchemaVersion[0:len((*c.CallOptions).GetRawSchemaVersion):len((*c.CallOptions).GetRawSchemaVersion)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "GetRawSchemaVersion")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListVersions get all versions of a subject.
// The response will be an array of versions of the subject.
func (c *managedSchemaRegistryRESTClient) ListVersions(ctx context.Context, req *schemaregistrypb.ListVersionsRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/versions", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Deleted != nil {
		params.Add("deleted", fmt.Sprintf("%v", req.GetDeleted()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListVersions[0:len((*c.CallOptions).ListVersions):len((*c.CallOptions).ListVersions)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListVersions")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// CreateVersion register a new version under a given subject with the given schema.
func (c *managedSchemaRegistryRESTClient) CreateVersion(ctx context.Context, req *schemaregistrypb.CreateVersionRequest, opts ...gax.CallOption) (*schemaregistrypb.CreateVersionResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/versions", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).CreateVersion[0:len((*c.CallOptions).CreateVersion):len((*c.CallOptions).CreateVersion)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.CreateVersionResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "CreateVersion")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteVersion delete a version of a subject.
// The response will be the deleted version id.
func (c *managedSchemaRegistryRESTClient) DeleteVersion(ctx context.Context, req *schemaregistrypb.DeleteVersionRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.Permanent != nil {
		params.Add("permanent", fmt.Sprintf("%v", req.GetPermanent()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).DeleteVersion[0:len((*c.CallOptions).DeleteVersion):len((*c.CallOptions).DeleteVersion)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "DeleteVersion")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListReferencedSchemas get a list of IDs of schemas that reference the schema with the given
// subject and version.
func (c *managedSchemaRegistryRESTClient) ListReferencedSchemas(ctx context.Context, req *schemaregistrypb.ListReferencedSchemasRequest, opts ...gax.CallOption) (*httpbodypb.HttpBody, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v/referencedby", req.GetParent())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "parent", url.QueryEscape(req.GetParent()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).ListReferencedSchemas[0:len((*c.CallOptions).ListReferencedSchemas):len((*c.CallOptions).ListReferencedSchemas)], opts...)
	resp := &httpbodypb.HttpBody{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, httpRsp, err := executeHTTPRequestWithResponse(ctx, c.httpClient, httpReq, c.logger, nil, "ListReferencedSchemas")
		if err != nil {
			return err
		}

		resp.Data = buf
		if headers := httpRsp.Header; len(headers["Content-Type"]) > 0 {
			resp.ContentType = headers["Content-Type"][0]
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// CheckCompatibility check compatibility of a schema with all versions or a specific version of
// a subject.
func (c *managedSchemaRegistryRESTClient) CheckCompatibility(ctx context.Context, req *schemaregistrypb.CheckCompatibilityRequest, opts ...gax.CallOption) (*schemaregistrypb.CheckCompatibilityResponse, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).CheckCompatibility[0:len((*c.CallOptions).CheckCompatibility):len((*c.CallOptions).CheckCompatibility)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.CheckCompatibilityResponse{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "CheckCompatibility")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetSchemaConfig get schema config at global level or for a subject.
func (c *managedSchemaRegistryRESTClient) GetSchemaConfig(ctx context.Context, req *schemaregistrypb.GetSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")
	if req != nil && req.DefaultToGlobal != nil {
		params.Add("defaultToGlobal", fmt.Sprintf("%v", req.GetDefaultToGlobal()))
	}

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetSchemaConfig[0:len((*c.CallOptions).GetSchemaConfig):len((*c.CallOptions).GetSchemaConfig)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaConfig{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetSchemaConfig")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// UpdateSchemaConfig update config at global level or for a subject.
// Creates a SchemaSubject-level SchemaConfig if it does not exist.
func (c *managedSchemaRegistryRESTClient) UpdateSchemaConfig(ctx context.Context, req *schemaregistrypb.UpdateSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).UpdateSchemaConfig[0:len((*c.CallOptions).UpdateSchemaConfig):len((*c.CallOptions).UpdateSchemaConfig)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaConfig{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("PUT", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "UpdateSchemaConfig")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteSchemaConfig delete schema config for a subject.
func (c *managedSchemaRegistryRESTClient) DeleteSchemaConfig(ctx context.Context, req *schemaregistrypb.DeleteSchemaConfigRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaConfig, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSchemaConfig[0:len((*c.CallOptions).DeleteSchemaConfig):len((*c.CallOptions).DeleteSchemaConfig)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaConfig{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "DeleteSchemaConfig")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetSchemaMode get mode at global level or for a subject.
func (c *managedSchemaRegistryRESTClient) GetSchemaMode(ctx context.Context, req *schemaregistrypb.GetSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetSchemaMode[0:len((*c.CallOptions).GetSchemaMode):len((*c.CallOptions).GetSchemaMode)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaMode{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetSchemaMode")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// UpdateSchemaMode update mode at global level or for a subject.
func (c *managedSchemaRegistryRESTClient) UpdateSchemaMode(ctx context.Context, req *schemaregistrypb.UpdateSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return nil, err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).UpdateSchemaMode[0:len((*c.CallOptions).UpdateSchemaMode):len((*c.CallOptions).UpdateSchemaMode)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaMode{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("PUT", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "UpdateSchemaMode")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// DeleteSchemaMode delete schema mode for a subject.
func (c *managedSchemaRegistryRESTClient) DeleteSchemaMode(ctx context.Context, req *schemaregistrypb.DeleteSchemaModeRequest, opts ...gax.CallOption) (*schemaregistrypb.SchemaMode, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).DeleteSchemaMode[0:len((*c.CallOptions).DeleteSchemaMode):len((*c.CallOptions).DeleteSchemaMode)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &schemaregistrypb.SchemaMode{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "DeleteSchemaMode")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// GetLocation gets information about a location.
func (c *managedSchemaRegistryRESTClient) GetLocation(ctx context.Context, req *locationpb.GetLocationRequest, opts ...gax.CallOption) (*locationpb.Location, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetLocation[0:len((*c.CallOptions).GetLocation):len((*c.CallOptions).GetLocation)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &locationpb.Location{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetLocation")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListLocations lists information about the supported locations for this service.
func (c *managedSchemaRegistryRESTClient) ListLocations(ctx context.Context, req *locationpb.ListLocationsRequest, opts ...gax.CallOption) *LocationIterator {
	it := &LocationIterator{}
	req = proto.Clone(req).(*locationpb.ListLocationsRequest)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	it.InternalFetch = func(pageSize int, pageToken string) ([]*locationpb.Location, string, error) {
		resp := &locationpb.ListLocationsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		baseUrl, err := url.Parse(c.endpoint)
		if err != nil {
			return nil, "", err
		}
		baseUrl.Path += fmt.Sprintf("/v1/%v/locations", req.GetName())

		params := url.Values{}
		params.Add("$alt", "json;enum-encoding=int")
		if req.GetFilter() != "" {
			params.Add("filter", fmt.Sprintf("%v", req.GetFilter()))
		}
		if req.GetPageSize() != 0 {
			params.Add("pageSize", fmt.Sprintf("%v", req.GetPageSize()))
		}
		if req.GetPageToken() != "" {
			params.Add("pageToken", fmt.Sprintf("%v", req.GetPageToken()))
		}

		baseUrl.RawQuery = params.Encode()

		// Build HTTP headers from client and context metadata.
		hds := append(c.xGoogHeaders, "Content-Type", "application/json")
		headers := gax.BuildHeaders(ctx, hds...)
		e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			if settings.Path != "" {
				baseUrl.Path = settings.Path
			}
			httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
			if err != nil {
				return err
			}
			httpReq.Header = headers

			buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "ListLocations")
			if err != nil {
				return err
			}
			if err := unm.Unmarshal(buf, resp); err != nil {
				return err
			}

			return nil
		}, opts...)
		if e != nil {
			return nil, "", e
		}
		it.Response = resp
		return resp.GetLocations(), resp.GetNextPageToken(), nil
	}

	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}

// CancelOperation is a utility method from google.longrunning.Operations.
func (c *managedSchemaRegistryRESTClient) CancelOperation(ctx context.Context, req *longrunningpb.CancelOperationRequest, opts ...gax.CallOption) error {
	m := protojson.MarshalOptions{AllowPartial: true, UseEnumNumbers: true}
	jsonReq, err := m.Marshal(req)
	if err != nil {
		return err
	}

	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v:cancel", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	return gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("POST", baseUrl.String(), bytes.NewReader(jsonReq))
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		_, err = executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, jsonReq, "CancelOperation")
		return err
	}, opts...)
}

// DeleteOperation is a utility method from google.longrunning.Operations.
func (c *managedSchemaRegistryRESTClient) DeleteOperation(ctx context.Context, req *longrunningpb.DeleteOperationRequest, opts ...gax.CallOption) error {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	return gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("DELETE", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		_, err = executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "DeleteOperation")
		return err
	}, opts...)
}

// GetOperation is a utility method from google.longrunning.Operations.
func (c *managedSchemaRegistryRESTClient) GetOperation(ctx context.Context, req *longrunningpb.GetOperationRequest, opts ...gax.CallOption) (*longrunningpb.Operation, error) {
	baseUrl, err := url.Parse(c.endpoint)
	if err != nil {
		return nil, err
	}
	baseUrl.Path += fmt.Sprintf("/v1/%v", req.GetName())

	params := url.Values{}
	params.Add("$alt", "json;enum-encoding=int")

	baseUrl.RawQuery = params.Encode()

	// Build HTTP headers from client and context metadata.
	hds := []string{"x-goog-request-params", fmt.Sprintf("%s=%v", "name", url.QueryEscape(req.GetName()))}

	hds = append(c.xGoogHeaders, hds...)
	hds = append(hds, "Content-Type", "application/json")
	headers := gax.BuildHeaders(ctx, hds...)
	opts = append((*c.CallOptions).GetOperation[0:len((*c.CallOptions).GetOperation):len((*c.CallOptions).GetOperation)], opts...)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	resp := &longrunningpb.Operation{}
	e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
		if settings.Path != "" {
			baseUrl.Path = settings.Path
		}
		httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
		if err != nil {
			return err
		}
		httpReq = httpReq.WithContext(ctx)
		httpReq.Header = headers

		buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "GetOperation")
		if err != nil {
			return err
		}

		if err := unm.Unmarshal(buf, resp); err != nil {
			return err
		}

		return nil
	}, opts...)
	if e != nil {
		return nil, e
	}
	return resp, nil
}

// ListOperations is a utility method from google.longrunning.Operations.
func (c *managedSchemaRegistryRESTClient) ListOperations(ctx context.Context, req *longrunningpb.ListOperationsRequest, opts ...gax.CallOption) *OperationIterator {
	it := &OperationIterator{}
	req = proto.Clone(req).(*longrunningpb.ListOperationsRequest)
	unm := protojson.UnmarshalOptions{AllowPartial: true, DiscardUnknown: true}
	it.InternalFetch = func(pageSize int, pageToken string) ([]*longrunningpb.Operation, string, error) {
		resp := &longrunningpb.ListOperationsResponse{}
		if pageToken != "" {
			req.PageToken = pageToken
		}
		if pageSize > math.MaxInt32 {
			req.PageSize = math.MaxInt32
		} else if pageSize != 0 {
			req.PageSize = int32(pageSize)
		}
		baseUrl, err := url.Parse(c.endpoint)
		if err != nil {
			return nil, "", err
		}
		baseUrl.Path += fmt.Sprintf("/v1/%v/operations", req.GetName())

		params := url.Values{}
		params.Add("$alt", "json;enum-encoding=int")
		if req.GetFilter() != "" {
			params.Add("filter", fmt.Sprintf("%v", req.GetFilter()))
		}
		if req.GetPageSize() != 0 {
			params.Add("pageSize", fmt.Sprintf("%v", req.GetPageSize()))
		}
		if req.GetPageToken() != "" {
			params.Add("pageToken", fmt.Sprintf("%v", req.GetPageToken()))
		}

		baseUrl.RawQuery = params.Encode()

		// Build HTTP headers from client and context metadata.
		hds := append(c.xGoogHeaders, "Content-Type", "application/json")
		headers := gax.BuildHeaders(ctx, hds...)
		e := gax.Invoke(ctx, func(ctx context.Context, settings gax.CallSettings) error {
			if settings.Path != "" {
				baseUrl.Path = settings.Path
			}
			httpReq, err := http.NewRequest("GET", baseUrl.String(), nil)
			if err != nil {
				return err
			}
			httpReq.Header = headers

			buf, err := executeHTTPRequest(ctx, c.httpClient, httpReq, c.logger, nil, "ListOperations")
			if err != nil {
				return err
			}
			if err := unm.Unmarshal(buf, resp); err != nil {
				return err
			}

			return nil
		}, opts...)
		if e != nil {
			return nil, "", e
		}
		it.Response = resp
		return resp.GetOperations(), resp.GetNextPageToken(), nil
	}

	fetch := func(pageSize int, pageToken string) (string, error) {
		items, nextPageToken, err := it.InternalFetch(pageSize, pageToken)
		if err != nil {
			return "", err
		}
		it.items = append(it.items, items...)
		return nextPageToken, nil
	}

	it.pageInfo, it.nextFunc = iterator.NewPageInfo(fetch, it.bufLen, it.takeBuf)
	it.pageInfo.MaxSize = int(req.GetPageSize())
	it.pageInfo.Token = req.GetPageToken()

	return it
}
