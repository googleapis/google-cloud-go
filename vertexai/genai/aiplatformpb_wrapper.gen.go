// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file was generated by protowrap. DO NOT EDIT.

package genai

import (
	"cloud.google.com/go/civil"
	pb "cloud.google.com/go/vertexai/internal/aiplatform/apiv1beta1/aiplatformpb"
	"cloud.google.com/go/vertexai/internal/support"
)

// Blob contains raw media bytes.
//
// Text should not be sent as raw bytes, use the 'text' field.
type Blob struct {
	// Required. The IANA standard MIME type of the source data.
	MIMEType string
	// Required. Raw bytes for media formats.
	Data []byte
}

func (w *Blob) toProto() *pb.Blob {
	if w == nil {
		return nil
	}
	return &pb.Blob{
		MimeType: w.MIMEType,
		Data:     w.Data,
	}
}

func (Blob) fromProto(p *pb.Blob) *Blob {
	if p == nil {
		return nil
	}
	return &Blob{
		MIMEType: p.MimeType,
		Data:     p.Data,
	}
}

// BlockedReason is blocked reason enumeration.
type BlockedReason int32

const (
	// BlockedReasonUnspecified means unspecified blocked reason.
	BlockedReasonUnspecified BlockedReason = 0
	// BlockedReasonSafety means candidates blocked due to safety.
	BlockedReasonSafety BlockedReason = 1
	// BlockedReasonOther means candidates blocked due to other reason.
	BlockedReasonOther BlockedReason = 2
)

// Candidate is a response candidate generated from the model.
type Candidate struct {
	// Output only. Index of the candidate.
	Index int32
	// Output only. Content parts of the candidate.
	Content *Content
	// Output only. The reason why the model stopped generating tokens.
	// If empty, the model has not stopped generating the tokens.
	FinishReason FinishReason
	// Output only. List of ratings for the safety of a response candidate.
	//
	// There is at most one rating per category.
	SafetyRatings []*SafetyRating
	// Output only. Describes the reason the mode stopped generating tokens in
	// more detail. This is only filled when `finish_reason` is set.
	FinishMessage string
	// Output only. Source attribution of the generated content.
	CitationMetadata *CitationMetadata
}

func (w *Candidate) toProto() *pb.Candidate {
	if w == nil {
		return nil
	}
	return &pb.Candidate{
		Index:            w.Index,
		Content:          w.Content.toProto(),
		FinishReason:     pb.Candidate_FinishReason(w.FinishReason),
		SafetyRatings:    support.TransformSlice(w.SafetyRatings, (*SafetyRating).toProto),
		FinishMessage:    support.ZeroToNil(w.FinishMessage),
		CitationMetadata: w.CitationMetadata.toProto(),
	}
}

func (Candidate) fromProto(p *pb.Candidate) *Candidate {
	if p == nil {
		return nil
	}
	return &Candidate{
		Index:            p.Index,
		Content:          (Content{}).fromProto(p.Content),
		FinishReason:     FinishReason(p.FinishReason),
		SafetyRatings:    support.TransformSlice(p.SafetyRatings, (SafetyRating{}).fromProto),
		FinishMessage:    support.NilToZero(p.FinishMessage),
		CitationMetadata: (CitationMetadata{}).fromProto(p.CitationMetadata),
	}
}

// Citation contains source attributions for content.
type Citation struct {
	// Output only. Start index into the content.
	StartIndex int32
	// Output only. End index into the content.
	EndIndex int32
	// Output only. Url reference of the attribution.
	URI string
	// Output only. Title of the attribution.
	Title string
	// Output only. License of the attribution.
	License string
	// Output only. Publication date of the attribution.
	PublicationDate civil.Date
}

func (w *Citation) toProto() *pb.Citation {
	if w == nil {
		return nil
	}
	return &pb.Citation{
		StartIndex:      w.StartIndex,
		EndIndex:        w.EndIndex,
		Uri:             w.URI,
		Title:           w.Title,
		License:         w.License,
		PublicationDate: support.CivilDateToProto(w.PublicationDate),
	}
}

func (Citation) fromProto(p *pb.Citation) *Citation {
	if p == nil {
		return nil
	}
	return &Citation{
		StartIndex:      p.StartIndex,
		EndIndex:        p.EndIndex,
		URI:             p.Uri,
		Title:           p.Title,
		License:         p.License,
		PublicationDate: support.CivilDateFromProto(p.PublicationDate),
	}
}

// CitationMetadata is a collection of source attributions for a piece of content.
type CitationMetadata struct {
	// Output only. List of citations.
	Citations []*Citation
}

func (w *CitationMetadata) toProto() *pb.CitationMetadata {
	if w == nil {
		return nil
	}
	return &pb.CitationMetadata{
		Citations: support.TransformSlice(w.Citations, (*Citation).toProto),
	}
}

func (CitationMetadata) fromProto(p *pb.CitationMetadata) *CitationMetadata {
	if p == nil {
		return nil
	}
	return &CitationMetadata{
		Citations: support.TransformSlice(p.Citations, (Citation{}).fromProto),
	}
}

// Content is the base structured datatype containing multi-part content of a message.
//
// A `Content` includes a `role` field designating the producer of the `Content`
// and a `parts` field containing multi-part data that contains the content of
// the message turn.
type Content struct {
	// Optional. The producer of the content. Must be either 'user' or 'model'.
	//
	// Useful to set for multi-turn conversations, otherwise can be left blank
	// or unset.
	Role string
	// Required. Ordered `Parts` that constitute a single message. Parts may have
	// different IANA MIME types.
	Parts []Part
}

func (w *Content) toProto() *pb.Content {
	if w == nil {
		return nil
	}
	return &pb.Content{
		Role:  w.Role,
		Parts: support.TransformSlice(w.Parts, partToProto),
	}
}

func (Content) fromProto(p *pb.Content) *Content {
	if p == nil {
		return nil
	}
	return &Content{
		Role:  p.Role,
		Parts: support.TransformSlice(p.Parts, partFromProto),
	}
}

// CountTokensResponse is response message for
// [PredictionService.CountTokens][google.cloud.aiplatform.v1beta1.PredictionService.CountTokens].
type CountTokensResponse struct {
	// The total number of tokens counted across all instances from the request.
	TotalTokens int32
	// The total number of billable characters counted across all instances from
	// the request.
	TotalBillableCharacters int32
}

func (w *CountTokensResponse) toProto() *pb.CountTokensResponse {
	if w == nil {
		return nil
	}
	return &pb.CountTokensResponse{
		TotalTokens:             w.TotalTokens,
		TotalBillableCharacters: w.TotalBillableCharacters,
	}
}

func (CountTokensResponse) fromProto(p *pb.CountTokensResponse) *CountTokensResponse {
	if p == nil {
		return nil
	}
	return &CountTokensResponse{
		TotalTokens:             p.TotalTokens,
		TotalBillableCharacters: p.TotalBillableCharacters,
	}
}

// FileData is URI based data.
type FileData struct {
	// Required. The IANA standard MIME type of the source data.
	MIMEType string
	// Required. URI.
	FileURI string
}

func (w *FileData) toProto() *pb.FileData {
	if w == nil {
		return nil
	}
	return &pb.FileData{
		MimeType: w.MIMEType,
		FileUri:  w.FileURI,
	}
}

func (FileData) fromProto(p *pb.FileData) *FileData {
	if p == nil {
		return nil
	}
	return &FileData{
		MIMEType: p.MimeType,
		FileURI:  p.FileUri,
	}
}

// FinishReason is the reason why the model stopped generating tokens.
// If empty, the model has not stopped generating the tokens.
type FinishReason int32

const (
	// FinishReasonUnspecified means the finish reason is unspecified.
	FinishReasonUnspecified FinishReason = 0
	// FinishReasonStop means natural stop point of the model or provided stop sequence.
	FinishReasonStop FinishReason = 1
	// FinishReasonMaxTokens means the maximum number of tokens as specified in the request was reached.
	FinishReasonMaxTokens FinishReason = 2
	// FinishReasonSafety means the token generation was stopped as the response was flagged for safety
	// reasons. NOTE: When streaming the Candidate.content will be empty if
	// content filters blocked the output.
	FinishReasonSafety FinishReason = 3
	// FinishReasonRecitation means the token generation was stopped as the response was flagged for
	// unauthorized citations.
	FinishReasonRecitation FinishReason = 4
	// FinishReasonOther means all other reasons that stopped the token generation
	FinishReasonOther FinishReason = 5
)

// FunctionCall is a predicted [FunctionCall] returned from the model that contains a string
// representing the [FunctionDeclaration.name] and a structured JSON object
// containing the parameters and their values.
type FunctionCall struct {
	// Required. The name of the function to call.
	// Matches [FunctionDeclaration.name].
	Name string
	// Optional. Required. The function parameters and values in JSON object
	// format. See [FunctionDeclaration.parameters] for parameter details.
	Args map[string]any
}

func (w *FunctionCall) toProto() *pb.FunctionCall {
	if w == nil {
		return nil
	}
	return &pb.FunctionCall{
		Name: w.Name,
		Args: support.MapToStructPB(w.Args),
	}
}

func (FunctionCall) fromProto(p *pb.FunctionCall) *FunctionCall {
	if p == nil {
		return nil
	}
	return &FunctionCall{
		Name: p.Name,
		Args: support.MapFromStructPB(p.Args),
	}
}

// FunctionDeclaration is structured representation of a function declaration as defined by the
// [OpenAPI 3.0 specification](https://spec.openapis.org/oas/v3.0.3). Included
// in this declaration are the function name and parameters. This
// FunctionDeclaration is a representation of a block of code that can be used
// as a `Tool` by the model and executed by the client.
type FunctionDeclaration struct {
	// Required. The name of the function to call.
	// Must start with a letter or an underscore.
	// Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum
	// length of 64.
	Name string
	// Optional. Description and purpose of the function.
	// Model uses it to decide how and whether to call the function.
	Description string
	// Optional. Describes the parameters to this function in JSON Schema Object
	// format. Reflects the Open API 3.03 Parameter Object. string Key: the name
	// of the parameter. Parameter names are case sensitive. Schema Value: the
	// Schema defining the type used for the parameter. For function with no
	// parameters, this can be left unset. Example with 1 required and 1 optional
	// parameter: type: OBJECT properties:
	//  param1:
	//    type: STRING
	//  param2:
	//    type: INTEGER
	// required:
	//  - param1
	Parameters *Schema
}

func (w *FunctionDeclaration) toProto() *pb.FunctionDeclaration {
	if w == nil {
		return nil
	}
	return &pb.FunctionDeclaration{
		Name:        w.Name,
		Description: w.Description,
		Parameters:  w.Parameters.toProto(),
	}
}

func (FunctionDeclaration) fromProto(p *pb.FunctionDeclaration) *FunctionDeclaration {
	if p == nil {
		return nil
	}
	return &FunctionDeclaration{
		Name:        p.Name,
		Description: p.Description,
		Parameters:  (Schema{}).fromProto(p.Parameters),
	}
}

// FunctionResponse is the result output from a [FunctionCall] that contains a string representing
// the [FunctionDeclaration.name] and a structured JSON object containing any
// output from the function is used as context to the model. This should contain
// the result of a [FunctionCall] made based on model prediction.
type FunctionResponse struct {
	// Required. The name of the function to call.
	// Matches [FunctionDeclaration.name] and [FunctionCall.name].
	Name string
	// Required. The function response in JSON object format.
	Response map[string]any
}

func (w *FunctionResponse) toProto() *pb.FunctionResponse {
	if w == nil {
		return nil
	}
	return &pb.FunctionResponse{
		Name:     w.Name,
		Response: support.MapToStructPB(w.Response),
	}
}

func (FunctionResponse) fromProto(p *pb.FunctionResponse) *FunctionResponse {
	if p == nil {
		return nil
	}
	return &FunctionResponse{
		Name:     p.Name,
		Response: support.MapFromStructPB(p.Response),
	}
}

// GenerationConfig is generation config.
type GenerationConfig struct {
	// Optional. Controls the randomness of predictions.
	Temperature float32
	// Optional. If specified, nucleus sampling will be used.
	TopP float32
	// Optional. If specified, top-k sampling will be used.
	TopK float32
	// Optional. Number of candidates to generate.
	CandidateCount int32
	// Optional. The maximum number of output tokens to generate per message.
	MaxOutputTokens int32
	// Optional. Stop sequences.
	StopSequences []string
}

func (w *GenerationConfig) toProto() *pb.GenerationConfig {
	if w == nil {
		return nil
	}
	return &pb.GenerationConfig{
		Temperature:     support.ZeroToNil(w.Temperature),
		TopP:            support.ZeroToNil(w.TopP),
		TopK:            support.ZeroToNil(w.TopK),
		CandidateCount:  support.ZeroToNil(w.CandidateCount),
		MaxOutputTokens: support.ZeroToNil(w.MaxOutputTokens),
		StopSequences:   w.StopSequences,
	}
}

func (GenerationConfig) fromProto(p *pb.GenerationConfig) *GenerationConfig {
	if p == nil {
		return nil
	}
	return &GenerationConfig{
		Temperature:     support.NilToZero(p.Temperature),
		TopP:            support.NilToZero(p.TopP),
		TopK:            support.NilToZero(p.TopK),
		CandidateCount:  support.NilToZero(p.CandidateCount),
		MaxOutputTokens: support.NilToZero(p.MaxOutputTokens),
		StopSequences:   p.StopSequences,
	}
}

// HarmBlockThreshold specifies probability based thresholds levels for blocking.
type HarmBlockThreshold int32

const (
	// HarmBlockUnspecified means unspecified harm block threshold.
	HarmBlockUnspecified HarmBlockThreshold = 0
	// HarmBlockLowAndAbove means block low threshold and above (i.e. block more).
	HarmBlockLowAndAbove HarmBlockThreshold = 1
	// HarmBlockMediumAndAbove means block medium threshold and above.
	HarmBlockMediumAndAbove HarmBlockThreshold = 2
	// HarmBlockOnlyHigh means block only high threshold (i.e. block less).
	HarmBlockOnlyHigh HarmBlockThreshold = 3
	// HarmBlockNone means block none.
	HarmBlockNone HarmBlockThreshold = 4
)

// HarmCategory specifies harm categories that will block the content.
type HarmCategory int32

const (
	// HarmCategoryUnspecified means the harm category is unspecified.
	HarmCategoryUnspecified HarmCategory = 0
	// HarmCategoryHateSpeech means the harm category is hate speech.
	HarmCategoryHateSpeech HarmCategory = 1
	// HarmCategoryDangerousContent means the harm category is dangerous content.
	HarmCategoryDangerousContent HarmCategory = 2
	// HarmCategoryHarassment means the harm category is harassment.
	HarmCategoryHarassment HarmCategory = 3
	// HarmCategorySexuallyExplicit means the harm category is sexually explicit content.
	HarmCategorySexuallyExplicit HarmCategory = 4
)

// HarmProbability specifies harm probability levels in the content.
type HarmProbability int32

const (
	// HarmProbabilityUnspecified means harm probability unspecified.
	HarmProbabilityUnspecified HarmProbability = 0
	// HarmProbabilityNegligible means negligible level of harm.
	HarmProbabilityNegligible HarmProbability = 1
	// HarmProbabilityLow means low level of harm.
	HarmProbabilityLow HarmProbability = 2
	// HarmProbabilityMedium means medium level of harm.
	HarmProbabilityMedium HarmProbability = 3
	// HarmProbabilityHigh means high level of harm.
	HarmProbabilityHigh HarmProbability = 4
)

// PromptFeedback contains content filter results for a prompt sent in the request.
type PromptFeedback struct {
	// Output only. Blocked reason.
	BlockReason BlockedReason
	// Output only. Safety ratings.
	SafetyRatings []*SafetyRating
	// Output only. A readable block reason message.
	BlockReasonMessage string
}

func (w *PromptFeedback) toProto() *pb.GenerateContentResponse_PromptFeedback {
	if w == nil {
		return nil
	}
	return &pb.GenerateContentResponse_PromptFeedback{
		BlockReason:        pb.GenerateContentResponse_PromptFeedback_BlockedReason(w.BlockReason),
		SafetyRatings:      support.TransformSlice(w.SafetyRatings, (*SafetyRating).toProto),
		BlockReasonMessage: w.BlockReasonMessage,
	}
}

func (PromptFeedback) fromProto(p *pb.GenerateContentResponse_PromptFeedback) *PromptFeedback {
	if p == nil {
		return nil
	}
	return &PromptFeedback{
		BlockReason:        BlockedReason(p.BlockReason),
		SafetyRatings:      support.TransformSlice(p.SafetyRatings, (SafetyRating{}).fromProto),
		BlockReasonMessage: p.BlockReasonMessage,
	}
}

// SafetyRating is the safety rating corresponding to the generated content.
type SafetyRating struct {
	// Output only. Harm category.
	Category HarmCategory
	// Output only. Harm probability levels in the content.
	Probability HarmProbability
	// Output only. Indicates whether the content was filtered out because of this
	// rating.
	Blocked bool
}

func (w *SafetyRating) toProto() *pb.SafetyRating {
	if w == nil {
		return nil
	}
	return &pb.SafetyRating{
		Category:    pb.HarmCategory(w.Category),
		Probability: pb.SafetyRating_HarmProbability(w.Probability),
		Blocked:     w.Blocked,
	}
}

func (SafetyRating) fromProto(p *pb.SafetyRating) *SafetyRating {
	if p == nil {
		return nil
	}
	return &SafetyRating{
		Category:    HarmCategory(p.Category),
		Probability: HarmProbability(p.Probability),
		Blocked:     p.Blocked,
	}
}

// SafetySetting is safety settings.
type SafetySetting struct {
	// Required. Harm category.
	Category HarmCategory
	// Required. The harm block threshold.
	Threshold HarmBlockThreshold
}

func (w *SafetySetting) toProto() *pb.SafetySetting {
	if w == nil {
		return nil
	}
	return &pb.SafetySetting{
		Category:  pb.HarmCategory(w.Category),
		Threshold: pb.SafetySetting_HarmBlockThreshold(w.Threshold),
	}
}

func (SafetySetting) fromProto(p *pb.SafetySetting) *SafetySetting {
	if p == nil {
		return nil
	}
	return &SafetySetting{
		Category:  HarmCategory(p.Category),
		Threshold: HarmBlockThreshold(p.Threshold),
	}
}

// Schema is used to define the format of input/output data. Represents a select
// subset of an [OpenAPI 3.0 schema
// object](https://spec.openapis.org/oas/v3.0.3#schema). More fields may be
// added in the future as needed.
type Schema struct {
	// Optional. The type of the data.
	Type Type
	// Optional. The format of the data.
	// Supported formats:
	//  for NUMBER type: float, double
	//  for INTEGER type: int32, int64
	Format string
	// Optional. The description of the data.
	Description string
	// Optional. Indicates if the value may be null.
	Nullable bool
	// Optional. Schema of the elements of Type.ARRAY.
	Items *Schema
	// Optional. Possible values of the element of Type.STRING with enum format.
	// For example we can define an Enum Direction as :
	// {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
	Enum []string
	// Optional. Properties of Type.OBJECT.
	Properties map[string]*Schema
	// Optional. Required properties of Type.OBJECT.
	Required []string
}

func (w *Schema) toProto() *pb.Schema {
	if w == nil {
		return nil
	}
	return &pb.Schema{
		Type:        pb.Type(w.Type),
		Format:      w.Format,
		Description: w.Description,
		Nullable:    w.Nullable,
		Items:       w.Items.toProto(),
		Enum:        w.Enum,
		Properties:  support.TransformMapValues(w.Properties, (*Schema).toProto),
		Required:    w.Required,
	}
}

func (Schema) fromProto(p *pb.Schema) *Schema {
	if p == nil {
		return nil
	}
	return &Schema{
		Type:        Type(p.Type),
		Format:      p.Format,
		Description: p.Description,
		Nullable:    p.Nullable,
		Items:       (Schema{}).fromProto(p.Items),
		Enum:        p.Enum,
		Properties:  support.TransformMapValues(p.Properties, (Schema{}).fromProto),
		Required:    p.Required,
	}
}

// Tool details that the model may use to generate response.
//
// A `Tool` is a piece of code that enables the system to interact with
// external systems to perform an action, or set of actions, outside of
// knowledge and scope of the model.
type Tool struct {
	// Optional. One or more function declarations to be passed to the model along
	// with the current user query. Model may decide to call a subset of these
	// functions by populating [FunctionCall][content.part.function_call] in the
	// response. User should provide a
	// [FunctionResponse][content.part.function_response] for each function call
	// in the next turn. Based on the function responses, Model will generate the
	// final response back to the user. Maximum 64 function declarations can be
	// provided.
	FunctionDeclarations []*FunctionDeclaration
}

func (w *Tool) toProto() *pb.Tool {
	if w == nil {
		return nil
	}
	return &pb.Tool{
		FunctionDeclarations: support.TransformSlice(w.FunctionDeclarations, (*FunctionDeclaration).toProto),
	}
}

func (Tool) fromProto(p *pb.Tool) *Tool {
	if p == nil {
		return nil
	}
	return &Tool{
		FunctionDeclarations: support.TransformSlice(p.FunctionDeclarations, (FunctionDeclaration{}).fromProto),
	}
}

// Type contains the list of OpenAPI data types as defined by
// https://swagger.io/docs/specification/data-models/data-types/
type Type int32

const (
	// TypeUnspecified means not specified, should not be used.
	TypeUnspecified Type = 0
	// TypeString means openAPI string type
	TypeString Type = 1
	// TypeNumber means openAPI number type
	TypeNumber Type = 2
	// TypeInteger means openAPI integer type
	TypeInteger Type = 3
	// TypeBoolean means openAPI boolean type
	TypeBoolean Type = 4
	// TypeArray means openAPI array type
	TypeArray Type = 5
	// TypeObject means openAPI object type
	TypeObject Type = 6
)
