// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file was generated by protowrap. DO NOT EDIT.

package genai

import (
	"cloud.google.com/go/civil"
	pb "cloud.google.com/go/vertexai/internal/aiplatform/apiv1beta1/aiplatformpb"
)

// Blob contains raw media bytes.
//
// Text should not be sent as raw bytes, use the 'text' field.
type Blob struct {
	// Required. The IANA standard MIME type of the source data.
	MIMEType string
	// Required. Raw bytes for media formats.
	Data []byte
}

func (w *Blob) toProto() *pb.Blob {
	if w == nil {
		return nil
	}
	return &pb.Blob{
		MimeType: w.MIMEType,
		Data:     w.Data,
	}
}

func (Blob) fromProto(p *pb.Blob) *Blob {
	if p == nil {
		return nil
	}
	return &Blob{
		MIMEType: p.MimeType,
		Data:     p.Data,
	}
}

// BlockedReason is blocked reason enumeration.
type BlockedReason int32

const (
	// BlockedReasonUnspecified means unspecified blocked reason.
	BlockedReasonUnspecified BlockedReason = 0
	// BlockedReasonSafety means candidates blocked due to safety.
	BlockedReasonSafety BlockedReason = 1
	// BlockedReasonOther means candidates blocked due to other reason.
	BlockedReasonOther BlockedReason = 2
)

// Candidate is a response candidate generated from the model.
type Candidate struct {
	// Output only. Index of the candidate.
	Index int32
	// Output only. Content parts of the candidate.
	Content *Content
	// Output only. The reason why the model stopped generating tokens.
	// If empty, the model has not stopped generating the tokens.
	FinishReason FinishReason
	// Output only. List of ratings for the safety of a response candidate.
	//
	// There is at most one rating per category.
	SafetyRatings []*SafetyRating
	// Output only. Describes the reason the mode stopped generating tokens in
	// more detail. This is only filled when `finish_reason` is set.
	FinishMessage string
	// Output only. Source attribution of the generated content.
	CitationMetadata *CitationMetadata
}

func (w *Candidate) toProto() *pb.Candidate {
	if w == nil {
		return nil
	}
	return &pb.Candidate{
		Index:            w.Index,
		Content:          (*w.Content).toProto(),
		FinishReason:     pb.Candidate_FinishReason(w.FinishReason),
		SafetyRatings:    mapSlice(w.SafetyRatings, (*SafetyRating).toProto),
		FinishMessage:    zeroToNil(w.FinishMessage),
		CitationMetadata: (*w.CitationMetadata).toProto(),
	}
}

func (Candidate) fromProto(p *pb.Candidate) *Candidate {
	if p == nil {
		return nil
	}
	return &Candidate{
		Index:            p.Index,
		Content:          (Content{}).fromProto(p.Content),
		FinishReason:     FinishReason(p.FinishReason),
		SafetyRatings:    mapSlice(p.SafetyRatings, (SafetyRating{}).fromProto),
		FinishMessage:    nilToZero(p.FinishMessage),
		CitationMetadata: (CitationMetadata{}).fromProto(p.CitationMetadata),
	}
}

// Citation contains source attributions for content.
type Citation struct {
	// Output only. Start index into the content.
	StartIndex int32
	// Output only. End index into the content.
	EndIndex int32
	// Output only. Url reference of the attribution.
	URI string
	// Output only. Title of the attribution.
	Title string
	// Output only. License of the attribution.
	License string
	// Output only. Publication date of the attribution.
	PublicationDate civil.Date
}

func (w *Citation) toProto() *pb.Citation {
	if w == nil {
		return nil
	}
	return &pb.Citation{
		StartIndex:      w.StartIndex,
		EndIndex:        w.EndIndex,
		Uri:             w.URI,
		Title:           w.Title,
		License:         w.License,
		PublicationDate: civilDateToProto(w.PublicationDate),
	}
}

func (Citation) fromProto(p *pb.Citation) *Citation {
	if p == nil {
		return nil
	}
	return &Citation{
		StartIndex:      p.StartIndex,
		EndIndex:        p.EndIndex,
		URI:             p.Uri,
		Title:           p.Title,
		License:         p.License,
		PublicationDate: civilDateFromProto(p.PublicationDate),
	}
}

// CitationMetadata is a collection of source attributions for a piece of content.
type CitationMetadata struct {
	// Output only. List of citations.
	Citations []*Citation
}

func (w *CitationMetadata) toProto() *pb.CitationMetadata {
	if w == nil {
		return nil
	}
	return &pb.CitationMetadata{
		Citations: mapSlice(w.Citations, (*Citation).toProto),
	}
}

func (CitationMetadata) fromProto(p *pb.CitationMetadata) *CitationMetadata {
	if p == nil {
		return nil
	}
	return &CitationMetadata{
		Citations: mapSlice(p.Citations, (Citation{}).fromProto),
	}
}

// Content is the base structured datatype containing multi-part content of a message.
//
// A `Content` includes a `role` field designating the producer of the `Content`
// and a `parts` field containing multi-part data that contains the content of
// the message turn.
type Content struct {
	// Optional. The producer of the content. Must be either 'user' or 'model'.
	//
	// Useful to set for multi-turn conversations, otherwise can be left blank
	// or unset.
	Role string
	// Required. Ordered `Parts` that constitute a single message. Parts may have
	// different IANA MIME types.
	Parts []Part
}

func (w *Content) toProto() *pb.Content {
	if w == nil {
		return nil
	}
	return &pb.Content{
		Role:  w.Role,
		Parts: mapSlice(w.Parts, partToProto),
	}
}

func (Content) fromProto(p *pb.Content) *Content {
	if p == nil {
		return nil
	}
	return &Content{
		Role:  p.Role,
		Parts: mapSlice(p.Parts, partFromProto),
	}
}

// CountTokensRequest is request message for
// [PredictionService.CountTokens][google.cloud.aiplatform.v1beta1.PredictionService.CountTokens].
type CountTokensRequest struct {
	// Required. The name of the Endpoint requested to perform token counting.
	// Format:
	// `projects/{project}/locations/{location}/endpoints/{endpoint}`
	Endpoint string
	// Required. The name of the publisher model requested to serve the
	// prediction. Format:
	// `projects/{project}/locations/{location}/publishers/*/models/*`
	Model string
	// Required. Input content.
	Contents []*Content
}

func (w *CountTokensRequest) toProto() *pb.CountTokensRequest {
	if w == nil {
		return nil
	}
	return &pb.CountTokensRequest{
		Endpoint: w.Endpoint,
		Model:    w.Model,
		Contents: mapSlice(w.Contents, (*Content).toProto),
	}
}

func (CountTokensRequest) fromProto(p *pb.CountTokensRequest) *CountTokensRequest {
	if p == nil {
		return nil
	}
	return &CountTokensRequest{
		Endpoint: p.Endpoint,
		Model:    p.Model,
		Contents: mapSlice(p.Contents, (Content{}).fromProto),
	}
}

// CountTokensResponse is response message for
// [PredictionService.CountTokens][google.cloud.aiplatform.v1beta1.PredictionService.CountTokens].
type CountTokensResponse struct {
	// The total number of tokens counted across all instances from the request.
	TotalTokens int32
	// The total number of billable characters counted across all instances from
	// the request.
	TotalBillableCharacters int32
}

func (w *CountTokensResponse) toProto() *pb.CountTokensResponse {
	if w == nil {
		return nil
	}
	return &pb.CountTokensResponse{
		TotalTokens:             w.TotalTokens,
		TotalBillableCharacters: w.TotalBillableCharacters,
	}
}

func (CountTokensResponse) fromProto(p *pb.CountTokensResponse) *CountTokensResponse {
	if p == nil {
		return nil
	}
	return &CountTokensResponse{
		TotalTokens:             p.TotalTokens,
		TotalBillableCharacters: p.TotalBillableCharacters,
	}
}

// FileData is URI based data.
type FileData struct {
	// Required. The IANA standard MIME type of the source data.
	MIMEType string
	// Required. URI.
	FileURI string
}

func (w *FileData) toProto() *pb.FileData {
	if w == nil {
		return nil
	}
	return &pb.FileData{
		MimeType: w.MIMEType,
		FileUri:  w.FileURI,
	}
}

func (FileData) fromProto(p *pb.FileData) *FileData {
	if p == nil {
		return nil
	}
	return &FileData{
		MIMEType: p.MimeType,
		FileURI:  p.FileUri,
	}
}

// FinishReason is the reason why the model stopped generating tokens.
// If empty, the model has not stopped generating the tokens.
type FinishReason int32

const (
	// FinishReasonUnspecified means the finish reason is unspecified.
	FinishReasonUnspecified FinishReason = 0
	// FinishReasonStop means natural stop point of the model or provided stop sequence.
	FinishReasonStop FinishReason = 1
	// FinishReasonMaxTokens means the maximum number of tokens as specified in the request was reached.
	FinishReasonMaxTokens FinishReason = 2
	// FinishReasonSafety means the token generation was stopped as the response was flagged for safety
	// reasons. NOTE: When streaming the Candidate.content will be empty if
	// content filters blocked the output.
	FinishReasonSafety FinishReason = 3
	// FinishReasonRecitation means the token generation was stopped as the response was flagged for
	// unauthorized citations.
	FinishReasonRecitation FinishReason = 4
	// FinishReasonOther means all other reasons that stopped the token generation
	FinishReasonOther FinishReason = 5
)

// GenerationConfig is generation config.
type GenerationConfig struct {
	// Optional. Controls the randomness of predictions.
	Temperature float32
	// Optional. If specified, nucleus sampling will be used.
	TopP float32
	// Optional. If specified, top-k sampling will be used.
	TopK float32
	// Optional. Number of candidates to generate.
	CandidateCount int32
	// Optional. The maximum number of output tokens to generate per message.
	MaxOutputTokens int32
	// Optional. Stop sequences.
	StopSequences []string
}

func (w *GenerationConfig) toProto() *pb.GenerationConfig {
	if w == nil {
		return nil
	}
	return &pb.GenerationConfig{
		Temperature:     zeroToNil(w.Temperature),
		TopP:            zeroToNil(w.TopP),
		TopK:            zeroToNil(w.TopK),
		CandidateCount:  zeroToNil(w.CandidateCount),
		MaxOutputTokens: zeroToNil(w.MaxOutputTokens),
		StopSequences:   w.StopSequences,
	}
}

func (GenerationConfig) fromProto(p *pb.GenerationConfig) *GenerationConfig {
	if p == nil {
		return nil
	}
	return &GenerationConfig{
		Temperature:     nilToZero(p.Temperature),
		TopP:            nilToZero(p.TopP),
		TopK:            nilToZero(p.TopK),
		CandidateCount:  nilToZero(p.CandidateCount),
		MaxOutputTokens: nilToZero(p.MaxOutputTokens),
		StopSequences:   p.StopSequences,
	}
}

// HarmBlockThreshold specifies probability based thresholds levels for blocking.
type HarmBlockThreshold int32

const (
	// HarmBlockUnspecified means unspecified harm block threshold.
	HarmBlockUnspecified HarmBlockThreshold = 0
	// HarmBlockLowAndAbove means block low threshold and above (i.e. block more).
	HarmBlockLowAndAbove HarmBlockThreshold = 1
	// HarmBlockMediumAndAbove means block medium threshold and above.
	HarmBlockMediumAndAbove HarmBlockThreshold = 2
	// HarmBlockOnlyHigh means block only high threshold (i.e. block less).
	HarmBlockOnlyHigh HarmBlockThreshold = 3
	// HarmBlockNone means block none.
	HarmBlockNone HarmBlockThreshold = 4
)

// HarmCategory specifies harm categories that will block the content.
type HarmCategory int32

const (
	// HarmCategoryUnspecified means the harm category is unspecified.
	HarmCategoryUnspecified HarmCategory = 0
	// HarmCategoryHateSpeech means the harm category is hate speech.
	HarmCategoryHateSpeech HarmCategory = 1
	// HarmCategoryDangerousContent means the harm category is dangerous content.
	HarmCategoryDangerousContent HarmCategory = 2
	// HarmCategoryHarassment means the harm category is harassment.
	HarmCategoryHarassment HarmCategory = 3
	// HarmCategorySexuallyExplicit means the harm category is sexually explicit content.
	HarmCategorySexuallyExplicit HarmCategory = 4
)

// HarmProbability specifies harm probability levels in the content.
type HarmProbability int32

const (
	// HarmProbabilityUnspecified means harm probability unspecified.
	HarmProbabilityUnspecified HarmProbability = 0
	// HarmProbabilityNegligible means negligible level of harm.
	HarmProbabilityNegligible HarmProbability = 1
	// HarmProbabilityLow means low level of harm.
	HarmProbabilityLow HarmProbability = 2
	// HarmProbabilityMedium means medium level of harm.
	HarmProbabilityMedium HarmProbability = 3
	// HarmProbabilityHigh means high level of harm.
	HarmProbabilityHigh HarmProbability = 4
)

// PromptFeedback contains content filter results for a prompt sent in the request.
type PromptFeedback struct {
	// Output only. Blocked reason.
	BlockReason BlockedReason
	// Output only. Safety ratings.
	SafetyRatings []*SafetyRating
	// Output only. A readable block reason message.
	BlockReasonMessage string
}

func (w *PromptFeedback) toProto() *pb.GenerateContentResponse_PromptFeedback {
	if w == nil {
		return nil
	}
	return &pb.GenerateContentResponse_PromptFeedback{
		BlockReason:        pb.GenerateContentResponse_PromptFeedback_BlockedReason(w.BlockReason),
		SafetyRatings:      mapSlice(w.SafetyRatings, (*SafetyRating).toProto),
		BlockReasonMessage: w.BlockReasonMessage,
	}
}

func (PromptFeedback) fromProto(p *pb.GenerateContentResponse_PromptFeedback) *PromptFeedback {
	if p == nil {
		return nil
	}
	return &PromptFeedback{
		BlockReason:        BlockedReason(p.BlockReason),
		SafetyRatings:      mapSlice(p.SafetyRatings, (SafetyRating{}).fromProto),
		BlockReasonMessage: p.BlockReasonMessage,
	}
}

// SafetyRating is the safety rating corresponding to the generated content.
type SafetyRating struct {
	// Output only. Harm category.
	Category HarmCategory
	// Output only. Harm probability levels in the content.
	Probability HarmProbability
	// Output only. Indicates whether the content was filtered out because of this
	// rating.
	Blocked bool
}

func (w *SafetyRating) toProto() *pb.SafetyRating {
	if w == nil {
		return nil
	}
	return &pb.SafetyRating{
		Category:    pb.HarmCategory(w.Category),
		Probability: pb.SafetyRating_HarmProbability(w.Probability),
		Blocked:     w.Blocked,
	}
}

func (SafetyRating) fromProto(p *pb.SafetyRating) *SafetyRating {
	if p == nil {
		return nil
	}
	return &SafetyRating{
		Category:    HarmCategory(p.Category),
		Probability: HarmProbability(p.Probability),
		Blocked:     p.Blocked,
	}
}

// SafetySetting is safety settings.
type SafetySetting struct {
	// Required. Harm category.
	Category HarmCategory
	// Required. The harm block threshold.
	Threshold HarmBlockThreshold
}

func (w *SafetySetting) toProto() *pb.SafetySetting {
	if w == nil {
		return nil
	}
	return &pb.SafetySetting{
		Category:  pb.HarmCategory(w.Category),
		Threshold: pb.SafetySetting_HarmBlockThreshold(w.Threshold),
	}
}

func (SafetySetting) fromProto(p *pb.SafetySetting) *SafetySetting {
	if p == nil {
		return nil
	}
	return &SafetySetting{
		Category:  HarmCategory(p.Category),
		Threshold: HarmBlockThreshold(p.Threshold),
	}
}
